<?xml version="1.0" encoding="UTF-8"?>
<Root name="strings">
    <methods>
        <method>
            <name>addcslashes</name>
            <signature><![CDATA[string addcslashes ( string str, string charlist)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107642" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >addcslashes</B
> ( string str, string charlist)<BR  ></BR
><P  >     Returns a string with backslashes before characters that are
     listed in <TT  CLASS="parameter" ><I  >charlist</I
></TT
> parameter. It escapes
     <TT  CLASS="literal" >\n</TT
>, <TT  CLASS="literal" >\r</TT
> etc. in C-like
     style, characters with ASCII code lower than 32 and higher than
     126 are converted to octal representation. 
    </P
><P  >     Be careful if you choose to escape characters 0, a, b, f, n, r, 
     t and v. They will be converted to \0, \a, \b, \f, \n, \r, \t 
     and \v. 
     In PHP \0 (<TT  CLASS="constant" ><B  >NULL</B
></TT
>), \r (carriage return), \n (newline) and \t (tab) 
     are predefined escape sequences, while in C all of these are 
     predefined escape sequences.
    </P
><P  >     <TT  CLASS="parameter" ><I  >charlist</I
></TT
> like "\0..\37", which would
     escape all characters with ASCII code between 0 and 37.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN107661" ></A
><P  ><B  >例子 1. <B  CLASS="function" >addcslashes()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$escaped </font><font  color="#007700">= </font><font  color="#0000BB">addcslashes</font><font  color="#007700">(</font><font  color="#0000BB">$not_escaped</font><font  color="#007700">, </font><font  color="#DD0000">"\0..\37!@\177..\377"</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     When you define a sequence of characters in the charlist argument
     make sure that you know what characters come between the
     characters that you set as the start and end of the range.
     </P><DIV  CLASS="informalexample" ><A  NAME="AEN107666" ></A
><P  ></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">addcslashes</font><font  color="#007700">(</font><font  color="#DD0000">'foo[ ]'</font><font  color="#007700">, </font><font  color="#DD0000">'A..z'</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// output:  \f\o\o\[ \]<br  />// All upper and lower-case letters will be escaped<br  />// ... but so will the [\]^_` and any tabs, line<br  />// feeds, carriage returns, etc.<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  ></P
></DIV
>
     Also, if the first character in a range has a higher ASCII value
     than the second character in the range, no range will be
     constructed.  Only the start, end and period characters will be
     escaped. Use the <SPAN HREF="#"><B  CLASS="function" >ord()</B
></A
> function to find the
     ASCII value for a character.
     <DIV  CLASS="informalexample" ><A  NAME="AEN107669" ></A
><P  ></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">addcslashes</font><font  color="#007700">(</font><font  color="#DD0000">"zoo['.']"</font><font  color="#007700">, </font><font  color="#DD0000">'z..A'</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// output:  \zoo['\.']<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  ></P
></DIV
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >stripcslashes()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >stripslashes()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>, and 
     <SPAN HREF="#"><B  CLASS="function" >quotemeta()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>addslashes</name>
            <signature><![CDATA[string addslashes ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107680" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >addslashes</B
> ( string str)<BR  ></BR
><P  >     Returns a string with backslashes before characters that need
     to be quoted in database queries etc.  These characters are
     single quote (<TT  CLASS="literal" >'</TT
>), double quote
     (<TT  CLASS="literal" >"</TT
>), backslash (<TT  CLASS="literal" >\</TT
>)
     and NUL (the <TT  CLASS="constant" ><B  >NULL</B
></TT
> byte).
    </P
><P  >     An example use of <B  CLASS="function" >addslashes()</B
> is when you're
     entering data into a database.  For example, to insert the name 
     <TT  CLASS="literal" >O'reilly</TT
> into a database, you will need to escape
     it.  Most databases do this with a <TT  CLASS="literal" >\</TT
> which would
     mean <TT  CLASS="literal" >O\'reilly</TT
>.  This would only be to get the data
     into the database, the extra <TT  CLASS="literal" >\</TT
> will not be inserted.
     Having the PHP directive <SPAN HREF="#">     magic_quotes_sybase</A
> set to <TT  CLASS="literal" >on</TT
> will mean 
     <TT  CLASS="literal" >'</TT
> is instead escaped with another 
     <TT  CLASS="literal" >'</TT
>.
    </P
><P  >     The PHP directive <SPAN HREF="#">     magic_quotes_gpc</A
> is <TT  CLASS="literal" >on</TT
> by default, and it 
     essentially runs <B  CLASS="function" >addslashes()</B
> on all GET, POST,
     and COOKIE data.  Do not use <B  CLASS="function" >addslashes()</B
> on
     strings that have already been escaped with 
     <SPAN HREF="#">magic_quotes_gpc</A
> as you'll
     then do double escaping.  The function
     <SPAN HREF="#"><B  CLASS="function" >get_magic_quotes_gpc()</B
></A
> may come in handy for 
     checking this.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN107711" ></A
><P  ><B  >例子 1. An <B  CLASS="function" >addslashes()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"Is your name O'reilly?"</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// Outputs: Is your name O\'reilly?<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">addslashes</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >stripslashes()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >quotemeta()</B
></A
>, and 
     <SPAN HREF="#"><B  CLASS="function" >get_magic_quotes_gpc()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>bin2hex</name>
            <signature><![CDATA[string bin2hex ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107724" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >bin2hex</B
> ( string str)<BR  ></BR
><P  >     Returns an ASCII string containing the hexadecimal representation
     of <TT  CLASS="parameter" ><I  >str</I
></TT
>. The conversion is done byte-wise
     with the high-nibble first.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >pack()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >unpack()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>chop</name>
            <signature><![CDATA[]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107742" ></A
><H2  >Description</H2
><P  >     This function is an alias of <SPAN HREF="#"><B  CLASS="function" >rtrim()</B
></A
>.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      <B  CLASS="function" >chop()</B
> is different than the Perl
      <TT  CLASS="literal" >chop()</TT
> function, which removes the last
      character in the string.
     </P
></BLOCKQUOTE
></DIV
></DIV
>]]></description>
        </method>
        <method>
            <name>chr</name>
            <signature><![CDATA[string chr ( int ascii)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107754" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >chr</B
> ( int ascii)<BR  ></BR
><P  >     Returns a one-character string containing the character specified
     by <TT  CLASS="parameter" ><I  >ascii</I
></TT
>.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN107764" ></A
><P  ><B  >例子 1. <B  CLASS="function" >chr()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"The string ends in escape: "</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$str </font><font  color="#007700">.= </font><font  color="#0000BB">chr</font><font  color="#007700">(</font><font  color="#0000BB">27</font><font  color="#007700">); </font><font  color="#FF8000">/* add an escape character at the end of $str */<br  /><br  />/* Often this is more useful */<br  /><br  /></font><font  color="#0000BB">$str </font><font  color="#007700">= </font><font  color="#0000BB">sprintf</font><font  color="#007700">(</font><font  color="#DD0000">"The string ends in escape: %c"</font><font  color="#007700">, </font><font  color="#0000BB">27</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     You can find an ASCII-table over here: <SPAN HREF="#">http://www.asciitable.com</A
>.
    </P
><P  >     This function complements <SPAN HREF="#"><B  CLASS="function" >ord()</B
></A
>. See also
     <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
> with a format string of
     <TT  CLASS="literal" >%c</TT
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>chunk_split</name>
            <signature><![CDATA[string chunk_split ( string body [, int chunklen [, string end]])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107778" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >chunk_split</B
> ( string body [, int chunklen [, string end]])<BR  ></BR
><P  >     Can be used to split a string into smaller chunks which is useful for
     e.g. converting <SPAN HREF="#">base64_encode</A
> output to match RFC
     2045 semantics. It inserts <TT  CLASS="parameter" ><I  >end</I
></TT
> (defaults to
     "\r\n") every <TT  CLASS="parameter" ><I  >chunklen</I
></TT
> characters (defaults to
     76). It returns the new string leaving the original string untouched.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN107796" ></A
><P  ><B  >例子 1. <B  CLASS="function" >chunk_split()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#FF8000">// format $data using RFC 2045 semantics<br  /></font><font  color="#0000BB">$new_string </font><font  color="#007700">= </font><font  color="#0000BB">chunk_split</font><font  color="#007700">(</font><font  color="#0000BB">base64_encode</font><font  color="#007700">(</font><font  color="#0000BB">$data</font><font  color="#007700">));<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >str_split()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >explode()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >split()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >wordwrap()</B
></A
> and
     <SPAN HREF="#">RFC 2045</A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>convert_cyr_string</name>
            <signature><![CDATA[string convert_cyr_string ( string str, string from, string to)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107810" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >convert_cyr_string</B
> ( string str, string from, string to)<BR  ></BR
><P  >     This function returns the given string converted from one
     Cyrillic character set to another.  The <TT  CLASS="parameter" ><I  >from</I
></TT
>
     and <TT  CLASS="parameter" ><I  >to</I
></TT
> arguments are single characters that
     represent the source and target Cyrillic character sets.  The
     supported types are:
     </P><P  ></P
><UL  ><LI  ><P  >        k - koi8-r
       </P
></LI
><LI  ><P  >        w - windows-1251
       </P
></LI
><LI  ><P  >        i - iso8859-5
       </P
></LI
><LI  ><P  >        a - x-cp866
       </P
></LI
><LI  ><P  >        d - x-cp866
       </P
></LI
><LI  ><P  >        m - x-mac-cyrillic
       </P
></LI
></UL
>
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>count_chars</name>
            <signature><![CDATA[mixed count_chars ( string string [, int mode])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107844" ></A
><H2  >Description</H2
>mixed <B  CLASS="methodname" >count_chars</B
> ( string string [, int mode])<BR  ></BR
><P  >     Counts the number of occurrences of every byte-value (0..255) in
     <TT  CLASS="parameter" ><I  >string</I
></TT
> and returns it in various ways.
     The optional parameter <TT  CLASS="parameter" ><I  >mode</I
></TT
> default to
     0. Depending on <TT  CLASS="parameter" ><I  >mode</I
></TT
>
     <B  CLASS="function" >count_chars()</B
> returns one of the following:
     </P><P  ></P
><UL  ><LI  ><P  >        0 - an array with the byte-value as key and the frequency of
        every byte as value.
       </P
></LI
><LI  ><P  >        1 - same as 0 but only byte-values with a frequency greater
        than zero are listed.
       </P
></LI
><LI  ><P  >        2 - same as 0 but only byte-values with a frequency equal to
        zero are listed.
       </P
></LI
><LI  ><P  > 
        3 - a string containing all used byte-values is returned.
       </P
></LI
><LI  ><P  > 
        4 - a string containing all not used byte-values is returned.
       </P
></LI
></UL
>
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN107872" ></A
><P  ><B  >例子 1. <B  CLASS="function" >count_chars()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$data </font><font  color="#007700">= </font><font  color="#DD0000">"Two Ts and one F."</font><font  color="#007700">;<br  /><br  /></font><font  color="#0000BB">$result </font><font  color="#007700">= </font><font  color="#0000BB">count_chars</font><font  color="#007700">(</font><font  color="#0000BB">$data</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">);<br  /><br  />for (</font><font  color="#0000BB">$i</font><font  color="#007700">=</font><font  color="#0000BB">0</font><font  color="#007700">; </font><font  color="#0000BB">$i </font><font  color="#007700">< </font><font  color="#0000BB">count</font><font  color="#007700">(</font><font  color="#0000BB">$result</font><font  color="#007700">); </font><font  color="#0000BB">$i</font><font  color="#007700">++) {<br  />   if (</font><font  color="#0000BB">$result</font><font  color="#007700">[</font><font  color="#0000BB">$i</font><font  color="#007700">] != </font><font  color="#0000BB">0</font><font  color="#007700">)<br  />       echo </font><font  color="#DD0000">"There were $result[$i] instance(s) of \"" </font><font  color="#007700">, </font><font  color="#0000BB">chr</font><font  color="#007700">(</font><font  color="#0000BB">$i</font><font  color="#007700">) , </font><font  color="#DD0000">"\" in the string.\n"</font><font  color="#007700">;<br  />}<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >       This will output :
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >There were 4 instance(s) of " " in the string. 
There were 1 instance(s) of "." in the string. 
There were 1 instance(s) of "F" in the string. 
There were 2 instance(s) of "T" in the string. 
There were 1 instance(s) of "a" in the string. 
There were 1 instance(s) of "d" in the string. 
There were 1 instance(s) of "e" in the string. 
There were 2 instance(s) of "n" in the string. 
There were 2 instance(s) of "o" in the string. 
There were 1 instance(s) of "s" in the string. 
There were 1 instance(s) of "w" in the string.</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
> 
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strpos()</B
></A
> and
     <SPAN HREF="#"><B  CLASS="function" >substr_count()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>crc32</name>
            <signature><![CDATA[int crc32 ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107885" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >crc32</B
> ( string str)<BR  ></BR
><P  >     Generates the cyclic redundancy checksum polynomial of 32-bit
     lengths of the <TT  CLASS="parameter" ><I  >str</I
></TT
>. This is usually used
     to validate the integrity of data being transmitted.
    </P
><P  >     Because PHP's integer type is signed, and many crc32 checksums will
     result in negative integers, you need to use the "%u" formatter of
     <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
> or <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
> to get
     the string representation of the unsigned crc32 checksum.
    </P
><P  >     This second example shows how to print a converted checksum with the
     <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
> function:
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN107900" ></A
><P  ><B  >例子 1. Displaying a crc32 checksum</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$checksum </font><font  color="#007700">= </font><font  color="#0000BB">crc32</font><font  color="#007700">(</font><font  color="#DD0000">"The quick brown fox jumped over the lazy dog."</font><font  color="#007700">);<br  /></font><font  color="#0000BB">printf</font><font  color="#007700">(</font><font  color="#DD0000">"%u\n"</font><font  color="#007700">, </font><font  color="#0000BB">$checksum</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >md5()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >sha1()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>crypt</name>
            <signature><![CDATA[string crypt ( string str [, string salt])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107910" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >crypt</B
> ( string str [, string salt])<BR  ></BR
><P  >     <B  CLASS="function" >crypt()</B
> will return an encrypted string using the
     standard Unix <SPAN  CLASS="abbrev" >DES</SPAN
>-based encryption algorithm or
     alternative algorithms that may be available on the system.  Arguments
     are a string to be encrypted and an optional salt string to base the
     encryption on.  See the Unix man page for your crypt function for more
     information.
    </P
><P  >     If the salt argument is not provided, one will be randomly
     generated by PHP.
    </P
><P  >     Some operating systems support more than one type of encryption.  In
     fact, sometimes the standard DES-based encryption is replaced by an
     MD5-based encryption algorithm.  The encryption type is triggered by the
     salt argument.  At install time, PHP determines the capabilities of the
     crypt function and will accept salts for other encryption types.  If no
     salt is provided, PHP will auto-generate a standard two character salt by
     default, unless the default encryption type on the system is MD5, in
     which case a random MD5-compatible salt is generated.  PHP sets a
     constant named CRYPT_SALT_LENGTH which tells you whether a regular two
     character salt applies to your system or the longer twelve character salt
     is applicable.
    </P
><P  >     If you are using the supplied salt, you should be aware that the salt is
     generated once. If you are calling this function recursively, this may
     impact both appearance and security.
    </P
><P  >     The standard DES-based encryption <B  CLASS="function" >crypt()</B
> returns the
     salt as the first two characters of the output. It also only uses the
     first eight characters of <TT  CLASS="parameter" ><I  >str</I
></TT
>, so longer strings
     that start with the same eight characters will generate the same result
     (when the same salt is used).
    </P
><P  >     On systems where the crypt() function supports multiple
     encryption types, the following constants are set to 0 or 1
     depending on whether the given type is available:
    </P
><P  ></P
><UL  ><LI  ><P  >       CRYPT_STD_DES - Standard DES-based encryption with a two character salt
      </P
></LI
><LI  ><P  >       CRYPT_EXT_DES - Extended DES-based encryption with a nine character salt
      </P
></LI
><LI  ><P  >       CRYPT_MD5 - MD5 encryption with a twelve character salt starting with
       $1$
      </P
></LI
><LI  ><P  >       CRYPT_BLOWFISH - Blowfish encryption with a sixteen character salt
       starting with $2$
      </P
></LI
></UL
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      There is no decrypt function, since <B  CLASS="function" >crypt()</B
>
      uses a one-way algorithm.
     </P
></BLOCKQUOTE
></DIV
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN107943" ></A
><P  ><B  >例子 1. <B  CLASS="function" >crypt()</B
> examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$password </font><font  color="#007700">= </font><font  color="#0000BB">crypt</font><font  color="#007700">(</font><font  color="#DD0000">"My1sTpassword"</font><font  color="#007700">); </font><font  color="#FF8000">// let salt be generated<br  /><br  /># You should pass the entire results of crypt() as the salt for comparing a<br  /># password, to avoid problems when different hashing algorithms are used. (As<br  /># it says above, standard DES-based password hashing uses a 2-character salt,<br  /># but MD5-based hashing uses 12.)<br  /></font><font  color="#007700">if (</font><font  color="#0000BB">crypt</font><font  color="#007700">(</font><font  color="#0000BB">$user_input</font><font  color="#007700">, </font><font  color="#0000BB">$password</font><font  color="#007700">) == </font><font  color="#0000BB">$password</font><font  color="#007700">) {<br  />   echo </font><font  color="#DD0000">"Password verified!"</font><font  color="#007700">;<br  />}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >md5()</B
></A
> and <SPAN HREF="#">the
     Mcrypt extension</A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>echo</name>
            <signature><![CDATA[void echo ( string arg1 [, string argn...])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107954" ></A
><H2  >Description</H2
>void <B  CLASS="methodname" >echo</B
> ( string arg1 [, string argn...])<BR  ></BR
><P  >     Outputs all parameters.
    </P
><P  >     <B  CLASS="function" >echo()</B
> is not actually a function (it is a
     language construct) so you are not required to use parentheses
     with it. In fact, if you want to pass more than one parameter
     to echo, you must not enclose the parameters within parentheses.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN107969" ></A
><P  ><B  >例子 1. <B  CLASS="function" >echo()</B
> examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#007700">echo </font><font  color="#DD0000">"Hello World"</font><font  color="#007700">;<br  /><br  />echo </font><font  color="#DD0000">"This spans<br  />multiple lines. The newlines will be <br  />output as well"</font><font  color="#007700">;<br  /><br  />echo </font><font  color="#DD0000">"This spans\nmultiple lines. The newlines will be\noutput as well."</font><font  color="#007700">;<br  /><br  />echo </font><font  color="#DD0000">"Escaping characters is done \"Like this\"."</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// You can use variables inside of an echo statement<br  /></font><font  color="#0000BB">$foo </font><font  color="#007700">= </font><font  color="#DD0000">"foobar"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= </font><font  color="#DD0000">"barbaz"</font><font  color="#007700">;<br  /><br  />echo </font><font  color="#DD0000">"foo is $foo"</font><font  color="#007700">; </font><font  color="#FF8000">// foo is foobar<br  /><br  />// You can also use arrays<br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= array(</font><font  color="#DD0000">"value" </font><font  color="#007700">=> </font><font  color="#DD0000">"foo"</font><font  color="#007700">);<br  /><br  />echo </font><font  color="#DD0000">"this is {$bar['value']} !"</font><font  color="#007700">; </font><font  color="#FF8000">// this is foo !<br  /><br  />// Using single quotes will print the variable name, not the value<br  /></font><font  color="#007700">echo </font><font  color="#DD0000">'foo is $foo'</font><font  color="#007700">; </font><font  color="#FF8000">// foo is $foo<br  /><br  />// If you are not using any other characters, you can just echo variables<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$foo</font><font  color="#007700">;          </font><font  color="#FF8000">// foobar<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$foo</font><font  color="#007700">,</font><font  color="#0000BB">$bar</font><font  color="#007700">;     </font><font  color="#FF8000">// foobarbarbaz<br  /><br  />// Some people prefer passing multiple parameters to echo over concatenation.<br  /></font><font  color="#007700">echo </font><font  color="#DD0000">'This '</font><font  color="#007700">, </font><font  color="#DD0000">'string '</font><font  color="#007700">, </font><font  color="#DD0000">'was '</font><font  color="#007700">, </font><font  color="#DD0000">'made '</font><font  color="#007700">, </font><font  color="#DD0000">'with multiple parameters.'</font><font  color="#007700">, </font><font  color="#0000BB">chr</font><font  color="#007700">(</font><font  color="#0000BB">10</font><font  color="#007700">);<br  />echo </font><font  color="#DD0000">'This ' </font><font  color="#007700">. </font><font  color="#DD0000">'string ' </font><font  color="#007700">. </font><font  color="#DD0000">'was ' </font><font  color="#007700">. </font><font  color="#DD0000">'made ' </font><font  color="#007700">. </font><font  color="#DD0000">'with concatenation.' </font><font  color="#007700">. </font><font  color="#DD0000">"\n"</font><font  color="#007700">;<br  /><br  />echo <<<END<br  /></font><font  color="#0000BB">This uses the "here document" syntax to output<br  />multiple lines with $variable interpolation. Note<br  />that the here document terminator must appear on a<br  />line with just a semicolon. no extra whitespace!<br  /></font><font  color="#007700">END;<br  /></font><font  color="#FF8000">// Because echo is not a function, following code is invalid. <br  /></font><font  color="#007700">(</font><font  color="#0000BB">$some_var</font><font  color="#007700">) ? echo </font><font  color="#DD0000">'true' </font><font  color="#007700">: echo </font><font  color="#DD0000">'false'</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// However, the following examples will work:<br  /></font><font  color="#007700">(</font><font  color="#0000BB">$some_var</font><font  color="#007700">) ? print(</font><font  color="#DD0000">'true'</font><font  color="#007700">): print(</font><font  color="#DD0000">'false'</font><font  color="#007700">); </font><font  color="#FF8000">// print is a function<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$some_var </font><font  color="#007700">? </font><font  color="#DD0000">'true'</font><font  color="#007700">: </font><font  color="#DD0000">'false'</font><font  color="#007700">; </font><font  color="#FF8000">// changing the statement around<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     <B  CLASS="function" >echo()</B
> also has a shortcut syntax, where you can
     immediately follow the opening tag with an equals sign. This short syntax
     only works with the <SPAN HREF="#">short_open_tag</A
> configuration setting
     enabled.
     </P><DIV  CLASS="informalexample" ><A  NAME="AEN107976" ></A
><P  ></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
I have <font  color="#0000BB"><?=$foo?></font> foo.</font>
</code></TD
></TR
></TABLE
><P  ></P
></DIV
>
    </P
><P  >     For a short discussion about the differences between 
     <SPAN HREF="#"><B  CLASS="function" >print()</B
></A
> and <B  CLASS="function" >echo()</B
>, see this FAQTs
     Knowledge Base Article: <SPAN HREF="#">http://www.faqts.com/knowledge_base/view.phtml/aid/1/fid/40
     </A
>
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>由于这是一个语言结构而非函数，因此它无法被“<SPAN HREF="#">变量函数</A
>”调用。</P
></BLOCKQUOTE
></DIV
><P  >     See also
     <SPAN HREF="#"><B  CLASS="function" >print()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >flush()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>explode</name>
            <signature><![CDATA[array explode ( string separator, string string [, int limit])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN107993" ></A
><H2  >Description</H2
>array <B  CLASS="methodname" >explode</B
> ( string separator, string string [, int limit])<BR  ></BR
><P  >     Returns an array of strings, each of which is a substring of
     <TT  CLASS="parameter" ><I  >string</I
></TT
> formed by splitting it on
     boundaries formed by the string <TT  CLASS="parameter" ><I  >separator</I
></TT
>.
     If <TT  CLASS="parameter" ><I  >limit</I
></TT
> is set, the returned array will
     contain a maximum of <TT  CLASS="parameter" ><I  >limit</I
></TT
> elements with
     the last element containing the rest of
     <TT  CLASS="parameter" ><I  >string</I
></TT
>.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >separator</I
></TT
> is an empty string (""),
     <B  CLASS="function" >explode()</B
> will return <TT  CLASS="constant" ><B  >FALSE</B
></TT
>.  If
     <TT  CLASS="parameter" ><I  >separator</I
></TT
> contains a value that is not contained
     in <TT  CLASS="parameter" ><I  >string</I
></TT
>, then <B  CLASS="function" >explode()</B
> will
     return an array containing <TT  CLASS="parameter" ><I  >string</I
></TT
>.
    </P
><P  >     Although <SPAN HREF="#"><B  CLASS="function" >implode()</B
></A
> can, for historical reasons,
     accept its parameters in either order,
     <B  CLASS="function" >explode()</B
> cannot. You must ensure that the
     <TT  CLASS="parameter" ><I  >separator</I
></TT
> argument comes before the
     <TT  CLASS="parameter" ><I  >string</I
></TT
> argument.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The <TT  CLASS="parameter" ><I  >limit</I
></TT
> parameter was added in PHP
      4.0.1 
     </P
></BLOCKQUOTE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108030" ></A
><P  ><B  >例子 1. <B  CLASS="function" >explode()</B
> examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#FF8000">// Example 1<br  /></font><font  color="#0000BB">$pizza  </font><font  color="#007700">= </font><font  color="#DD0000">"piece1 piece2 piece3 piece4 piece5 piece6"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$pieces </font><font  color="#007700">= </font><font  color="#0000BB">explode</font><font  color="#007700">(</font><font  color="#DD0000">" "</font><font  color="#007700">, </font><font  color="#0000BB">$pizza</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$pieces</font><font  color="#007700">[</font><font  color="#0000BB">0</font><font  color="#007700">]; </font><font  color="#FF8000">// piece1<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$pieces</font><font  color="#007700">[</font><font  color="#0000BB">1</font><font  color="#007700">]; </font><font  color="#FF8000">// piece2<br  /><br  />// Example 2<br  /></font><font  color="#0000BB">$data </font><font  color="#007700">= </font><font  color="#DD0000">"foo:*:1023:1000::/home/foo:/bin/sh"</font><font  color="#007700">;<br  />list(</font><font  color="#0000BB">$user</font><font  color="#007700">, </font><font  color="#0000BB">$pass</font><font  color="#007700">, </font><font  color="#0000BB">$uid</font><font  color="#007700">, </font><font  color="#0000BB">$gid</font><font  color="#007700">, </font><font  color="#0000BB">$gecos</font><font  color="#007700">, </font><font  color="#0000BB">$home</font><font  color="#007700">, </font><font  color="#0000BB">$shell</font><font  color="#007700">) = </font><font  color="#0000BB">explode</font><font  color="#007700">(</font><font  color="#DD0000">":"</font><font  color="#007700">, </font><font  color="#0000BB">$data</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$user</font><font  color="#007700">; </font><font  color="#FF8000">// foo<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$pass</font><font  color="#007700">; </font><font  color="#FF8000">// *<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also 
     <SPAN HREF="#"><B  CLASS="function" >preg_split()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >spliti()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >split()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >implode()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>fprintf</name>
            <signature><![CDATA[]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108118" ></A
><H2  >Examples</H2
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108121" ></A
><P  ><B  >例子 1. <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>: zero-padded integers</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$isodate </font><font  color="#007700">= </font><font  color="#0000BB">sprintf</font><font  color="#007700">(</font><font  color="#DD0000">"%04d-%02d-%02d"</font><font  color="#007700">, </font><font  color="#0000BB">$year</font><font  color="#007700">, </font><font  color="#0000BB">$month</font><font  color="#007700">, </font><font  color="#0000BB">$day</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108125" ></A
><P  ><B  >例子 2. <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>: formatting currency</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$money1 </font><font  color="#007700">= </font><font  color="#0000BB">68.75</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$money2 </font><font  color="#007700">= </font><font  color="#0000BB">54.35</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$money </font><font  color="#007700">= </font><font  color="#0000BB">$money1 </font><font  color="#007700">+ </font><font  color="#0000BB">$money2</font><font  color="#007700">;<br  /></font><font  color="#FF8000">// echo $money will output "123.1";<br  /></font><font  color="#0000BB">$formatted </font><font  color="#007700">= </font><font  color="#0000BB">sprintf</font><font  color="#007700">(</font><font  color="#DD0000">"%01.2f"</font><font  color="#007700">, </font><font  color="#0000BB">$money</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// echo $formatted will output "123.10"<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>get_html_translation_table</name>
            <signature><![CDATA[array get_html_translation_table ( int table [, int quote_style])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108135" ></A
><H2  >Description</H2
>array <B  CLASS="methodname" >get_html_translation_table</B
> ( int table [, int quote_style])<BR  ></BR
><P  >     <B  CLASS="function" >get_html_translation_table()</B
> will return the
     translation table that is used internally for
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
> and
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
>. 
    </P
><P  >     There are two new constants
     (<TT  CLASS="constant" ><B  >HTML_ENTITIES</B
></TT
>,
     <TT  CLASS="constant" ><B  >HTML_SPECIALCHARS</B
></TT
>) that allow you to
     specify the table you want. And as in the
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
> and
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
> functions you can optionally
     specify the <TT  CLASS="parameter" ><I  >quote_style</I
></TT
> you are working with.  The default is
     <TT  CLASS="constant" ><B  >ENT_COMPAT</B
></TT
> mode.  See the description of these modes in
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108159" ></A
><P  ><B  >例子 1. Translation Table Example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$trans </font><font  color="#007700">= </font><font  color="#0000BB">get_html_translation_table</font><font  color="#007700">(</font><font  color="#0000BB">HTML_ENTITIES</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$str </font><font  color="#007700">= </font><font  color="#DD0000">"Hallo & <Frau> & Kr漤er"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$encoded </font><font  color="#007700">= </font><font  color="#0000BB">strtr</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">, </font><font  color="#0000BB">$trans</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
     The <TT  CLASS="literal" >$encoded</TT
> variable will now contain: 
     <TT  CLASS="literal" >"Hallo &amp; &lt;Frau&gt; &amp;
     Kr&auml;mer".</TT
>
    </P
><P  >     Another interesting use of this function is to, with help of <SPAN HREF="#"><B  CLASS="function" >array_flip()</B
></A
>,
     change the direction of the translation.
     </P><DIV  CLASS="informalexample" ><A  NAME="AEN108166" ></A
><P  ></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$trans </font><font  color="#007700">= </font><font  color="#0000BB">array_flip</font><font  color="#007700">(</font><font  color="#0000BB">$trans</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$original </font><font  color="#007700">= </font><font  color="#0000BB">strtr</font><font  color="#007700">(</font><font  color="#0000BB">$encoded</font><font  color="#007700">, </font><font  color="#0000BB">$trans</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  ></P
></DIV
>
      The content of <TT  CLASS="literal" >$original</TT
> would be: "Hallo &
      <Frau> & Krämer".
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strtr()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >array_flip()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>hebrev</name>
            <signature><![CDATA[string hebrev ( string hebrew_text [, int max_chars_per_line])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108178" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >hebrev</B
> ( string hebrew_text [, int max_chars_per_line])<BR  ></BR
><P  >     The optional parameter <TT  CLASS="parameter" ><I  >max_chars_per_line</I
></TT
>
     indicates maximum number of characters per line will be
     output. The function tries to avoid breaking words.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >hebrevc()</B
></A
>
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>hebrevc</name>
            <signature><![CDATA[string hebrevc ( string hebrew_text [, int max_chars_per_line])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108197" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >hebrevc</B
> ( string hebrew_text [, int max_chars_per_line])<BR  ></BR
><P  >     This function is similar to <SPAN HREF="#"><B  CLASS="function" >hebrev()</B
></A
> with the
     difference that it converts newlines (\n) to "<br>\n".  The
     optional parameter <TT  CLASS="parameter" ><I  >max_chars_per_line</I
></TT
>
     indicates maximum number of characters per line will be
     output. The function tries to avoid breaking words.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >hebrev()</B
></A
>
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>html_entity_decode</name>
            <signature><![CDATA[string html_entity_decode ( string string [, int quote_style [, string charset]])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108217" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >html_entity_decode</B
> ( string string [, int quote_style [, string charset]])<BR  ></BR
><P  >     <B  CLASS="function" >html_entity_decode()</B
> is the opposite of
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
> in that it converts all HTML entities
     to their applicable characters from <TT  CLASS="parameter" ><I  >string</I
></TT
>.
    </P
><P  >     The optional second <TT  CLASS="parameter" ><I  >quote_style</I
></TT
> parameter lets 
     you define what will be done with 'single' and "double" quotes.  It takes 
     on one of three constants with the default being 
     <TT  CLASS="constant" ><B  >ENT_COMPAT</B
></TT
>:
     </P><DIV  CLASS="table" ><A  NAME="AEN108238" ></A
><P  ><B  >表格 1. Available <TT  CLASS="parameter" ><I  >quote_style</I
></TT
> constants</B
></P
><TABLE  BORDER="1" CLASS="CALSTABLE" ><THEAD  ><TR  ><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Constant Name</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Description</TH
></TR
></THEAD
><TBODY  ><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" ><TT  CLASS="constant" ><B  >ENT_COMPAT</B
></TT
></TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Will convert double-quotes and leave single-quotes alone.</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" ><TT  CLASS="constant" ><B  >ENT_QUOTES</B
></TT
></TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Will convert both double and single quotes.</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" ><TT  CLASS="constant" ><B  >ENT_NOQUOTES</B
></TT
></TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Will leave both double and single quotes unconverted.</TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
><P  >     The ISO-8859-1 character set is used as default for the optional third
     <TT  CLASS="parameter" ><I  >charset</I
></TT
>. This defines the character set used in
     conversion.
    </P
><P  > Following character sets are supported in PHP 4.3.0 and later.
 </P><DIV  CLASS="table" ><A  NAME="AEN108262" ></A
><P  ><B  >表格 2. Supported charsets</B
></P
><TABLE  BORDER="1" CLASS="CALSTABLE" ><THEAD  ><TR  ><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Charset</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Aliases</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Description</TH
></TR
></THEAD
><TBODY  ><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO-8859-1</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO8859-1</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Western European, Latin-1
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO-8859-15</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO8859-15</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Western European, Latin-9. Adds the Euro sign, French and Finnish
      letters missing in Latin-1(ISO-8859-1).
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >UTF-8</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" > </TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      ASCII compatible multi-byte 8-bit Unicode.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp866</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ibm866, 866</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      DOS-specific Cyrillic charset.
      This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp1251</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Windows-1251, win-1251, 1251</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Windows-specific Cyrillic charset.
      This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp1252</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Windows-1252, 1252</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Windows specific charset for Western European.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >KOI8-R</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >koi8-ru, koi8r</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Russian. This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >BIG5</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >950</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Traditional Chinese, mainly used in Taiwan.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >GB2312</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >936</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Simplified Chinese, national standard character set.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >BIG5-HKSCS</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" > </TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Big5 with Hong Kong extensions, Traditional Chinese.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Shift_JIS</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >SJIS, 932</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Japanese
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >EUC-JP</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >EUCJP</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Japanese
     </TD
></TR
></TBODY
></TABLE
></DIV
>
 <DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
   Any other character sets are not recognized and ISO-8859-1 will be used
   instead.
  </P
></BLOCKQUOTE
></DIV
>
</P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108322" ></A
><P  ><B  >例子 1. Decoding HTML entities</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$orig </font><font  color="#007700">= </font><font  color="#DD0000">"I'll \"walk\" the <b>dog</b> now"</font><font  color="#007700">;<br  /><br  /></font><font  color="#0000BB">$a </font><font  color="#007700">= </font><font  color="#0000BB">htmlentities</font><font  color="#007700">(</font><font  color="#0000BB">$orig</font><font  color="#007700">);<br  /><br  /></font><font  color="#0000BB">$b </font><font  color="#007700">= </font><font  color="#0000BB">html_entity_decode</font><font  color="#007700">(</font><font  color="#0000BB">$a</font><font  color="#007700">);<br  /><br  />echo </font><font  color="#0000BB">$a</font><font  color="#007700">; </font><font  color="#FF8000">// I'll &quot;walk&quot; the &lt;b&gt;dog&lt;/b&gt; now<br  /><br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$b</font><font  color="#007700">; </font><font  color="#FF8000">// I'll "walk" the <b>dog</b> now<br  /><br  /><br  />// For users prior to PHP 4.3.0 you may do this:<br  /></font><font  color="#007700">function </font><font  color="#0000BB">unhtmlentities</font><font  color="#007700">(</font><font  color="#0000BB">$string</font><font  color="#007700">) <br  />{<br  />    </font><font  color="#0000BB">$trans_tbl </font><font  color="#007700">= </font><font  color="#0000BB">get_html_translation_table</font><font  color="#007700">(</font><font  color="#0000BB">HTML_ENTITIES</font><font  color="#007700">);<br  />    </font><font  color="#0000BB">$trans_tbl </font><font  color="#007700">= </font><font  color="#0000BB">array_flip</font><font  color="#007700">(</font><font  color="#0000BB">$trans_tbl</font><font  color="#007700">);<br  />    return </font><font  color="#0000BB">strtr</font><font  color="#007700">(</font><font  color="#0000BB">$string</font><font  color="#007700">, </font><font  color="#0000BB">$trans_tbl</font><font  color="#007700">);<br  />}<br  /><br  /></font><font  color="#0000BB">$c </font><font  color="#007700">= </font><font  color="#0000BB">unhtmlentities</font><font  color="#007700">(</font><font  color="#0000BB">$a</font><font  color="#007700">);<br  /><br  />echo </font><font  color="#0000BB">$c</font><font  color="#007700">; </font><font  color="#FF8000">// I'll "walk" the <b>dog</b> now<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     </P><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
       You might wonder why trim(html_entity_decode('&nbsp;')); doesn't
       reduce the string to an empty string, that's because the '&nbsp;'
       entity is not ASCII code 32 (which is stripped by
       <SPAN HREF="#"><B  CLASS="function" >trim()</B
></A
>) but ASCII code 160 (0xa0) in the default ISO
       8859-1 characterset.
      </P
></BLOCKQUOTE
></DIV
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >get_html_translation_table()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >urldecode()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>htmlentities</name>
            <signature><![CDATA[string htmlentities ( string string [, int quote_style [, string charset]])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108339" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >htmlentities</B
> ( string string [, int quote_style [, string charset]])<BR  ></BR
><P  >     This function is identical to
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
> in all ways, except with
     <B  CLASS="function" >htmlentities()</B
>, all characters which have HTML 
     character entity equivalents are translated into these entities.
    </P
><P  >     Like <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>, the optional second 
     <TT  CLASS="parameter" ><I  >quote_style</I
></TT
> parameter lets you define what will 
     be done with 'single' and "double" quotes.  It takes on one of three 
     constants with the default being <TT  CLASS="constant" ><B  >ENT_COMPAT</B
></TT
>:
     </P><DIV  CLASS="table" ><A  NAME="AEN108360" ></A
><P  ><B  >表格 1. Available <TT  CLASS="parameter" ><I  >quote_style</I
></TT
> constants</B
></P
><TABLE  BORDER="1" CLASS="CALSTABLE" ><THEAD  ><TR  ><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Constant Name</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Description</TH
></TR
></THEAD
><TBODY  ><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" ><TT  CLASS="constant" ><B  >ENT_COMPAT</B
></TT
></TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Will convert double-quotes and leave single-quotes alone.</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" ><TT  CLASS="constant" ><B  >ENT_QUOTES</B
></TT
></TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Will convert both double and single quotes.</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" ><TT  CLASS="constant" ><B  >ENT_NOQUOTES</B
></TT
></TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Will leave both double and single quotes unconverted.</TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
><P  >     Support for the optional <TT  CLASS="parameter" ><I  >quote</I
></TT
> parameter was
     added in PHP 4.0.3.
    </P
><P  >     Like <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>, it takes an optional
     third argument <TT  CLASS="parameter" ><I  >charset</I
></TT
> which defines character
     set used in conversion. Support for this argument was added in PHP 4.1.0.
     Presently, the ISO-8859-1 character set is used as the default.
    </P
><P  > Following character sets are supported in PHP 4.3.0 and later.
 </P><DIV  CLASS="table" ><A  NAME="AEN108387" ></A
><P  ><B  >表格 2. Supported charsets</B
></P
><TABLE  BORDER="1" CLASS="CALSTABLE" ><THEAD  ><TR  ><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Charset</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Aliases</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Description</TH
></TR
></THEAD
><TBODY  ><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO-8859-1</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO8859-1</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Western European, Latin-1
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO-8859-15</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO8859-15</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Western European, Latin-9. Adds the Euro sign, French and Finnish
      letters missing in Latin-1(ISO-8859-1).
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >UTF-8</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" > </TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      ASCII compatible multi-byte 8-bit Unicode.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp866</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ibm866, 866</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      DOS-specific Cyrillic charset.
      This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp1251</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Windows-1251, win-1251, 1251</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Windows-specific Cyrillic charset.
      This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp1252</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Windows-1252, 1252</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Windows specific charset for Western European.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >KOI8-R</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >koi8-ru, koi8r</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Russian. This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >BIG5</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >950</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Traditional Chinese, mainly used in Taiwan.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >GB2312</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >936</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Simplified Chinese, national standard character set.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >BIG5-HKSCS</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" > </TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Big5 with Hong Kong extensions, Traditional Chinese.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Shift_JIS</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >SJIS, 932</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Japanese
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >EUC-JP</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >EUCJP</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Japanese
     </TD
></TR
></TBODY
></TABLE
></DIV
>
 <DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
   Any other character sets are not recognized and ISO-8859-1 will be used
   instead.
  </P
></BLOCKQUOTE
></DIV
>
</P
><P  >     If you're wanting to decode instead (the reverse) you can use
     <SPAN HREF="#"><B  CLASS="function" >html_entity_decode()</B
></A
>.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108449" ></A
><P  ><B  >例子 1. A <B  CLASS="function" >htmlentities()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"A 'quote' is <b>bold</b>"</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// Outputs: A 'quote' is &lt;b&gt;bold&lt;/b&gt;<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">htmlentities</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">// Outputs: A &#039;quote&#039; is &lt;b&gt;bold&lt;/b&gt;<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">htmlentities</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">, </font><font  color="#0000BB">ENT_QUOTES</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >html_entity_decode()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >get_html_translation_table()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >nl2br()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >urlencode()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>htmlspecialchars</name>
            <signature><![CDATA[string htmlspecialchars ( string string [, int quote_style [, string charset]])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108463" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >htmlspecialchars</B
> ( string string [, int quote_style [, string charset]])<BR  ></BR
><P  >     Certain characters have special significance in HTML, and should
     be represented by HTML entities if they are to preserve their
     meanings. This function returns a string with some of these
     conversions made; the translations made are those most
     useful for everyday web programming. If you require all HTML
     character entities to be translated, use
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
> instead.
    </P
><P  >     This function is useful in preventing user-supplied text from
     containing HTML markup, such as in a message board or guest book
     application.  The optional second argument, <TT  CLASS="parameter" ><I  >quote_style</I
></TT
>, tells
     the function what to do with single and double quote characters.
     The default mode, <TT  CLASS="constant" ><B  >ENT_COMPAT</B
></TT
>, is the backwards compatible mode
     which only translates the double-quote character and leaves the
     single-quote untranslated.  If <TT  CLASS="constant" ><B  >ENT_QUOTES</B
></TT
> is set, both single and
     double quotes are translated and if <TT  CLASS="constant" ><B  >ENT_NOQUOTES</B
></TT
> is set neither
     single nor double quotes are translated.
    </P
><P  >     The translations performed are:
     </P><P  ></P
><UL  ><LI  ><P  >        '&' (ampersand) becomes '&amp;'
       </P
></LI
><LI  ><P  >        '"' (double quote) becomes '&quot;' when <TT  CLASS="constant" ><B  >ENT_NOQUOTES</B
></TT
>
        is not set.
       </P
></LI
><LI  ><P  >        ''' (single quote) becomes '&#039;' only when
        <TT  CLASS="constant" ><B  >ENT_QUOTES</B
></TT
> is set.
       </P
></LI
><LI  ><P  >        '<' (less than) becomes '&lt;'
       </P
></LI
><LI  ><P  >        '>' (greater than) becomes '&gt;'
       </P
></LI
></UL
>
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108498" ></A
><P  ><B  >例子 1. <B  CLASS="function" >htmlspecialchars()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$new </font><font  color="#007700">= </font><font  color="#0000BB">htmlspecialchars</font><font  color="#007700">(</font><font  color="#DD0000">"<a href='test'>Test</a>"</font><font  color="#007700">, </font><font  color="#0000BB">ENT_QUOTES</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$new</font><font  color="#007700">; </font><font  color="#FF8000">// &lt;a href=&#039;test&#039;&gt;Test&lt;/a&gt;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     Note that this function does not translate anything beyond what
     is listed above. For full entity translation, see
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
>.  Support for the optional
     second argument was added in PHP 3.0.17 and PHP 4.0.3.
    </P
><P  >     The third argument <TT  CLASS="parameter" ><I  >charset</I
></TT
> defines character set
     used in conversion. The default character set is ISO-8859-1. Support for
     this third argument was added in PHP 4.1.0.
    </P
><P  > Following character sets are supported in PHP 4.3.0 and later.
 </P><DIV  CLASS="table" ><A  NAME="AEN108507" ></A
><P  ><B  >表格 1. Supported charsets</B
></P
><TABLE  BORDER="1" CLASS="CALSTABLE" ><THEAD  ><TR  ><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Charset</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Aliases</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Description</TH
></TR
></THEAD
><TBODY  ><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO-8859-1</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO8859-1</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Western European, Latin-1
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO-8859-15</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ISO8859-15</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Western European, Latin-9. Adds the Euro sign, French and Finnish
      letters missing in Latin-1(ISO-8859-1).
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >UTF-8</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" > </TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      ASCII compatible multi-byte 8-bit Unicode.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp866</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >ibm866, 866</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      DOS-specific Cyrillic charset.
      This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp1251</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Windows-1251, win-1251, 1251</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Windows-specific Cyrillic charset.
      This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >cp1252</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Windows-1252, 1252</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Windows specific charset for Western European.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >KOI8-R</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >koi8-ru, koi8r</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Russian. This charset is supported in 4.3.2.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >BIG5</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >950</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Traditional Chinese, mainly used in Taiwan.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >GB2312</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >936</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Simplified Chinese, national standard character set.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >BIG5-HKSCS</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" > </TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Big5 with Hong Kong extensions, Traditional Chinese.
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Shift_JIS</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >SJIS, 932</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Japanese
     </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >EUC-JP</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >EUCJP</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >      Japanese
     </TD
></TR
></TBODY
></TABLE
></DIV
>
 <DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
   Any other character sets are not recognized and ISO-8859-1 will be used
   instead.
  </P
></BLOCKQUOTE
></DIV
>
</P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >get_html_translation_table()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strip_tags()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
>, and <SPAN HREF="#"><B  CLASS="function" >nl2br()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>implode</name>
            <signature><![CDATA[string implode ( string glue, array pieces)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108575" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >implode</B
> ( string glue, array pieces)<BR  ></BR
><P  >     Returns a string containing a string representation of all the
     array elements in the same order, with the glue string between
     each element.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108587" ></A
><P  ><B  >例子 1. <B  CLASS="function" >implode()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$array </font><font  color="#007700">= array(</font><font  color="#DD0000">'lastname'</font><font  color="#007700">, </font><font  color="#DD0000">'email'</font><font  color="#007700">, </font><font  color="#DD0000">'phone'</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$comma_separated </font><font  color="#007700">= </font><font  color="#0000BB">implode</font><font  color="#007700">(</font><font  color="#DD0000">","</font><font  color="#007700">, </font><font  color="#0000BB">$array</font><font  color="#007700">);<br  /><br  />echo </font><font  color="#0000BB">$comma_separated</font><font  color="#007700">; </font><font  color="#FF8000">// lastname,email,phone<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      <B  CLASS="function" >implode()</B
> can, for historical reasons, accept
      its parameters in either order. For consistency with
      <SPAN HREF="#"><B  CLASS="function" >explode()</B
></A
>, however, it may be less confusing
      to use the documented order of arguments.
     </P
></BLOCKQUOTE
></DIV
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      As of PHP 4.3.0, the glue parameter of <B  CLASS="function" >implode()</B
> is
      optional and defaults to the empty string(''). This is not the preferred
      usage of <B  CLASS="function" >implode()</B
>. We recommend to always use two
      parameters for compatibility with older versions.
     </P
></BLOCKQUOTE
></DIV
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >explode()</B
></A
>, and <SPAN HREF="#"><B  CLASS="function" >split()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>join</name>
            <signature><![CDATA[]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108607" ></A
><H2  >Description</H2
><P  >     This function is an alias of <SPAN HREF="#"><B  CLASS="function" >implode()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>levenshtein</name>
            <signature><![CDATA[int levenshtein ( string str1, string str2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108615" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >levenshtein</B
> ( string str1, string str2)<BR  ></BR
>int <B  CLASS="methodname" >levenshtein</B
> ( string str1, string str2, int cost_ins, int cost_rep, int cost_del)<BR  ></BR
>int <B  CLASS="methodname" >levenshtein</B
> ( string str1, string str2, function cost)<BR  ></BR
><P  >     This function returns the Levenshtein-Distance between the
     two argument strings or -1, if one of the argument strings
     is longer than the limit of 255 characters (255 should be
     more than enough for name or dictionary comparison, and 
     nobody serious would be doing genetic analysis with PHP).
    </P
><P  >     The Levenshtein distance is defined as the minimal number of
     characters you have to replace, insert or delete to transform
     <TT  CLASS="parameter" ><I  >str1</I
></TT
> into <TT  CLASS="parameter" ><I  >str2</I
></TT
>.
     The complexity of the algorithm is <TT  CLASS="literal" >O(m*n)</TT
>,
     where <TT  CLASS="literal" >n</TT
> and <TT  CLASS="literal" >m</TT
> are the
     length of <TT  CLASS="parameter" ><I  >str1</I
></TT
> and
     <TT  CLASS="parameter" ><I  >str2</I
></TT
> (rather good when compared to
     <SPAN HREF="#"><B  CLASS="function" >similar_text()</B
></A
>, which is O(max(n,m)**3),
     but still expensive).
    </P
><P  >     In its simplest form the function will take only the two
     strings as parameter and will calculate just the number of
     insert, replace and delete operations needed to transform
     <TT  CLASS="parameter" ><I  >str1</I
></TT
> into <TT  CLASS="parameter" ><I  >str2</I
></TT
>.
    </P
><P  > 
     A second variant will take three additional parameters that
     define the cost of insert, replace and delete operations.  This
     is more general and adaptive than variant one, but not as
     efficient.
    </P
><P  > 
     The third variant (which is not implemented yet) will be the most
     general and adaptive, but also the slowest alternative.  It will
     call a user-supplied function that will determine the cost for
     every possible operation.
    </P
><P  >     The user-supplied function will be called with the following
     arguments:
     </P><P  ></P
><UL  ><LI  ><P  >        operation to apply: 'I', 'R' or 'D'
       </P
></LI
><LI  ><P  >        actual character in string 1
       </P
></LI
><LI  ><P  >        actual character in string 2
       </P
></LI
><LI  ><P  >        position in string 1
       </P
></LI
><LI  ><P  >        position in string 2
       </P
></LI
><LI  ><P  >        remaining characters in string 1
       </P
></LI
><LI  ><P  >        remaining characters in string 2
       </P
></LI
></UL
>
     The user-supplied function has to return a positive integer
     describing the cost for this particular operation, but it may
     decide to use only some of the supplied arguments.
    </P
><P  > 
     The user-supplied function approach offers the possibility to
     take into account the relevance of and/or difference between
     certain symbols (characters) or even the context those symbols
     appear in to determine the cost of insert, replace and delete
     operations, but at the cost of losing all optimizations done
     regarding cpu register utilization and cache misses that have
     been worked into the other two variants.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >soundex()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >similar_text()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >metaphone()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>localeconv</name>
            <signature><![CDATA[array localeconv ( void )]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108696" ></A
><H2  >Description</H2
>array <B  CLASS="methodname" >localeconv</B
> ( void )<BR  ></BR
><P  >     Returns an associative array containing localized numeric and
     monetary formatting information.
    </P
><P  >     <B  CLASS="function" >localeconv()</B
> returns data based upon the current locale
     as set by <SPAN HREF="#"><B  CLASS="function" >setlocale()</B
></A
>.  The associative array that is
     returned contains the following fields:
     </P><DIV  CLASS="informaltable" ><A  NAME="AEN108706" ></A
><P  ></P
><TABLE  BORDER="1" CLASS="CALSTABLE" ><THEAD  ><TR  ><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Array element</TH
><TH  ALIGN="LEFT" VALIGN="MIDDLE" >Description</TH
></TR
></THEAD
><TBODY  ><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >decimal_point</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Decimal point character</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >thousands_sep</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Thousands separator</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >grouping</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Array containing numeric groupings</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >int_curr_symbol</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >International currency symbol (i.e. USD)</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >currency_symbol</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Local currency symbol (i.e. $)</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >mon_decimal_point</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Monetary decimal point character</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >mon_thousands_sep</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Monetary thousands separator</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >mon_grouping</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Array containing monetary groupings</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >positive_sign</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Sign for positive values</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >negative_sign</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Sign for negative values</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >int_frac_digits</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >International fractional digits</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >frac_digits</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >Local fractional digits</TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >p_cs_precedes</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >          <TT  CLASS="constant" ><B  >TRUE</B
></TT
> if currency_symbol precedes a positive value, <TT  CLASS="constant" ><B  >FALSE</B
></TT
>
          if it succeeds one
         </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >p_sep_by_space</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >          <TT  CLASS="constant" ><B  >TRUE</B
></TT
> if a space separates currency_symbol from a positive
          value, <TT  CLASS="constant" ><B  >FALSE</B
></TT
> otherwise
         </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >n_cs_precedes</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >          <TT  CLASS="constant" ><B  >TRUE</B
></TT
> if currency_symbol precedes a negative value, <TT  CLASS="constant" ><B  >FALSE</B
></TT
>
          if it succeeds one
         </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="MIDDLE" >n_sep_by_space</TD
><TD  ALIGN="LEFT" VALIGN="MIDDLE" >          <TT  CLASS="constant" ><B  >TRUE</B
></TT
> if a space separates currency_symbol from a negative
          value, <TT  CLASS="constant" ><B  >FALSE</B
></TT
> otherwise
         </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="TOP" >p_sign_posn</TD
><TD  ALIGN="LEFT" VALIGN="TOP" >          <P  ></P
><TABLE  BORDER="0" ><TBODY  ><TR  ><TD  >0</TD
><TD  >            Parentheses surround the quantity and currency_symbol</TD
></TR
><TR  ><TD  >1</TD
><TD  >            The sign string precedes the quantity and currency_symbol
           </TD
></TR
><TR  ><TD  >2</TD
><TD  >            The sign string succeeds the quantity and currency_symbol
           </TD
></TR
><TR  ><TD  >3</TD
><TD  >            The sign string immediately precedes the currency_symbol
           </TD
></TR
><TR  ><TD  >4</TD
><TD  >            The sign string immediately succeeds the currency_symbol
           </TD
></TR
></TBODY
></TABLE
><P  ></P
>
         </TD
></TR
><TR  ><TD  ALIGN="LEFT" VALIGN="TOP" >n_sign_posn</TD
><TD  ALIGN="LEFT" VALIGN="TOP" >          <P  ></P
><TABLE  BORDER="0" ><TBODY  ><TR  ><TD  >0</TD
><TD  >            Parentheses surround the quantity and currency_symbol
           </TD
></TR
><TR  ><TD  >1</TD
><TD  >            The sign string precedes the quantity and currency_symbol
           </TD
></TR
><TR  ><TD  >2</TD
><TD  >            The sign string succeeds the quantity and currency_symbol
           </TD
></TR
><TR  ><TD  >3</TD
><TD  >            The sign string immediately precedes the currency_symbol
           </TD
></TR
><TR  ><TD  >4</TD
><TD  >            The sign string immediately succeeds the currency_symbol
           </TD
></TR
></TBODY
></TABLE
><P  ></P
>
         </TD
></TR
></TBODY
></TABLE
><P  ></P
></DIV
>
    </P
><P  >     The grouping fields contain arrays that define the way numbers
     should be grouped.  For example, the grouping field for the en_US
     locale, would contain a 2 item array with the values 3 and 3.
     The higher the index in the array, the farther left the grouping
     is.  If an array element is equal to CHAR_MAX, no further
     grouping is done.  If an array element is equal to 0, the
     previous element should be used.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108798" ></A
><P  ><B  >例子 1. <B  CLASS="function" >localeconv()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_ALL</font><font  color="#007700">, </font><font  color="#DD0000">"en_US"</font><font  color="#007700">);<br  /><br  /></font><font  color="#0000BB">$locale_info </font><font  color="#007700">= </font><font  color="#0000BB">localeconv</font><font  color="#007700">();<br  /><br  />echo </font><font  color="#DD0000">"<pre>\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"--------------------------------------------\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"  Monetary information for current locale:  \n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"--------------------------------------------\n\n"</font><font  color="#007700">;<br  /><br  />echo </font><font  color="#DD0000">"int_curr_symbol:   {$locale_info["int_curr_symbol"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"currency_symbol:   {$locale_info["currency_symbol"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"mon_decimal_point: {$locale_info["mon_decimal_point"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"mon_thousands_sep: {$locale_info["mon_thousands_sep"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"positive_sign:     {$locale_info["positive_sign"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"negative_sign:     {$locale_info["negative_sign"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"int_frac_digits:   {$locale_info["int_frac_digits"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"frac_digits:       {$locale_info["frac_digits"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"p_cs_precedes:     {$locale_info["p_cs_precedes"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"p_sep_by_space:    {$locale_info["p_sep_by_space"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"n_cs_precedes:     {$locale_info["n_cs_precedes"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"n_sep_by_space:    {$locale_info["n_sep_by_space"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"p_sign_posn:       {$locale_info["p_sign_posn"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"n_sign_posn:       {$locale_info["n_sign_posn"]}\n"</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"</pre>\n"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     The constant CHAR_MAX is also defined for the use mentioned above.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >setlocale()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>ltrim</name>
            <signature><![CDATA[string ltrim ( string str [, string charlist])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108809" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >ltrim</B
> ( string str [, string charlist])<BR  ></BR
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The second parameter was added in PHP 4.1.0
     </P
></BLOCKQUOTE
></DIV
><P  >     This function returns a string with whitespace stripped from the
     beginning of <TT  CLASS="parameter" ><I  >str</I
></TT
>.
     Without the second parameter,
     <B  CLASS="function" >ltrim()</B
> will strip these characters:
     
     </P><P  ></P
><UL  ><LI  ><P  >        " " (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >32</TT
> 
        (<TT  CLASS="literal" >0x20</TT
>)), an ordinary space.
       </P
></LI
><LI  ><P  >        "\t" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >9</TT
> 
        (<TT  CLASS="literal" >0x09</TT
>)), a tab.
       </P
></LI
><LI  ><P  >        "\n" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >10</TT
> 
        (<TT  CLASS="literal" >0x0A</TT
>)), a new line (line feed).
       </P
></LI
><LI  ><P  >        "\r" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >13</TT
> 
        (<TT  CLASS="literal" >0x0D</TT
>)), a carriage return.
       </P
></LI
><LI  ><P  >        "\0" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >0</TT
> 
        (<TT  CLASS="literal" >0x00</TT
>)), the <TT  CLASS="literal" >NUL</TT
>-byte.
       </P
></LI
><LI  ><P  > 
        "\x0B" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >11</TT
> 
        (<TT  CLASS="literal" >0x0B</TT
>)), a vertical tab.
       </P
></LI
></UL
>
    </P
><P  >     You can also specify the characters you want to strip, by means
     of the <TT  CLASS="parameter" ><I  >charlist</I
></TT
> parameter.
     Simply list all characters that you want to be stripped. With
     <TT  CLASS="literal" >..</TT
> you can specify a range of characters.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108860" ></A
><P  ><B  >例子 1. Usage example of <B  CLASS="function" >ltrim()</B
></B
></P
><P  >      <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$text </font><font  color="#007700">= </font><font  color="#DD0000">"\t\tThese are a few words :) ...  "</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$trimmed </font><font  color="#007700">= </font><font  color="#0000BB">ltrim</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// $trimmed = "These are a few words :) ...  "<br  /></font><font  color="#0000BB">$trimmed </font><font  color="#007700">= </font><font  color="#0000BB">ltrim</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">, </font><font  color="#DD0000">" \t."</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// $trimmed = "These are a few words :) ...  "<br  /></font><font  color="#0000BB">$clean </font><font  color="#007700">= </font><font  color="#0000BB">ltrim</font><font  color="#007700">(</font><font  color="#0000BB">$binary</font><font  color="#007700">, </font><font  color="#DD0000">"\0x00..\0x1F"</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// trim the ASCII control characters at the beginning of $binary <br  />// (from 0 to 31 inclusive)<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
>
     </P
></DIV
></TD
></TR
></TABLE
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >trim()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >rtrim()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>md5_file</name>
            <signature><![CDATA[string md5_file ( string filename [, bool raw_output])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108872" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >md5_file</B
> ( string filename [, bool raw_output])<BR  ></BR
><P  >     Calculates the MD5 hash of the specified
     <TT  CLASS="parameter" ><I  >filename</I
></TT
> using the
     <SPAN HREF="#">RSA Data Security, Inc. 
     MD5 Message-Digest Algorithm</A
>, and returns that hash.
     The hash is a 32-character hexadecimal number.  If the optional
     <TT  CLASS="parameter" ><I  >raw_output</I
></TT
> is set to <TT  CLASS="constant" ><B  >TRUE</B
></TT
>, then the md5 digest
     is instead returned in raw binary format with a length of 16.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The optional <TT  CLASS="parameter" ><I  >raw_output</I
></TT
> parameter was added in
      PHP 5.0.0 and defaults to <TT  CLASS="constant" ><B  >FALSE</B
></TT
>
     </P
></BLOCKQUOTE
></DIV
><P  >     This function has the same purpose of the command line utility
     md5sum.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >md5()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >crc32()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >sha1_file()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>md5</name>
            <signature><![CDATA[string md5 ( string str [, bool raw_output])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108901" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >md5</B
> ( string str [, bool raw_output])<BR  ></BR
><P  >     Calculates the MD5 hash of <TT  CLASS="parameter" ><I  >str</I
></TT
> using the
     <SPAN HREF="#">RSA Data Security, Inc. 
     MD5 Message-Digest Algorithm</A
>, and returns that hash.
     The hash is a 32-character hexadecimal number.  If the optional
     <TT  CLASS="parameter" ><I  >raw_output</I
></TT
> is set to <TT  CLASS="constant" ><B  >TRUE</B
></TT
>, then the md5 digest
     is instead returned in raw binary format with a length of 16.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The optional <TT  CLASS="parameter" ><I  >raw_output</I
></TT
> parameter was added in
      PHP 5.0.0 and defaults to <TT  CLASS="constant" ><B  >FALSE</B
></TT
>
     </P
></BLOCKQUOTE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN108922" ></A
><P  ><B  >例子 1. A <B  CLASS="function" >md5()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">'apple'</font><font  color="#007700">;<br  /><br  />if (</font><font  color="#0000BB">md5</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">) === </font><font  color="#DD0000">'1f3870be274f6c49b3e31a0c6728957f'</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">"Would you like a green or red apple?"</font><font  color="#007700">;<br  />    exit;<br  />}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >crc32()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >md5_file()</B
></A
>, 
     and <SPAN HREF="#"><B  CLASS="function" >sha1()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>metaphone</name>
            <signature><![CDATA[string metaphone ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108934" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >metaphone</B
> ( string str)<BR  ></BR
><P  >     Calculates the metaphone key of <TT  CLASS="parameter" ><I  >str</I
></TT
>.
    </P
><P  >     Similar to <SPAN HREF="#"><B  CLASS="function" >soundex()</B
></A
> metaphone creates the
     same key for similar sounding words. It's more accurate than
     <SPAN HREF="#"><B  CLASS="function" >soundex()</B
></A
> as it knows the basic rules of
     English pronunciation.  The metaphone generated keys are of
     variable length.
    </P
><P  >     Metaphone was developed by Lawrence Philips
     <lphilips at verity dot com>. It is described in ["Practical
     Algorithms for Programmers", Binstock & Rex, Addison Wesley,
     1995].
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>money_format</name>
            <signature><![CDATA[string money_format ( string format, float number)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN108952" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >money_format</B
> ( string format, float number)<BR  ></BR
><P  >     <B  CLASS="function" >money_format()</B
> returns a formatted version of
     <TT  CLASS="parameter" ><I  >number</I
></TT
>.  This function wraps the C library
     function <B  CLASS="function" >strfmon()</B
>, with the difference that
     this implementation converts only one number at a time.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The function <B  CLASS="function" >money_format()</B
> is only defined if 
      the system has strfmon capabilities.  For example, Windows does
      not, so <B  CLASS="function" >money_format()</B
> is undefined in Windows.
     </P
></BLOCKQUOTE
></DIV
><P  >     The format specification consists of the following sequence:
     </P><P  ></P
><UL  ><LI  ><P  >a <TT  CLASS="literal" >%</TT
> character</P
></LI
><LI  ><P  >optional flags</P
></LI
><LI  ><P  >optional field width</P
></LI
><LI  ><P  >optional left precision</P
></LI
><LI  ><P  >optional right precision</P
></LI
><LI  ><P  >a required conversion character</P
></LI
></UL
>
    </P
><DIV  CLASS="formalpara" ><P  ><B  >Flags. </B
>
     One or more of the optional flags below can be used:
      </P><P  ></P
><DIV  CLASS="variablelist" ><DL  ><DT  ><TT  CLASS="literal" >=</TT
><TT  CLASS="replaceable" ><I  >f</I
></TT
></DT
><DD  ><P  >          The character <TT  CLASS="literal" >=</TT
> followed by a a (single byte)
          character <TT  CLASS="replaceable" ><I  >f</I
></TT
> to be used as the numeric fill
          character. The default fill character is space.
         </P
></DD
><DT  ><TT  CLASS="literal" >^</TT
></DT
><DD  ><P  >          Disable the use of grouping characters (as defined
          by the current locale).
         </P
></DD
><DT  ><TT  CLASS="literal" >+</TT
> or <TT  CLASS="literal" >(</TT
></DT
><DD  ><P  >          Specify the formatting style for positive and negative numbers.
          If <TT  CLASS="literal" >+</TT
> is used, the locale's equivalent for
          <TT  CLASS="literal" >+</TT
> and <TT  CLASS="literal" >-</TT
> will be used. If
          <TT  CLASS="literal" >(</TT
> is used, negative amounts are enclosed in
          parenthesis. If no specification is given, the default is
          <TT  CLASS="literal" >+</TT
>.
         </P
></DD
><DT  ><TT  CLASS="literal" >!</TT
></DT
><DD  ><P  >          Suppress the currency symbol from the output string.
         </P
></DD
><DT  ><TT  CLASS="literal" >-</TT
></DT
><DD  ><P  >          If present, it will make all fields left-justified (padded to the
          right), as opposed to the default which is for the fields to be
          right-justified (padded to the left).
         </P
></DD
></DL
></DIV
>
     </P
></DIV
><DIV  CLASS="formalpara" ><P  ><B  >Field width. </B
>
      </P><P  ></P
><DIV  CLASS="variablelist" ><DL  ><DT  ><TT  CLASS="replaceable" ><I  >w</I
></TT
></DT
><DD  ><P  >          A decimal digit string specifying a minimum field width. Field will
          be right-justified unless the flag <TT  CLASS="literal" >-</TT
> is used.
          Default value is 0 (zero).
         </P
></DD
></DL
></DIV
>
     </P
></DIV
><DIV  CLASS="formalpara" ><P  ><B  >Left precision. </B
>
      </P><P  ></P
><DIV  CLASS="variablelist" ><DL  ><DT  ><TT  CLASS="literal" >#</TT
><TT  CLASS="replaceable" ><I  >n</I
></TT
></DT
><DD  ><P  >          The maximum number of digits (<TT  CLASS="replaceable" ><I  >n</I
></TT
>) expected
          to the left of the decimal character (e.g. the decimal point). It is
          used usually to keep formatted output aligned in the same columns,
          using the fill character if the number of digits is less than
          <TT  CLASS="replaceable" ><I  >n</I
></TT
>. If the number of actual digits is
          bigger than <TT  CLASS="replaceable" ><I  >n</I
></TT
>, then this specification is
          ignored.
         </P
><P  >          If grouping has not been suppressed using the <TT  CLASS="literal" >^</TT
>
          flag, grouping separators will be inserted before the fill
          characters (if any) are added. Grouping separators will not be
          applied to fill characters, even if the fill character is a digit.
         </P
><P  >          To ensure alignment, any characters appearing before or after the
          number in the formatted output such as currency or sign symbols are
          padded as necessary with space characters to make their positive and
          negative formats an equal length.
         </P
></DD
></DL
></DIV
>
     </P
></DIV
><DIV  CLASS="formalpara" ><P  ><B  >      Right precision
     . </B
>
      </P><P  ></P
><DIV  CLASS="variablelist" ><DL  ><DT  ><TT  CLASS="literal" >.</TT
><TT  CLASS="replaceable" ><I  >p</I
></TT
></DT
><DD  ><P  >          A period followed by the number of digits
          (<TT  CLASS="replaceable" ><I  >p</I
></TT
>) after the decimal character. If the
          value of <TT  CLASS="replaceable" ><I  >p</I
></TT
> is 0 (zero), the decimal
          character and the digits to its right will be omitted. If no right
          precision is included, the default will dictated by the current
          local in use. The amount being formatted is rounded to the specified 
          number of digits prior to formatting.
         </P
></DD
></DL
></DIV
>
     </P
></DIV
><DIV  CLASS="formalpara" ><P  ><B  >      Conversion characters
     . </B
>
      </P><P  ></P
><DIV  CLASS="variablelist" ><DL  ><DT  ><TT  CLASS="literal" >i</TT
></DT
><DD  ><P  >          The number is formatted according to the locale's international
          currency format (e.g. for the USA locale: USD 1,234.56).
         </P
></DD
><DT  ><TT  CLASS="literal" >n</TT
></DT
><DD  ><P  >          The number is formatted according to the locale's national
          currency format (e.g. for the de_DE locale: DM1.234,56).
         </P
></DD
><DT  ><TT  CLASS="literal" >%</TT
></DT
><DD  ><P  >          Returns the <TT  CLASS="literal" >%</TT
> character.
         </P
></DD
></DL
></DIV
>
     </P
></DIV
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The <TT  CLASS="constant" ><B  >LC_MONETARY</B
></TT
> category of the locale settings,
      affects the behavior of this function. Use
      <SPAN HREF="#"><B  CLASS="function" >setlocale()</B
></A
> to set to the appropriate default locale
      before using this function.
     </P
><P  >      Characters before and after the formatting string will be returned
      unchanged.
     </P
></BLOCKQUOTE
></DIV
><P  >    <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109088" ></A
><P  ><B  >例子 1. <B  CLASS="function" >money_format()</B
> Example</B
></P
><P  >      We will use different locales and format specifications to
      illustrate the use of this function.
     </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$number </font><font  color="#007700">= </font><font  color="#0000BB">1234.56</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// let's print the international format for the en_US locale<br  /></font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_MONETARY</font><font  color="#007700">, </font><font  color="#DD0000">'en_US'</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">money_format</font><font  color="#007700">(</font><font  color="#DD0000">'%i'</font><font  color="#007700">, </font><font  color="#0000BB">$number</font><font  color="#007700">) . </font><font  color="#DD0000">"\n"</font><font  color="#007700">;  <br  /></font><font  color="#FF8000">// USD 1,234.56<br  /><br  />// Italian national format with 2 decimals`<br  /></font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_MONETARY</font><font  color="#007700">, </font><font  color="#DD0000">'it_IT'</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">money_format</font><font  color="#007700">(</font><font  color="#DD0000">'%.2n'</font><font  color="#007700">, </font><font  color="#0000BB">$number</font><font  color="#007700">) . </font><font  color="#DD0000">"\n"</font><font  color="#007700">;<br  /></font><font  color="#FF8000">// L. 1.234,56<br  /><br  />// Using a negative number<br  /></font><font  color="#0000BB">$number </font><font  color="#007700">= -</font><font  color="#0000BB">1234.5672</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// US national format, using () for negative numbers<br  />// and 10 digits for left precision<br  /></font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_MONETARY</font><font  color="#007700">, </font><font  color="#DD0000">'en_US'</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">money_format</font><font  color="#007700">(</font><font  color="#DD0000">'%(#10n'</font><font  color="#007700">, </font><font  color="#0000BB">$number</font><font  color="#007700">) . </font><font  color="#DD0000">"\n"</font><font  color="#007700">;<br  /></font><font  color="#FF8000">// ($        1,234.57)<br  /><br  />// Similar format as above, adding the use of 2 digits of right <br  />// precision and '*' as a fill character<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">money_format</font><font  color="#007700">(</font><font  color="#DD0000">'%=*(#10.2n'</font><font  color="#007700">, </font><font  color="#0000BB">$number</font><font  color="#007700">) . </font><font  color="#DD0000">"\n"</font><font  color="#007700">;<br  /></font><font  color="#FF8000">// ($********1,234.57)<br  />    <br  />// Let's justify to the left, with 14 positions of width, 8 digits of<br  />// left precision, 2 of right precision, withouth grouping character<br  />// and using the international format for the de_DE locale.<br  /></font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_MONETARY</font><font  color="#007700">, </font><font  color="#DD0000">'de_DE'</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">money_format</font><font  color="#007700">(</font><font  color="#DD0000">'%=*^-14#8.2i'</font><font  color="#007700">, </font><font  color="#0000BB">1234.56</font><font  color="#007700">) . </font><font  color="#DD0000">"\n"</font><font  color="#007700">;<br  /></font><font  color="#FF8000">// DEM 1234,56****<br  /><br  />// Let's add some blurb before and after the conversion specification<br  /></font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_MONETARY</font><font  color="#007700">, </font><font  color="#DD0000">'en_GB'</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$fmt </font><font  color="#007700">= </font><font  color="#DD0000">'The final value is %i (after a 10%% discount)'</font><font  color="#007700">;<br  />echo </font><font  color="#0000BB">money_format</font><font  color="#007700">(</font><font  color="#0000BB">$fmt</font><font  color="#007700">, </font><font  color="#0000BB">1234.56</font><font  color="#007700">) . </font><font  color="#DD0000">"\n"</font><font  color="#007700">;<br  /></font><font  color="#FF8000">// The final value is  GBP 1,234.56 (after a 10% discount)<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also: <SPAN HREF="#"><B  CLASS="function" >setlocale()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >number_format()</B
></A
>,<SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >sscanf()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>nl_langinfo</name>
            <signature><![CDATA[string nl_langinfo ( int item)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109103" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >nl_langinfo</B
> ( int item)<BR  ></BR
><P  >     <B  CLASS="function" >nl_langinfo()</B
> is used to access individual elements of
     the locale categories.  Unlike <SPAN HREF="#"><B  CLASS="function" >localeconv()</B
></A
>, which
     returns all of the elements, <B  CLASS="function" >nl_langinfo()</B
> allows you
     to select any specific element.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >item</I
></TT
> is not valid, <TT  CLASS="constant" ><B  >FALSE</B
></TT
> will be returned.
    </P
><P  >     <TT  CLASS="parameter" ><I  >item</I
></TT
> may be an integer value of the element or the
     constant name of the element. The following is a list of constant names
     for <TT  CLASS="parameter" ><I  >item</I
></TT
> that may be used and their description.
     Some of these constants may not be defined or hold no value for certain
     locales.
     </P><DIV  CLASS="table" ><A  NAME="AEN109121" ></A
><P  ><B  >表格 1. nl_langinfo Constants</B
></P
><TABLE  BORDER="1" CLASS="CALSTABLE" ><THEAD  ><TR  ><TH  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Constant</TH
><TH  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Description</TH
></TR
></THEAD
><TBODY  ><TR  ><TD  COLSPAN="2" ALIGN="CENTER" VALIGN="MIDDLE" ><SPAN  CLASS="emphasis" ><I  CLASS="emphasis" >LC_TIME Category Constants</I
></SPAN
></TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >ABDAY_(1-7)</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Abbreviated name of n-th day of the week.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >DAY_(1-7)</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Name of the n-th day of the week (DAY_1 = Sunday).</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >ABMON_(1-12)</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Abbreviated name of the n-th month of the year.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >MON_(1-12)</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Name of the n-th month of the year.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >AM_STR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >String for Ante meridian.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >PM_STR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >String for Post meridian.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >D_T_FMT</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >String that can be used as the format string for <SPAN HREF="#"><B  CLASS="function" >strftime()</B
></A
> to represent time and date.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >D_FMT</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >String that can be used as the format string for <SPAN HREF="#"><B  CLASS="function" >strftime()</B
></A
> to represent date.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >T_FMT</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >String that can be used as the format string for <SPAN HREF="#"><B  CLASS="function" >strftime()</B
></A
> to represent time.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >T_FMT_AMPM</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >String that can be used as the format string for <SPAN HREF="#"><B  CLASS="function" >strftime()</B
></A
> to represent time in 12-hour format with ante/post meridian.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >ERA</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Alternate era.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >ERA_YEAR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Year in alternate era format.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >ERA_D_T_FMT</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Date and time in alternate era format (string can be used in <SPAN HREF="#"><B  CLASS="function" >strftime()</B
></A
>).</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >ERA_D_FMT</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Date in alternate era format (string can be used in <SPAN HREF="#"><B  CLASS="function" >strftime()</B
></A
>).</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >ERA_T_FMT</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Time in alternate era format (string can be used in <SPAN HREF="#"><B  CLASS="function" >strftime()</B
></A
>).</TD
></TR
><TR  ><TD  COLSPAN="2" ALIGN="CENTER" VALIGN="MIDDLE" ><SPAN  CLASS="emphasis" ><I  CLASS="emphasis" >LC_MONETARY Category Constants</I
></SPAN
></TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >INT_CURR_SYMBOL</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >International currency symbol.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >CURRENCY_SYMBOL</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Local currency symbol.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >CRNCYSTR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Same value as CURRENCY_SYMBOL.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >MON_DECIMAL_POINT</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Decimal point character.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >MON_THOUSANDS_SEP</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Thousands separator (groups of three digits).</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >MON_GROUPING</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Like 'grouping' element.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >POSITIVE_SIGN</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Sign for positive values.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >NEGATIVE_SIGN</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Sign for negative values.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >INT_FRAC_DIGITS</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >International fractional digits.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >FRAC_DIGITS</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Local fractional digits.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >P_CS_PRECEDES</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Returns 1 if CURRENCY_SYMBOL precedes a positive value.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >P_SEP_BY_SPACE</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Returns 1 if a space separates CURRENCY_SYMBOL from a positive value.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >N_CS_PRECEDES</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Returns 1 if CURRENCY_SYMBOL precedes a negative value.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >N_SEP_BY_SPACE</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Returns 1 if a space separates CURRENCY_SYMBOL from a negative value.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >P_SIGN_POSN</TD
><TD  ROWSPAN="2" WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >          <P  ></P
><UL  ><LI  ><P  >              Returns 0 if parentheses surround the quantity and currency_symbol.
            </P
></LI
><LI  ><P  >             Returns 1 if the sign string precedes the quantity and currency_symbol.
            </P
></LI
><LI  ><P  >             Returns 2 if the sign string follows the quantity and currency_symbol.
            </P
></LI
><LI  ><P  >             Returns 3 if the sign string immediately precedes the currency_symbol.
            </P
></LI
><LI  ><P  >             Returns 4 if the sign string immediately follows the currency_symbol.
            </P
></LI
></UL
>
         </TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >N_SIGN_POSN</TD
></TR
><TR  ><TD  COLSPAN="2" ALIGN="CENTER" VALIGN="MIDDLE" ><SPAN  CLASS="emphasis" ><I  CLASS="emphasis" >LC_NUMERIC Category Constants</I
></SPAN
></TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >DECIMAL_POINT</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Decimal point character.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >RADIXCHAR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Same value as DECIMAL_POINT.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >THOUSANDS_SEP</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Separator character for thousands (groups of three digits).</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >THOUSEP</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Same value as THOUSANDS_SEP.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >GROUPING</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" > </TD
></TR
><TR  ><TD  COLSPAN="2" ALIGN="CENTER" VALIGN="MIDDLE" ><SPAN  CLASS="emphasis" ><I  CLASS="emphasis" >LC_MESSAGES Category Constants</I
></SPAN
></TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >YESEXPR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Regex string for matching 'yes' input.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >NOEXPR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Regex string for matching 'no' input.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >YESSTR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Output string for 'yes'.</TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >NOSTR</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Output string for 'no'.</TD
></TR
><TR  ><TD  COLSPAN="2" ALIGN="CENTER" VALIGN="MIDDLE" ><SPAN  CLASS="emphasis" ><I  CLASS="emphasis" >LC_CTYPE Category Constants</I
></SPAN
></TD
></TR
><TR  ><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >CODESET</TD
><TD  WIDTH="50%" ALIGN="LEFT" VALIGN="MIDDLE" >Return a string with the name of the character encoding.</TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>该函数不适用于 Windows 平台！
</P
></BLOCKQUOTE
></DIV
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >setlocale()</B
></A
> and
     <SPAN HREF="#"><B  CLASS="function" >localeconv()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>nl2br</name>
            <signature><![CDATA[string nl2br ( string string)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109295" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >nl2br</B
> ( string string)<BR  ></BR
><P  >     Returns <TT  CLASS="parameter" ><I  >string</I
></TT
> with '<br />' inserted
     before all newlines.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
     Starting with PHP 4.0.5, <B  CLASS="function" >nl2br()</B
> is now XHTML
     compliant.  All versions before 4.0.5 will return
     <TT  CLASS="parameter" ><I  >string</I
></TT
> with '<br>' inserted before
     newlines instead of '<br />'.
    </P
></BLOCKQUOTE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109310" ></A
><P  ><B  >例子 1. using <B  CLASS="function" >nl2br()</B
></B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">nl2br</font><font  color="#007700">(</font><font  color="#DD0000">"foo isn't\n bar"</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >       this will output :
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >foo isn't<br />
 bar</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >wordwrap()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >str_replace()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>number_format</name>
            <signature><![CDATA[string number_format ( float number [, int decimals])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109325" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >number_format</B
> ( float number [, int decimals])<BR  ></BR
>string <B  CLASS="methodname" >number_format</B
> ( float number, int decimals, string dec_point, string thousands_sep)<BR  ></BR
><P  >     <B  CLASS="function" >number_format()</B
> returns a formatted version of
     <TT  CLASS="parameter" ><I  >number</I
></TT
>.  This function accepts either one,
     two or four parameters (not three):
    </P
><P  >If only one parameter is given,
     <TT  CLASS="parameter" ><I  >number</I
></TT
> will be formatted without decimals,
     but with a comma (",") between every group of thousands.
    </P
><P  >     If two parameters are given, <TT  CLASS="parameter" ><I  >number</I
></TT
> will
     be formatted with <TT  CLASS="parameter" ><I  >decimals</I
></TT
> decimals with a
     dot (".") in front, and a comma (",") between every group of
     thousands.
    </P
><P  >     If all four parameters are given, <TT  CLASS="parameter" ><I  >number</I
></TT
>
     will be formatted with <TT  CLASS="parameter" ><I  >decimals</I
></TT
> decimals,
     <TT  CLASS="parameter" ><I  >dec_point</I
></TT
> instead of a dot (".") before
     the decimals and <TT  CLASS="parameter" ><I  >thousands_sep</I
></TT
> instead of
     a comma (",") between every group of thousands.
    </P
><P  >     Only the first character of <TT  CLASS="parameter" ><I  >thousands_sep</I
></TT
>
     is used.  For example, if you use <TT  CLASS="literal" >foo</TT
> as
     <TT  CLASS="parameter" ><I  >thousands_sep</I
></TT
> on the number
     <TT  CLASS="literal" >1000</TT
>, <B  CLASS="function" >number_format()</B
> will
     return <TT  CLASS="literal" >1f000</TT
>.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109372" ></A
><P  ><B  >例子 1. <B  CLASS="function" >number_format()</B
> Example</B
></P
><P  >       For instance, French notation usually use two decimals,
       comma (',') as decimal separator, and space (' ') as
       thousand separator. This is achieved with this line :
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$number </font><font  color="#007700">= </font><font  color="#0000BB">1234.56</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// english notation (default)<br  /></font><font  color="#0000BB">$english_format_number </font><font  color="#007700">= </font><font  color="#0000BB">number_format</font><font  color="#007700">(</font><font  color="#0000BB">$number</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// 1,234<br  /><br  />// French notation<br  /></font><font  color="#0000BB">$nombre_format_francais </font><font  color="#007700">= </font><font  color="#0000BB">number_format</font><font  color="#007700">(</font><font  color="#0000BB">$number</font><font  color="#007700">, </font><font  color="#0000BB">2</font><font  color="#007700">, </font><font  color="#DD0000">','</font><font  color="#007700">, </font><font  color="#DD0000">' '</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// 1 234,56<br  /><br  /></font><font  color="#0000BB">$number </font><font  color="#007700">= </font><font  color="#0000BB">1234.5678</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// english notation without thousands seperator<br  /></font><font  color="#0000BB">$english_format_number </font><font  color="#007700">= </font><font  color="#0000BB">number_format</font><font  color="#007700">(</font><font  color="#0000BB">$number</font><font  color="#007700">, </font><font  color="#0000BB">2</font><font  color="#007700">, </font><font  color="#DD0000">'.'</font><font  color="#007700">, </font><font  color="#DD0000">''</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// 1234.57<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also: <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >sscanf()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>ord</name>
            <signature><![CDATA[int ord ( string string)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109385" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >ord</B
> ( string string)<BR  ></BR
><P  >     Returns the ASCII value of the first character of
     <TT  CLASS="parameter" ><I  >string</I
></TT
>.  This function complements
     <SPAN HREF="#"><B  CLASS="function" >chr()</B
></A
>.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109396" ></A
><P  ><B  >例子 1. <B  CLASS="function" >ord()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"\n"</font><font  color="#007700">;<br  />if (</font><font  color="#0000BB">ord</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">) == </font><font  color="#0000BB">10</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">"The first character of \$str is a line feed.\n"</font><font  color="#007700">;<br  />}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     You can find an ASCII-table over here: <SPAN HREF="#">http://www.asciitable.com</A
>.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >chr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>parse_str</name>
            <signature><![CDATA[void parse_str ( string str [, array arr])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109408" ></A
><H2  >Description</H2
>void <B  CLASS="methodname" >parse_str</B
> ( string str [, array arr])<BR  ></BR
><P  >     Parses <TT  CLASS="parameter" ><I  >str</I
></TT
> as if it were the query string
     passed via a URL and sets variables in the current scope. If 
     the second parameter <TT  CLASS="parameter" ><I  >arr</I
></TT
> is present, 
     variables are stored in this variable as array elements instead. 
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      Support for the optional second parameter was added in PHP 4.0.3.
     </P
></BLOCKQUOTE
></DIV
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      To get the current <SPAN  CLASS="emphasis" ><I  CLASS="emphasis" >QUERY_STRING</I
></SPAN
>, you may use the variable 
      <SPAN HREF="#">$_SERVER['QUERY_STRING']</A
>.
      Also, you may want to read the section on 
      <SPAN HREF="#">variables from outside of PHP</A
>.
     </P
></BLOCKQUOTE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109430" ></A
><P  ><B  >例子 1. Using <B  CLASS="function" >parse_str()</B
></B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"first=value&arr[]=foo+bar&arr[]=baz"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">parse_str</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$first</font><font  color="#007700">;  </font><font  color="#FF8000">// value<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$arr</font><font  color="#007700">[</font><font  color="#0000BB">0</font><font  color="#007700">]; </font><font  color="#FF8000">// foo bar<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$arr</font><font  color="#007700">[</font><font  color="#0000BB">1</font><font  color="#007700">]; </font><font  color="#FF8000">// baz<br  /><br  /></font><font  color="#0000BB">parse_str</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">, </font><font  color="#0000BB">$output</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$output</font><font  color="#007700">[</font><font  color="#DD0000">'first'</font><font  color="#007700">];  </font><font  color="#FF8000">// value<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$output</font><font  color="#007700">[</font><font  color="#DD0000">'arr'</font><font  color="#007700">][</font><font  color="#0000BB">0</font><font  color="#007700">]; </font><font  color="#FF8000">// foo bar<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$output</font><font  color="#007700">[</font><font  color="#DD0000">'arr'</font><font  color="#007700">][</font><font  color="#0000BB">1</font><font  color="#007700">]; </font><font  color="#FF8000">// baz<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >parse_url()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >pathinfo()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >set_magic_quotes_runtime()</B
></A
>, and <SPAN HREF="#"><B  CLASS="function" >urldecode()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>print</name>
            <signature><![CDATA[int print ( string arg)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109443" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >print</B
> ( string arg)<BR  ></BR
><P  >     Outputs <TT  CLASS="parameter" ><I  >arg</I
></TT
>. Returns <TT  CLASS="literal" >1</TT
>,
     always.
    </P
><P  >     <B  CLASS="function" >print()</B
> is not actually a real function (it is a
     language construct) so you are not required to use parentheses
     with its argument list. 
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109457" ></A
><P  ><B  >例子 1. <B  CLASS="function" >print()</B
> examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#007700">print(</font><font  color="#DD0000">"Hello World"</font><font  color="#007700">);<br  /><br  />print </font><font  color="#DD0000">"print() also works without parentheses."</font><font  color="#007700">;<br  /><br  />print </font><font  color="#DD0000">"This spans<br  />multiple lines. The newlines will be <br  />output as well"</font><font  color="#007700">;<br  /><br  />print </font><font  color="#DD0000">"This spans\nmultiple lines. The newlines will be\noutput as well."</font><font  color="#007700">;<br  /><br  />print </font><font  color="#DD0000">"escaping characters is done \"Like this\"."</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// You can use variables inside of a print statement<br  /></font><font  color="#0000BB">$foo </font><font  color="#007700">= </font><font  color="#DD0000">"foobar"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= </font><font  color="#DD0000">"barbaz"</font><font  color="#007700">;<br  /><br  />print </font><font  color="#DD0000">"foo is $foo"</font><font  color="#007700">; </font><font  color="#FF8000">// foo is foobar<br  /><br  />// You can also use arrays<br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= array(</font><font  color="#DD0000">"value" </font><font  color="#007700">=> </font><font  color="#DD0000">"foo"</font><font  color="#007700">);<br  /><br  />print </font><font  color="#DD0000">"this is {$bar['value']} !"</font><font  color="#007700">; </font><font  color="#FF8000">// this is foo !<br  /><br  />// Using single quotes will print the variable name, not the value<br  /></font><font  color="#007700">print </font><font  color="#DD0000">'foo is $foo'</font><font  color="#007700">; </font><font  color="#FF8000">// foo is $foo<br  /><br  />// If you are not using any other characters, you can just print variables<br  /></font><font  color="#007700">print </font><font  color="#0000BB">$foo</font><font  color="#007700">;          </font><font  color="#FF8000">// foobar<br  /><br  /></font><font  color="#007700">print <<<END<br  /></font><font  color="#0000BB">This uses the "here document" syntax to output<br  />multiple lines with $variable interpolation. Note<br  />that the here document terminator must appear on a<br  />line with just a semicolon no extra whitespace!<br  /></font><font  color="#007700">END;</font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     For a short discussion about the differences between 
     <B  CLASS="function" >print()</B
> and <SPAN HREF="#"><B  CLASS="function" >echo()</B
></A
>, see this FAQTs
     Knowledge Base Article: <SPAN HREF="#">http://www.faqts.com/knowledge_base/view.phtml/aid/1/fid/40
     </A
>
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>由于这是一个语言结构而非函数，因此它无法被“<SPAN HREF="#">变量函数</A
>”调用。</P
></BLOCKQUOTE
></DIV
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >echo()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >flush()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>printf</name>
            <signature><![CDATA[void printf ( string format [, mixed args])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109476" ></A
><H2  >Description</H2
>void <B  CLASS="methodname" >printf</B
> ( string format [, mixed args])<BR  ></BR
><P  >     Produces output according to <TT  CLASS="parameter" ><I  >format</I
></TT
>, which
     is described in the documentation for <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >print()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >vprintf()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >sscanf()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >fscanf()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >flush()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>quoted_printable_decode</name>
            <signature><![CDATA[string quoted_printable_decode ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109501" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >quoted_printable_decode</B
> ( string str)<BR  ></BR
><P  >     This function returns an 8-bit binary string corresponding to the
     decoded quoted printable string.  This function is similar to
     <SPAN HREF="#"><B  CLASS="function" >imap_qprint()</B
></A
>, except this one does not
     require the IMAP module to work.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>quotemeta</name>
            <signature><![CDATA[string quotemeta ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109515" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >quotemeta</B
> ( string str)<BR  ></BR
><P  >     Returns a version of str with a backslash character
     (<TT  CLASS="literal" >\</TT
>) before every character that is among
     these: <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >. \\ + * ? [ ^ ] ( $ )</PRE
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >addslashes()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >htmlentities()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >nl2br()</B
></A
>, and 
     <SPAN HREF="#"><B  CLASS="function" >stripslashes()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>rtrim</name>
            <signature><![CDATA[string rtrim ( string str [, string charlist])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109536" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >rtrim</B
> ( string str [, string charlist])<BR  ></BR
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The second parameter was added in PHP 4.1.0
     </P
></BLOCKQUOTE
></DIV
><P  >     This function returns a string with whitespace stripped from the
     end of <TT  CLASS="parameter" ><I  >str</I
></TT
>.
     Without the second parameter,
     <B  CLASS="function" >rtrim()</B
> will strip these characters:
     
     </P><P  ></P
><UL  ><LI  ><P  >        " " (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >32</TT
> 
        (<TT  CLASS="literal" >0x20</TT
>)), an ordinary space.
       </P
></LI
><LI  ><P  >        "\t" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >9</TT
> 
        (<TT  CLASS="literal" >0x09</TT
>)), a tab.
       </P
></LI
><LI  ><P  >        "\n" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >10</TT
> 
        (<TT  CLASS="literal" >0x0A</TT
>)), a new line (line feed).
       </P
></LI
><LI  ><P  >        "\r" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >13</TT
> 
        (<TT  CLASS="literal" >0x0D</TT
>)), a carriage return.
       </P
></LI
><LI  ><P  >        "\0" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >0</TT
> 
        (<TT  CLASS="literal" >0x00</TT
>)), the <TT  CLASS="literal" >NUL</TT
>-byte.
       </P
></LI
><LI  ><P  > 
        "\x0B" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >11</TT
> 
        (<TT  CLASS="literal" >0x0B</TT
>)), a vertical tab.
       </P
></LI
></UL
>
    </P
><P  >     You can also specify the characters you want to strip, by means
     of the <TT  CLASS="parameter" ><I  >charlist</I
></TT
> parameter.
     Simply list all characters that you want to be stripped. With
     <TT  CLASS="literal" >..</TT
> you can specify a range of characters.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109587" ></A
><P  ><B  >例子 1. Usage example of <B  CLASS="function" >rtrim()</B
></B
></P
><P  >      <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$text </font><font  color="#007700">= </font><font  color="#DD0000">"\t\tThese are a few words :) ...  "</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$trimmed </font><font  color="#007700">= </font><font  color="#0000BB">rtrim</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// $trimmed = "\t\tThese are a few words :) ..."<br  /></font><font  color="#0000BB">$trimmed </font><font  color="#007700">= </font><font  color="#0000BB">rtrim</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">, </font><font  color="#DD0000">" \t."</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// $trimmed = "\t\tThese are a few words :)"<br  /></font><font  color="#0000BB">$clean </font><font  color="#007700">= </font><font  color="#0000BB">rtrim</font><font  color="#007700">(</font><font  color="#0000BB">$binary</font><font  color="#007700">, </font><font  color="#DD0000">"\0x00..\0x1F"</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// trim the ASCII control characters at the end of $binary <br  />// (from 0 to 31 inclusive)<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
>
     </P
></DIV
></TD
></TR
></TABLE
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >trim()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >ltrim()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>setlocale</name>
            <signature><![CDATA[string setlocale ( mixed category, string locale [, string ...])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109599" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >setlocale</B
> ( mixed category, string locale [, string ...])<BR  ></BR
>string <B  CLASS="methodname" >setlocale</B
> ( mixed category, array locale)<BR  ></BR
><P  >     <TT  CLASS="parameter" ><I  >category</I
></TT
> is a named constant (or string)
     specifying the category of the functions affected by the locale
     setting:
     </P><P  ></P
><UL  ><LI  ><P  >        LC_ALL for all of the below
       </P
></LI
><LI  ><P  >        LC_COLLATE for string comparison, see
        <SPAN HREF="#"><B  CLASS="function" >strcoll()</B
></A
>
       </P
></LI
><LI  ><P  >        LC_CTYPE for character classification and conversion, for
        example <SPAN HREF="#"><B  CLASS="function" >strtoupper()</B
></A
>
       </P
></LI
><LI  ><P  >        LC_MONETARY for <SPAN HREF="#"><B  CLASS="function" >localeconv()</B
></A
>
       </P
></LI
><LI  ><P  > LC_NUMERIC for decimal separator (See also
       <SPAN HREF="#"><B  CLASS="function" >localeconv()</B
></A
>)
       </P
></LI
><LI  ><P  >        LC_TIME for date and time formatting with
        <SPAN HREF="#"><B  CLASS="function" >strftime()</B
></A
>
       </P
></LI
></UL
>
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      As of PHP 4.2.0, passing <TT  CLASS="parameter" ><I  >category</I
></TT
> as a string is
      deprecated, use the above constants instead.  Passing them as a string
      (within quotes) will result in a warning message.
     </P
></BLOCKQUOTE
></DIV
><P  >     If <TT  CLASS="parameter" ><I  >locale</I
></TT
> is the empty string
     <TT  CLASS="literal" >""</TT
>, the locale names will be set from the
     values of environment variables with the same names as the above
     categories, or from "LANG".
    </P
><P  >     If <TT  CLASS="parameter" ><I  >locale</I
></TT
> is <TT  CLASS="constant" ><B  >NULL</B
></TT
> or <TT  CLASS="literal" >"0"</TT
>,
     the locale setting is not affected, only the current setting is returned.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >locale</I
></TT
> is an array or followed by additional
     parameters then each array element or parameter is tried to be set as
     new locale until success. This is useful if a locale is known under
     different names on different systems or for providing a fallback 
     for a possibly not available locale.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      Passing multiple locales is not available before PHP 4.3.0
     </P
></BLOCKQUOTE
></DIV
><P  >     Setlocale returns the new current locale, or <TT  CLASS="constant" ><B  >FALSE</B
></TT
> if the locale
     functionality is not implemented on your platform, the specified
     locale does not exist or the category name is invalid.
     An invalid category name also causes a warning message. Category/locale
     names can be found in <SPAN HREF="#">RFC 1766</A
>
     and <SPAN HREF="#">ISO 639</A
>.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The return value of <B  CLASS="function" >setlocale()</B
> depends
      on the system that PHP is running.  It returns exactly
      what the system setlocale function returns.
     </P
></BLOCKQUOTE
></DIV
><DIV  CLASS="tip" ><BLOCKQUOTE  CLASS="tip" ><P  ><B  >提示: </B
>
      Windows users will find useful information about
      <TT  CLASS="parameter" ><I  >locale</I
></TT
> strings at Microsoft's
      <SPAN  CLASS="acronym" >MSDN</SPAN
>website. Supported language strings can be found
      at <SPAN HREF="#">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_crt_language_strings.asp</A
> and supported
      country/region strings at <SPAN HREF="#">      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_crt_country_strings.asp</A
>. Windows systems support the three letter codes for
      country/region specified by <TT  CLASS="literal" >ISO 3166-Alpha-3</TT
>, which
      can be found at this <SPAN HREF="#">Unicode website
      </A
>. 
     </P
></BLOCKQUOTE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109672" ></A
><P  ><B  >例子 1. <B  CLASS="function" >setlocale()</B
> Examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#FF8000">/* Set locale to Dutch */<br  /></font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_ALL</font><font  color="#007700">, </font><font  color="#DD0000">'nl_NL'</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">/* Output: vrijdag 22 december 1978 */<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">strftime</font><font  color="#007700">(</font><font  color="#DD0000">"%A %e %B %Y"</font><font  color="#007700">, </font><font  color="#0000BB">mktime</font><font  color="#007700">(</font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">12</font><font  color="#007700">, </font><font  color="#0000BB">22</font><font  color="#007700">, </font><font  color="#0000BB">1978</font><font  color="#007700">));<br  /><br  /></font><font  color="#FF8000">/* try different possible locale names for german as of PHP 4.3.0 */<br  /></font><font  color="#0000BB">$loc_de </font><font  color="#007700">= </font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_ALL</font><font  color="#007700">, </font><font  color="#DD0000">'de_DE@euro'</font><font  color="#007700">, </font><font  color="#DD0000">'de_DE'</font><font  color="#007700">, </font><font  color="#DD0000">'de'</font><font  color="#007700">, </font><font  color="#DD0000">'ge'</font><font  color="#007700">);<br  />echo </font><font  color="#DD0000">"Preferred locale for german on this system is '$loc_de'"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109677" ></A
><P  ><B  >例子 2. <B  CLASS="function" >setlocale()</B
> Examples for Windows</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#FF8000">/* Set locale to Dutch */<br  /></font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_ALL</font><font  color="#007700">, </font><font  color="#DD0000">'nld_nld'</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">/* Output: vrijdag 22 december 1978 */<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">strftime</font><font  color="#007700">(</font><font  color="#DD0000">"%A %d %B %Y"</font><font  color="#007700">, </font><font  color="#0000BB">mktime</font><font  color="#007700">(</font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">12</font><font  color="#007700">, </font><font  color="#0000BB">22</font><font  color="#007700">, </font><font  color="#0000BB">1978</font><font  color="#007700">));<br  /><br  /></font><font  color="#FF8000">/* try different possible locale names for german as of PHP 4.3.0 */<br  /></font><font  color="#0000BB">$loc_de </font><font  color="#007700">= </font><font  color="#0000BB">setlocale</font><font  color="#007700">(</font><font  color="#0000BB">LC_ALL</font><font  color="#007700">, </font><font  color="#DD0000">'de_DE@euro'</font><font  color="#007700">, </font><font  color="#DD0000">'de_DE'</font><font  color="#007700">, </font><font  color="#DD0000">'deu_deu'</font><font  color="#007700">);<br  />echo </font><font  color="#DD0000">"Preferred locale for german on this system is '$loc_de'"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>sha1_file</name>
            <signature><![CDATA[string sha1_file ( string filename [, bool raw_output])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109685" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >sha1_file</B
> ( string filename [, bool raw_output])<BR  ></BR
><P  >     Calculates the sha1 hash of <TT  CLASS="parameter" ><I  >filename</I
></TT
> using the
     <SPAN HREF="#">US Secure Hash Algorithm 1</A
>,
     and returns that hash. The hash is a 40-character hexadecimal number.
     Upon failure, <TT  CLASS="constant" ><B  >FALSE</B
></TT
> is returned.  If the optional 
     <TT  CLASS="parameter" ><I  >raw_output</I
></TT
> is set to <TT  CLASS="constant" ><B  >TRUE</B
></TT
>, then the sha1 digest 
     is instead returned in raw binary format with a length of 20.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The optional <TT  CLASS="parameter" ><I  >raw_output</I
></TT
> parameter was added in
      PHP 5.0.0 and defaults to <TT  CLASS="constant" ><B  >FALSE</B
></TT
>
     </P
></BLOCKQUOTE
></DIV
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >sha1()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >crc32()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >md5_file()</B
></A
> 
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>sha1</name>
            <signature><![CDATA[string sha1 ( string str [, bool raw_output])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109714" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >sha1</B
> ( string str [, bool raw_output])<BR  ></BR
><P  >     Calculates the sha1 hash of <TT  CLASS="parameter" ><I  >str</I
></TT
> using the
     <SPAN HREF="#">US Secure Hash Algorithm 1</A
>,
     and returns that hash. The hash is a 40-character hexadecimal number.
     If the optional <TT  CLASS="parameter" ><I  >raw_output</I
></TT
> is set to <TT  CLASS="constant" ><B  >TRUE</B
></TT
>,
     then the sha1 digest is instead returned in raw binary format with a
     length of 20. 
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The optional <TT  CLASS="parameter" ><I  >raw_output</I
></TT
> parameter was added in
      PHP 5.0.0 and defaults to <TT  CLASS="constant" ><B  >FALSE</B
></TT
>
     </P
></BLOCKQUOTE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109735" ></A
><P  ><B  >例子 1. A <B  CLASS="function" >sha1()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">'apple'</font><font  color="#007700">;<br  />                     <br  />if (</font><font  color="#0000BB">sha1</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">) === </font><font  color="#DD0000">'d0be2dc421be4fcd0172e5afceea3970e2f3d940'</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">"Would you like a green or red apple?"</font><font  color="#007700">;<br  />    exit;<br  />}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >sha1_file()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >crc32()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >md5()</B
></A
> 
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>similar_text</name>
            <signature><![CDATA[int similar_text ( string first, string second [, float percent])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109747" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >similar_text</B
> ( string first, string second [, float percent])<BR  ></BR
><P  >     This calculates the similarity between two strings as described
     in Oliver [1993]. Note that this implementation does not use a
     stack as in Oliver's pseudo code, but recursive calls which may
     or may not speed up the whole process. Note also that the
     complexity of this algorithm is O(N**3) where N is the length of
     the longest string.
    </P
><P  >     By passing a reference as third argument,
     <B  CLASS="function" >similar_text()</B
> will calculate the similarity
     in percent for you. It returns the number of matching chars in
     both strings.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>soundex</name>
            <signature><![CDATA[string soundex ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109768" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >soundex</B
> ( string str)<BR  ></BR
><P  >     Calculates the soundex key of <TT  CLASS="parameter" ><I  >str</I
></TT
>.
    </P
><P  >     Soundex keys have the property that words pronounced similarly
     produce the same soundex key, and can thus be used to simplify
     searches in databases where you know the pronunciation but not
     the spelling. This soundex function returns a string 4 characters
     long, starting with a letter.
    </P
><P  >     This particular soundex function is one described by Donald Knuth
     in "The Art Of Computer Programming, vol. 3: Sorting And
     Searching", Addison-Wesley (1973), pp. 391-392.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109781" ></A
><P  ><B  >例子 1. Soundex Examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Euler"</font><font  color="#007700">) == </font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Ellery"</font><font  color="#007700">); </font><font  color="#FF8000">// E460<br  /></font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Gauss"</font><font  color="#007700">) == </font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Ghosh"</font><font  color="#007700">); </font><font  color="#FF8000">// G200<br  /></font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Hilbert"</font><font  color="#007700">) == </font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Heilbronn"</font><font  color="#007700">); </font><font  color="#FF8000">// H416<br  /></font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Knuth"</font><font  color="#007700">) == </font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Kant"</font><font  color="#007700">); </font><font  color="#FF8000">// K530<br  /></font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Lloyd"</font><font  color="#007700">) == </font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Ladd"</font><font  color="#007700">); </font><font  color="#FF8000">// L300<br  /></font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Lukasiewicz"</font><font  color="#007700">) == </font><font  color="#0000BB">soundex</font><font  color="#007700">(</font><font  color="#DD0000">"Lissajous"</font><font  color="#007700">); </font><font  color="#FF8000">// L222<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >levenshtein()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >metaphone()</B
></A
>, and <SPAN HREF="#"><B  CLASS="function" >similar_text()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>sprintf</name>
            <signature><![CDATA[]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109874" ></A
><H2  >Examples</H2
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109877" ></A
><P  ><B  >例子 5. <B  CLASS="function" >sprintf()</B
>: zero-padded integers</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$isodate </font><font  color="#007700">= </font><font  color="#0000BB">sprintf</font><font  color="#007700">(</font><font  color="#DD0000">"%04d-%02d-%02d"</font><font  color="#007700">, </font><font  color="#0000BB">$year</font><font  color="#007700">, </font><font  color="#0000BB">$month</font><font  color="#007700">, </font><font  color="#0000BB">$day</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109881" ></A
><P  ><B  >例子 6. <B  CLASS="function" >sprintf()</B
>: formatting currency</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$money1 </font><font  color="#007700">= </font><font  color="#0000BB">68.75</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$money2 </font><font  color="#007700">= </font><font  color="#0000BB">54.35</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$money </font><font  color="#007700">= </font><font  color="#0000BB">$money1 </font><font  color="#007700">+ </font><font  color="#0000BB">$money2</font><font  color="#007700">;<br  /></font><font  color="#FF8000">// echo $money will output "123.1";<br  /></font><font  color="#0000BB">$formatted </font><font  color="#007700">= </font><font  color="#0000BB">sprintf</font><font  color="#007700">(</font><font  color="#DD0000">"%01.2f"</font><font  color="#007700">, </font><font  color="#0000BB">$money</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// echo $formatted will output "123.10"<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>sscanf</name>
            <signature><![CDATA[mixed sscanf ( string str, string format [, string var1])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109889" ></A
><H2  >Description</H2
>mixed <B  CLASS="methodname" >sscanf</B
> ( string str, string format [, string var1])<BR  ></BR
><P  >     The function <B  CLASS="function" >sscanf()</B
> is the input analog of
     <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
>. <B  CLASS="function" >sscanf()</B
> reads
     from the string <TT  CLASS="parameter" ><I  >str</I
></TT
> and interprets it
     according to the specified <TT  CLASS="parameter" ><I  >format</I
></TT
>. If only
     two parameters were passed to this function, the values parsed
     will be returned as an array.
    </P
><P  >     Any whitespace in the format string matches any whitespace in the input
     string. This means that even a tab \t in the format string can match a
     single space character in the input string.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109911" ></A
><P  ><B  >例子 1. <B  CLASS="function" >sscanf()</B
> Example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#FF8000">// getting the serial number<br  /></font><font  color="#0000BB">$serial </font><font  color="#007700">= </font><font  color="#0000BB">sscanf</font><font  color="#007700">(</font><font  color="#DD0000">"SN/2350001"</font><font  color="#007700">, </font><font  color="#DD0000">"SN/%d"</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// and the date of manufacturing<br  /></font><font  color="#0000BB">$mandate </font><font  color="#007700">= </font><font  color="#DD0000">"January 01 2000"</font><font  color="#007700">;<br  />list(</font><font  color="#0000BB">$month</font><font  color="#007700">, </font><font  color="#0000BB">$day</font><font  color="#007700">, </font><font  color="#0000BB">$year</font><font  color="#007700">) = </font><font  color="#0000BB">sscanf</font><font  color="#007700">(</font><font  color="#0000BB">$mandate</font><font  color="#007700">, </font><font  color="#DD0000">"%s %d %d"</font><font  color="#007700">);<br  />echo </font><font  color="#DD0000">"Item $serial was manufactured on: $year-" </font><font  color="#007700">. </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#0000BB">$month</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">3</font><font  color="#007700">) . </font><font  color="#DD0000">"-$day\n"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
     If optional parameters are passed, the function will return the
     number of assigned values. The optional parameters must be passed
     by reference.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109915" ></A
><P  ><B  >例子 2. <B  CLASS="function" >sscanf()</B
> - using optional parameters</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#FF8000">// get author info and generate DocBook entry<br  /></font><font  color="#0000BB">$auth </font><font  color="#007700">= </font><font  color="#DD0000">"24\tLewis Carroll"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$n </font><font  color="#007700">= </font><font  color="#0000BB">sscanf</font><font  color="#007700">(</font><font  color="#0000BB">$auth</font><font  color="#007700">, </font><font  color="#DD0000">"%d\t%s %s"</font><font  color="#007700">, &</font><font  color="#0000BB">$id</font><font  color="#007700">, &</font><font  color="#0000BB">$first</font><font  color="#007700">, &</font><font  color="#0000BB">$last</font><font  color="#007700">);<br  />echo </font><font  color="#DD0000">"<author id='$id'><br  />    <firstname>$first</firstname><br  />    <surname>$last</surname><br  /></author>\n"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >fscanf()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>. 
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>str_ireplace</name>
            <signature><![CDATA[mixed str_ireplace ( mixed search, mixed replace, mixed subject [, int &count])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109928" ></A
><H2  >Description</H2
>mixed <B  CLASS="methodname" >str_ireplace</B
> ( mixed search, mixed replace, mixed subject [, int &count])<BR  ></BR
><P  >     This function returns a string or an array with all occurrences of
     <TT  CLASS="parameter" ><I  >search</I
></TT
> in <TT  CLASS="parameter" ><I  >subject</I
></TT
>
     (ignoring case) replaced with the given <TT  CLASS="parameter" ><I  >replace</I
></TT
> 
     value.  If you don't need fancy replacing rules, you should generally
     use this function instead of <SPAN HREF="#"><B  CLASS="function" >eregi_replace()</B
></A
> or
     <SPAN HREF="#"><B  CLASS="function" >preg_replace()</B
></A
> with the <TT  CLASS="literal" >i</TT
> modifier.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >subject</I
></TT
> is an array, then the search
     and replace is performed with every entry of
     <TT  CLASS="parameter" ><I  >subject</I
></TT
>, and the return value is an array
     as well.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >search</I
></TT
> and
     <TT  CLASS="parameter" ><I  >replace</I
></TT
> are arrays, then
     <B  CLASS="function" >str_ireplace()</B
> takes a value from each array
     and uses them to do search and replace on
     <TT  CLASS="parameter" ><I  >subject</I
></TT
>. If
     <TT  CLASS="parameter" ><I  >replace</I
></TT
> has fewer values than
     <TT  CLASS="parameter" ><I  >search</I
></TT
>, then an empty string is used for
     the rest of replacement values. If <TT  CLASS="parameter" ><I  >search</I
></TT
>
     is an array and <TT  CLASS="parameter" ><I  >replace</I
></TT
> is a string; then
     this replacement string is used for every value of
     <TT  CLASS="parameter" ><I  >search</I
></TT
>.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN109966" ></A
><P  ><B  >例子 1. <B  CLASS="function" >str_ireplace()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$bodytag </font><font  color="#007700">= </font><font  color="#0000BB">str_ireplace</font><font  color="#007700">(</font><font  color="#DD0000">"%body%"</font><font  color="#007700">, </font><font  color="#DD0000">"black"</font><font  color="#007700">, </font><font  color="#DD0000">"<body text=%BODY%>"</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     This function is binary safe.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      As of <TT  CLASS="literal" >PHP 5.0.0</TT
> the number of matched and replaced
      <TT  CLASS="parameter" ><I  >needles</I
></TT
> will be returned in
      <TT  CLASS="parameter" ><I  >count</I
></TT
> which is passed by reference.
      Prior to <TT  CLASS="literal" >PHP 5.0.0</TT
> this parameter is not available.
     </P
></BLOCKQUOTE
></DIV
><P  >     See also: 
     <SPAN HREF="#"><B  CLASS="function" >str_replace()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >ereg_replace()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >preg_replace()</B
></A
>, and 
     <SPAN HREF="#"><B  CLASS="function" >strtr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>str_pad</name>
            <signature><![CDATA[string str_pad ( string input, int pad_length [, string pad_string [, int pad_type]])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN109986" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >str_pad</B
> ( string input, int pad_length [, string pad_string [, int pad_type]])<BR  ></BR
><P  >     This functions returns the <TT  CLASS="parameter" ><I  >input</I
></TT
> string 
     padded on the left, the right, or both sides to the specified
     padding length. If the optional argument
     <TT  CLASS="parameter" ><I  >pad_string</I
></TT
> is not supplied, the
     <TT  CLASS="parameter" ><I  >input</I
></TT
> is padded with spaces, otherwise it
     is padded with characters from <TT  CLASS="parameter" ><I  >pad_string</I
></TT
>
     up to the limit.
    </P
><P  >     Optional argument <TT  CLASS="parameter" ><I  >pad_type</I
></TT
> can be
     STR_PAD_RIGHT, STR_PAD_LEFT, or STR_PAD_BOTH.  If
     <TT  CLASS="parameter" ><I  >pad_type</I
></TT
> is not specified it is assumed to
     be STR_PAD_RIGHT.
    </P
><P  >     If the value of <TT  CLASS="parameter" ><I  >pad_length</I
></TT
> is negative or
     less than the length of the input string, no padding takes place.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110014" ></A
><P  ><B  >例子 1. <B  CLASS="function" >str_pad()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$input </font><font  color="#007700">= </font><font  color="#DD0000">"Alien"</font><font  color="#007700">;<br  />echo </font><font  color="#0000BB">str_pad</font><font  color="#007700">(</font><font  color="#0000BB">$input</font><font  color="#007700">, </font><font  color="#0000BB">10</font><font  color="#007700">);                      </font><font  color="#FF8000">// produces "Alien     "<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">str_pad</font><font  color="#007700">(</font><font  color="#0000BB">$input</font><font  color="#007700">, </font><font  color="#0000BB">10</font><font  color="#007700">, </font><font  color="#DD0000">"-="</font><font  color="#007700">, </font><font  color="#0000BB">STR_PAD_LEFT</font><font  color="#007700">);  </font><font  color="#FF8000">// produces "-=-=-Alien"<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">str_pad</font><font  color="#007700">(</font><font  color="#0000BB">$input</font><font  color="#007700">, </font><font  color="#0000BB">10</font><font  color="#007700">, </font><font  color="#DD0000">"_"</font><font  color="#007700">, </font><font  color="#0000BB">STR_PAD_BOTH</font><font  color="#007700">);   </font><font  color="#FF8000">// produces "__Alien___"<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">str_pad</font><font  color="#007700">(</font><font  color="#0000BB">$input</font><font  color="#007700">, </font><font  color="#0000BB">6 </font><font  color="#007700">, </font><font  color="#DD0000">"___"</font><font  color="#007700">);               </font><font  color="#FF8000">// produces "Alien_"<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The <TT  CLASS="parameter" ><I  >pad_string</I
></TT
> may be truncated if the
      required number of padding characters can't be evenly divided by
      the <TT  CLASS="parameter" ><I  >pad_string</I
></TT
>'s length.
     </P
></BLOCKQUOTE
></DIV
></DIV
>]]></description>
        </method>
        <method>
            <name>str_repeat</name>
            <signature><![CDATA[string str_repeat ( string input, int multiplier)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110026" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >str_repeat</B
> ( string input, int multiplier)<BR  ></BR
><P  >     Returns <TT  CLASS="parameter" ><I  >input_str</I
></TT
> repeated
     <TT  CLASS="parameter" ><I  >multiplier</I
></TT
> times.
     <TT  CLASS="parameter" ><I  >multiplier</I
></TT
> has to be greater than or equal to 0.
     If the <TT  CLASS="parameter" ><I  >multiplier</I
></TT
> is set to 0, the function will
     return an empty string.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110042" ></A
><P  ><B  >例子 1. <B  CLASS="function" >str_repeat()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">str_repeat</font><font  color="#007700">(</font><font  color="#DD0000">"-="</font><font  color="#007700">, </font><font  color="#0000BB">10</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     This will output "-=-=-=-=-=-=-=-=-=-=".
    </P
><P  >     See also <SPAN HREF="#">for</A
>,
     <SPAN HREF="#"><B  CLASS="function" >str_pad()</B
></A
>, and 
     <SPAN HREF="#"><B  CLASS="function" >substr_count()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>str_replace</name>
            <signature><![CDATA[mixed str_replace ( mixed search, mixed replace, mixed subject [, int &count])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110055" ></A
><H2  >Description</H2
>mixed <B  CLASS="methodname" >str_replace</B
> ( mixed search, mixed replace, mixed subject [, int &count])<BR  ></BR
><P  >     This function returns a string or an array with all occurrences of
     <TT  CLASS="parameter" ><I  >search</I
></TT
> in <TT  CLASS="parameter" ><I  >subject</I
></TT
>
     replaced with the given <TT  CLASS="parameter" ><I  >replace</I
></TT
> value.  If you
     don't need fancy replacing rules (like regular expressions), you should
     always use this function instead of <SPAN HREF="#"><B  CLASS="function" >ereg_replace()</B
></A
> or
     <SPAN HREF="#"><B  CLASS="function" >preg_replace()</B
></A
>.
    </P
><P  >     As of PHP 4.0.5, every parameter in <B  CLASS="function" >str_replace()</B
>
     can be an <SPAN HREF="#"><B  CLASS="type" >array</B
></A
>. 
    </P
><DIV  CLASS="warning" ><P  ></P
><TABLE  CLASS="warning" BORDER="1" WIDTH="100%" ><TR  ><TD  ALIGN="CENTER" ><B  >警告</B
></TD
></TR
><TR  ><TD  ALIGN="LEFT" ><P  >      In PHP versions prior to 4.3.3 a bug existed when using arrays as
      both <TT  CLASS="parameter" ><I  >search</I
></TT
> and <TT  CLASS="parameter" ><I  >replace</I
></TT
>
      parameters which caused empty <TT  CLASS="parameter" ><I  >search</I
></TT
> indexes
      to be skipped without advancing the internal pointer on the
      <TT  CLASS="parameter" ><I  >replace</I
></TT
> array. This has been corrected in
      <TT  CLASS="literal" >PHP 4.3.3</TT
>, any scripts which relied on this bug
      should remove empty search values prior to calling this function in
      order to mimick the original behavior.
     </P
></TD
></TR
></TABLE
></DIV
><P  >     If <TT  CLASS="parameter" ><I  >subject</I
></TT
> is an array, then the search
     and replace is performed with every entry of
     <TT  CLASS="parameter" ><I  >subject</I
></TT
>, and the return value is an array
     as well.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >search</I
></TT
> and
     <TT  CLASS="parameter" ><I  >replace</I
></TT
> are arrays, then
     <B  CLASS="function" >str_replace()</B
> takes a value from each array
     and uses them to do search and replace on
     <TT  CLASS="parameter" ><I  >subject</I
></TT
>. If
     <TT  CLASS="parameter" ><I  >replace</I
></TT
> has fewer values than
     <TT  CLASS="parameter" ><I  >search</I
></TT
>, then an empty string is used for
     the rest of replacement values. If <TT  CLASS="parameter" ><I  >search</I
></TT
>
     is an array and <TT  CLASS="parameter" ><I  >replace</I
></TT
> is a string; then
     this replacement string is used for every value of
     <TT  CLASS="parameter" ><I  >search</I
></TT
>.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110102" ></A
><P  ><B  >例子 1. <B  CLASS="function" >str_replace()</B
> examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#FF8000">// Provides: <body text='black'><br  /></font><font  color="#0000BB">$bodytag </font><font  color="#007700">= </font><font  color="#0000BB">str_replace</font><font  color="#007700">(</font><font  color="#DD0000">"%body%"</font><font  color="#007700">, </font><font  color="#DD0000">"black"</font><font  color="#007700">, </font><font  color="#DD0000">"<body text='%body%'>"</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">// Provides: Hll Wrld f PHP<br  /></font><font  color="#0000BB">$vowels </font><font  color="#007700">= array(</font><font  color="#DD0000">"a"</font><font  color="#007700">, </font><font  color="#DD0000">"e"</font><font  color="#007700">, </font><font  color="#DD0000">"i"</font><font  color="#007700">, </font><font  color="#DD0000">"o"</font><font  color="#007700">, </font><font  color="#DD0000">"u"</font><font  color="#007700">, </font><font  color="#DD0000">"A"</font><font  color="#007700">, </font><font  color="#DD0000">"E"</font><font  color="#007700">, </font><font  color="#DD0000">"I"</font><font  color="#007700">, </font><font  color="#DD0000">"O"</font><font  color="#007700">, </font><font  color="#DD0000">"U"</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$onlyconsonants </font><font  color="#007700">= </font><font  color="#0000BB">str_replace</font><font  color="#007700">(</font><font  color="#0000BB">$vowels</font><font  color="#007700">, </font><font  color="#DD0000">""</font><font  color="#007700">, </font><font  color="#DD0000">"Hello World of PHP"</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">// Provides: You should eat pizza, beer, and ice cream every day<br  /></font><font  color="#0000BB">$phrase  </font><font  color="#007700">= </font><font  color="#DD0000">"You should eat fruits, vegetables, and fiber every day."</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$healthy </font><font  color="#007700">= array(</font><font  color="#DD0000">"fruits"</font><font  color="#007700">, </font><font  color="#DD0000">"vegetables"</font><font  color="#007700">, </font><font  color="#DD0000">"fiber"</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$yummy   </font><font  color="#007700">= array(</font><font  color="#DD0000">"pizza"</font><font  color="#007700">, </font><font  color="#DD0000">"beer"</font><font  color="#007700">, </font><font  color="#DD0000">"ice cream"</font><font  color="#007700">);<br  /><br  /></font><font  color="#0000BB">$newphrase </font><font  color="#007700">= </font><font  color="#0000BB">str_replace</font><font  color="#007700">(</font><font  color="#0000BB">$healthy</font><font  color="#007700">, </font><font  color="#0000BB">$yummy</font><font  color="#007700">, </font><font  color="#0000BB">$phrase</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">// Use of the count parameter is available as of PHP 5.0.0<br  /></font><font  color="#0000BB">$str </font><font  color="#007700">= </font><font  color="#0000BB">str_replace</font><font  color="#007700">(</font><font  color="#DD0000">"ll"</font><font  color="#007700">, </font><font  color="#DD0000">""</font><font  color="#007700">, </font><font  color="#DD0000">"good golly miss molly!"</font><font  color="#007700">, </font><font  color="#0000BB">$count</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$count</font><font  color="#007700">; </font><font  color="#FF8000">// 2<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>该函数适用于二进制对象！</P
></BLOCKQUOTE
></DIV
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      As of <TT  CLASS="literal" >PHP 5.0.0</TT
> the number of matched and replaced
      needles (<TT  CLASS="parameter" ><I  >search</I
></TT
>) will be returned in
      <TT  CLASS="parameter" ><I  >count</I
></TT
> which is passed by reference.
      Prior to <TT  CLASS="literal" >PHP 5.0.0</TT
> this parameter is not available.
     </P
></BLOCKQUOTE
></DIV
><P  >     See also 
     <SPAN HREF="#"><B  CLASS="function" >str_ireplace()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >substr_replace()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >ereg_replace()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >preg_replace()</B
></A
>, and 
     <SPAN HREF="#"><B  CLASS="function" >strtr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>str_rot13</name>
            <signature><![CDATA[string str_rot13 ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110124" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >str_rot13</B
> ( string str)<BR  ></BR
><P  >     This function performs the ROT13 encoding on the
     <TT  CLASS="parameter" ><I  >str</I
></TT
> argument and returns the resulting
     string. The ROT13 encoding simply shifts every letter by 13
     places in the alphabet while leaving non-alpha characters
     untouched. Encoding and decoding are done by the same function,
     passing an encoded string as argument will return the original version.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110135" ></A
><P  ><B  >例子 1. <B  CLASS="function" >str_rot13()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  /></font><font  color="#007700">echo </font><font  color="#0000BB">str_rot13</font><font  color="#007700">(</font><font  color="#DD0000">'PHP 4.3.0'</font><font  color="#007700">); </font><font  color="#FF8000">// CUC 4.3.0<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The behaviour of this function was buggy until PHP 4.3.0. Before
      this, the <TT  CLASS="parameter" ><I  >str</I
></TT
> was also modified, as if
      passed by reference.
     </P
></BLOCKQUOTE
></DIV
></DIV
>]]></description>
        </method>
        <method>
            <name>str_shuffle</name>
            <signature><![CDATA[string str_shuffle ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110146" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >str_shuffle</B
> ( string str)<BR  ></BR
><P  >     <B  CLASS="function" >str_shuffle()</B
> shuffles a string.  One permutation 
     of all possible is created.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110157" ></A
><P  ><B  >例子 1. <B  CLASS="function" >str_shuffle()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">'abcdef'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$shuffled </font><font  color="#007700">= </font><font  color="#0000BB">str_shuffle</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">// This will echo something like: bfdaec<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$shuffled</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >shuffle()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >rand()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>str_split</name>
            <signature><![CDATA[array str_split ( string string [, int split_length])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110168" ></A
><H2  >Description</H2
>array <B  CLASS="methodname" >str_split</B
> ( string string [, int split_length])<BR  ></BR
><P  >     Converts a string to an array. If the optional
     <TT  CLASS="parameter" ><I  >split_length</I
></TT
> parameter is specified, the
     returned array will be broken down into chunks with each being
     <TT  CLASS="parameter" ><I  >split_length</I
></TT
> in length, otherwise each chunk
     will be one character in length.
    </P
><P  >     <TT  CLASS="constant" ><B  >FALSE</B
></TT
> is returned if <TT  CLASS="parameter" ><I  >split_length</I
></TT
> is less
     than 1.  If the <TT  CLASS="parameter" ><I  >split_length</I
></TT
> length exceeds the
     length of <TT  CLASS="parameter" ><I  >string</I
></TT
>, the entire string is returned
     as the first (and only) array element.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110188" ></A
><P  ><B  >例子 1. Example uses of <B  CLASS="function" >str_split()</B
></B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"Hello Friend"</font><font  color="#007700">;<br  /><br  /></font><font  color="#0000BB">$arr1 </font><font  color="#007700">= </font><font  color="#0000BB">str_split</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$arr2 </font><font  color="#007700">= </font><font  color="#0000BB">str_split</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">, </font><font  color="#0000BB">3</font><font  color="#007700">);<br  /><br  /></font><font  color="#0000BB">print_r</font><font  color="#007700">(</font><font  color="#0000BB">$arr1</font><font  color="#007700">);<br  /></font><font  color="#0000BB">print_r</font><font  color="#007700">(</font><font  color="#0000BB">$arr2</font><font  color="#007700">);<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >       Output may look like:
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >Array
(
    [0] => H
    [1] => e
    [2] => l
    [3] => l
    [4] => o
    [5] =>
    [6] => F
    [7] => r
    [8] => i
    [9] => e
    [10] => n
    [11] => d
)

Array
(
    [0] => Hel
    [1] => lo 
    [2] => Fri
    [3] => end
)</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110195" ></A
><P  ><B  >例子 2. Examples related to <B  CLASS="function" >str_split()</B
></B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"Hello Friend"</font><font  color="#007700">;<br  /><br  />echo </font><font  color="#0000BB">$str</font><font  color="#007700">{</font><font  color="#0000BB">0</font><font  color="#007700">};  </font><font  color="#FF8000">// H<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$str</font><font  color="#007700">{</font><font  color="#0000BB">8</font><font  color="#007700">};  </font><font  color="#FF8000">// i<br  /><br  />// Creates: array('H','e','l','l','o',' ','F','r','i','e','n','d')<br  /></font><font  color="#0000BB">$arr1 </font><font  color="#007700">= </font><font  color="#0000BB">preg_split</font><font  color="#007700">(</font><font  color="#DD0000">'//'</font><font  color="#007700">, </font><font  color="#0000BB">$str</font><font  color="#007700">, -</font><font  color="#0000BB">1</font><font  color="#007700">, </font><font  color="#0000BB">PREG_SPLIT_NO_EMPTY</font><font  color="#007700">);<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >chunk_split()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >preg_split()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >split()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >count_chars()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >str_word_count()</B
></A
>, and 
     <SPAN HREF="#">for</A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>str_word_count</name>
            <signature><![CDATA[mixed str_word_count ( string string [, int format])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110210" ></A
><H2  >Description</H2
>mixed <B  CLASS="methodname" >str_word_count</B
> ( string string [, int format])<BR  ></BR
><P  >     Counts the number of words inside <TT  CLASS="parameter" ><I  >string</I
></TT
>. 
     If the optional <TT  CLASS="parameter" ><I  >format</I
></TT
> is not specified, then 
     the return value will be an integer representing the number of words 
     found. In the event the <TT  CLASS="parameter" ><I  >format</I
></TT
> is specified, the return
     value will be an array, content of which is dependent on the 
     <TT  CLASS="parameter" ><I  >format</I
></TT
>. The possible value for the 
     <TT  CLASS="parameter" ><I  >format</I
></TT
> and the resultant outputs are listed below.
     </P><P  ></P
><UL  ><LI  ><P  >        1 - returns an array containing all the words found inside the
        <TT  CLASS="parameter" ><I  >string</I
></TT
>.
       </P
></LI
><LI  ><P  >        2 - returns an associative array, where the key is the numeric 
        position of the word inside the <TT  CLASS="parameter" ><I  >string</I
></TT
> and 
        the value is the actual word itself.
       </P
></LI
></UL
>
    </P
><P  >     For the purpose of this function, 'word' is defined as a locale dependent
     string containing alphabetic characters, which also may contain, but not start
     with "'" and "-" characters.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110236" ></A
><P  ><B  >例子 1. Example uses for <B  CLASS="function" >str_word_count()</B
></B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"Hello friend, you're<br  />        looking          good today!"</font><font  color="#007700">;<br  /><br  /></font><font  color="#0000BB">$a   </font><font  color="#007700">= </font><font  color="#0000BB">str_word_count</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">, </font><font  color="#0000BB">1</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$b   </font><font  color="#007700">= </font><font  color="#0000BB">str_word_count</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">, </font><font  color="#0000BB">2</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$c   </font><font  color="#007700">= </font><font  color="#0000BB">str_word_count</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  /><br  /></font><font  color="#0000BB">print_r</font><font  color="#007700">(</font><font  color="#0000BB">$a</font><font  color="#007700">);<br  /></font><font  color="#0000BB">print_r</font><font  color="#007700">(</font><font  color="#0000BB">$b</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$c</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >       Output may look like:
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >Array
(
    [0] => Hello
    [1] => friend
    [2] => you're
    [3] => looking
    [4] => good
    [5] => today
)

Array
(
    [0] => Hello
    [6] => friend
    [14] => you're
    [29] => looking
    [46] => good
    [51] => today
)

6</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >explode()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >preg_split()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >split()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >count_chars()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >substr_count()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strcasecmp</name>
            <signature><![CDATA[int strcasecmp ( string str1, string str2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110252" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strcasecmp</B
> ( string str1, string str2)<BR  ></BR
><P  >     Returns < 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
> is less than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>; > 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
>
     is greater than <TT  CLASS="parameter" ><I  >str2</I
></TT
>, and 0 if they are
     equal.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110268" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strcasecmp()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$var1 </font><font  color="#007700">= </font><font  color="#DD0000">"Hello"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$var2 </font><font  color="#007700">= </font><font  color="#DD0000">"hello"</font><font  color="#007700">;<br  />if (</font><font  color="#0000BB">strcasecmp</font><font  color="#007700">(</font><font  color="#0000BB">$var1</font><font  color="#007700">, </font><font  color="#0000BB">$var2</font><font  color="#007700">) == </font><font  color="#0000BB">0</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">'$var1 is equal to $var2 in a case-insensitive string comparison'</font><font  color="#007700">;<br  />}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strncasecmp()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strchr</name>
            <signature><![CDATA[]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110284" ></A
><H2  >Description</H2
><P  >     This function is an alias of <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strcmp</name>
            <signature><![CDATA[int strcmp ( string str1, string str2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110292" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strcmp</B
> ( string str1, string str2)<BR  ></BR
><P  >     Returns < 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
> is less than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>; > 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
>
     is greater than <TT  CLASS="parameter" ><I  >str2</I
></TT
>, and 0 if they are
     equal.
    </P
><P  >     Note that this comparison is case sensitive.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strcasecmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strncasecmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strncmp()</B
></A
>, and <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strcoll</name>
            <signature><![CDATA[int strcoll ( string str1, string str2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110321" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strcoll</B
> ( string str1, string str2)<BR  ></BR
><P  >     Returns < 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
> is less than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>; > 0 if
     <TT  CLASS="parameter" ><I  >str1</I
></TT
> is greater than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>, and 0 if they are equal.
     <B  CLASS="function" >strcoll()</B
> uses the current locale for doing
     the comparisons.  If the current locale is C or POSIX, this
     function is equivalent to <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>.
    </P
><P  >     Note that this comparison is case sensitive, and unlike
     <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
> this function is not binary safe.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      <B  CLASS="function" >strcoll()</B
> was added in PHP 4.0.5, but was not enabled
      for win32 until 4.2.3.
     </P
></BLOCKQUOTE
></DIV
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strcasecmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strncasecmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strncmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >setlocale()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strcspn</name>
            <signature><![CDATA[int strcspn ( string str1, string str2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110358" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strcspn</B
> ( string str1, string str2)<BR  ></BR
><P  >     Returns the length of the initial segment of
     <TT  CLASS="parameter" ><I  >str1</I
></TT
> which does <SPAN  CLASS="emphasis" ><I  CLASS="emphasis" >not</I
></SPAN
>
     contain any of the characters in <TT  CLASS="parameter" ><I  >str2</I
></TT
>.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strspn()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strip_tags</name>
            <signature><![CDATA[string strip_tags ( string str [, string allowable_tags])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110379" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >strip_tags</B
> ( string str [, string allowable_tags])<BR  ></BR
><P  >     This function tries to return a string with all HTML and PHP tags
     stripped from a given <TT  CLASS="parameter" ><I  >str</I
></TT
>.  It uses
     the same tag stripping state machine as the
     <SPAN HREF="#"><B  CLASS="function" >fgetss()</B
></A
> function.
    </P
><P  >     You can use the optional second parameter to specify tags which
     should not be stripped.
     </P><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
       <TT  CLASS="parameter" ><I  >allowable_tags</I
></TT
> was added in PHP 3.0.13
       and PHP 4.0b3. Since PHP 4.3.0, HTML comments are also stripped.
      </P
></BLOCKQUOTE
></DIV
>
     <DIV  CLASS="warning" ><P  ></P
><TABLE  CLASS="warning" BORDER="1" WIDTH="100%" ><TR  ><TD  ALIGN="CENTER" ><B  >警告</B
></TD
></TR
><TR  ><TD  ALIGN="LEFT" ><P  >         Because <B  CLASS="function" >strip_tags()</B
> does not actually validate the
         HTML, partial, or broken tags can result in the removal of more
         text/data than expected.
       </P
></TD
></TR
></TABLE
></DIV
>
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110401" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strip_tags()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$text </font><font  color="#007700">= </font><font  color="#DD0000">'<br  /><p>Test paragraph.</p><br  /><!-- Comment --><br  />Other text'</font><font  color="#007700">;<br  /><br  />echo </font><font  color="#0000BB">strip_tags</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">);<br  /><br  />echo </font><font  color="#DD0000">"\n\n-------\n"</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// allow <p><br  /></font><font  color="#007700">echo </font><font  color="#0000BB">strip_tags</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">, </font><font  color="#DD0000">'<p>'</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >       The above example will output:
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >Test paragraph.

Other text

-------

<p>Test paragraph.</p>

Other text</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><DIV  CLASS="warning" ><P  ></P
><TABLE  CLASS="warning" BORDER="1" WIDTH="100%" ><TR  ><TD  ALIGN="CENTER" ><B  >警告</B
></TD
></TR
><TR  ><TD  ALIGN="LEFT" ><P  >      This function does not modify any attributes on the tags that you allow
      using <TT  CLASS="parameter" ><I  >allowable_tags</I
></TT
>, including the
      <TT  CLASS="literal" >style</TT
> and <TT  CLASS="literal" >onmouseover</TT
> attributes
      that a mischievous user may abuse when posting text that will be shown
      to other users.
     </P
></TD
></TR
></TABLE
></DIV
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >htmlspecialchars()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>stripcslashes</name>
            <signature><![CDATA[string stripcslashes ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110419" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >stripcslashes</B
> ( string str)<BR  ></BR
><P  >     Returns a string with backslashes stripped off. Recognizes
     C-like <TT  CLASS="literal" >\n</TT
>, <TT  CLASS="literal" >\r</TT
> ..., octal
     and hexadecimal representation.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >addcslashes()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>stripos</name>
            <signature><![CDATA[int stripos ( string haystack, string needle [, int offset])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110436" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >stripos</B
> ( string haystack, string needle [, int offset])<BR  ></BR
><P  >     Returns the numeric position of the first occurrence of
     <TT  CLASS="parameter" ><I  >needle</I
></TT
> in the <TT  CLASS="parameter" ><I  >haystack</I
></TT
>
     <SPAN HREF="#"><B  CLASS="type" >string</B
></A
>.  Unlike <B  CLASS="function" > strpos()</B
>, 
     <B  CLASS="function" >stripos()</B
> is case-insensitive.
    </P
><P  >     Note that the <TT  CLASS="parameter" ><I  >needle</I
></TT
> may be a string of one or
     more characters.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not found,
     <B  CLASS="function" >stripos()</B
> will return <SPAN HREF="#"><B  CLASS="type" >boolean</B
></A
> <TT  CLASS="constant" ><B  >FALSE</B
></TT
>.
    </P
><DIV  CLASS="warning" ><P  ></P
><TABLE  CLASS="warning" BORDER="1" WIDTH="100%" ><TR  ><TD  ALIGN="CENTER" ><B  >警告</B
></TD
></TR
><TR  ><TD  ALIGN="LEFT" ><P  >这个函数可能返回 Boolean <TT  CLASS="constant" ><B  >FALSE</B
></TT
>，也可能返回一个与 <TT  CLASS="constant" ><B  >FALSE</B
></TT
> 相等地非 Boolean 值，比如 0 或者 "" 。请参阅 <SPAN HREF="#">Booleans</A
> 的有关章节以获取更多信息。请使用 <SPAN HREF="#">=== 操作符</A
> 来测试该函数的返回值。 </P
></TD
></TR
></TABLE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110470" ></A
><P  ><B  >例子 1. <B  CLASS="function" >stripos()</B
> examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$findme    </font><font  color="#007700">= </font><font  color="#DD0000">'a'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$mystring1 </font><font  color="#007700">= </font><font  color="#DD0000">'xyz'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$mystring2 </font><font  color="#007700">= </font><font  color="#DD0000">'ABC'</font><font  color="#007700">;<br  /><br  /></font><font  color="#0000BB">$pos1 </font><font  color="#007700">= </font><font  color="#0000BB">stripos</font><font  color="#007700">(</font><font  color="#0000BB">$mystring1</font><font  color="#007700">, </font><font  color="#0000BB">$findme</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$pos2 </font><font  color="#007700">= </font><font  color="#0000BB">stripos</font><font  color="#007700">(</font><font  color="#0000BB">$mystring2</font><font  color="#007700">, </font><font  color="#0000BB">$findme</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">// Nope, 'a' is certainly not in 'xyz'<br  /></font><font  color="#007700">if (</font><font  color="#0000BB">$pos1 </font><font  color="#007700">=== </font><font  color="#0000BB">false</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">"The string '$findme' was not found in the string '$mystring1'"</font><font  color="#007700">;<br  />}<br  /><br  /></font><font  color="#FF8000">// Note our use of ===.  Simply == would not work as expected<br  />// because the position of 'a' is the 0th (first) character.<br  /></font><font  color="#007700">if (</font><font  color="#0000BB">$pos2 </font><font  color="#007700">!== </font><font  color="#0000BB">false</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">"We found '$findme' in '$mystring2' at position $pos2"</font><font  color="#007700">;<br  />}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not a string, it is converted
     to an integer and applied as the ordinal value of a character.
    </P
><P  >     The optional <TT  CLASS="parameter" ><I  >offset</I
></TT
> parameter allows you
     to specify which character in <TT  CLASS="parameter" ><I  >haystack</I
></TT
> to
     start searching. The position returned is still relative to the
     the beginning of <TT  CLASS="parameter" ><I  >haystack</I
></TT
>.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strpos()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strrpos()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strrchr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strripos()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >str_ireplace()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>stripslashes</name>
            <signature><![CDATA[string stripslashes ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110494" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >stripslashes</B
> ( string str)<BR  ></BR
><P  >     Returns a string with backslashes stripped off.
     (<TT  CLASS="literal" >\'</TT
> becomes <TT  CLASS="literal" >'</TT
> and so on.)
     Double backslashes (<TT  CLASS="literal" >\\</TT
>) are made into a single
     backslash (<TT  CLASS="literal" >\</TT
>). 
    </P
><P  >     An example use of <B  CLASS="function" >stripslashes()</B
> is when the PHP
     directive <SPAN HREF="#">magic_quotes_gpc</A
>
     is <TT  CLASS="literal" >on</TT
> (it's on by default), and you aren't inserting
     this data into a place (such as a database) that requires escaping.
     For example, if you're simply outputting data straight from an HTML
     form.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110512" ></A
><P  ><B  >例子 1. A <B  CLASS="function" >stripslashes()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"Is your name O\'reilly?"</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">// Outputs: Is your name O'reilly?<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">stripslashes</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >addslashes()</B
></A
> and
     <SPAN HREF="#"><B  CLASS="function" >get_magic_quotes_gpc()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>stristr</name>
            <signature><![CDATA[string stristr ( string haystack, string needle)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110524" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >stristr</B
> ( string haystack, string needle)<BR  ></BR
><P  >     Returns all of <TT  CLASS="parameter" ><I  >haystack</I
></TT
> from the first
     occurrence of <TT  CLASS="parameter" ><I  >needle</I
></TT
> to the end.
     <TT  CLASS="parameter" ><I  >needle</I
></TT
> and <TT  CLASS="parameter" ><I  >haystack</I
></TT
>
     are examined in a case-insensitive manner.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not found, returns <TT  CLASS="constant" ><B  >FALSE</B
></TT
>.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not a string, it is converted
     to an integer and applied as the ordinal value of a character.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110546" ></A
><P  ><B  >例子 1. <B  CLASS="function" >stristr()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />  $email </font><font  color="#007700">= </font><font  color="#DD0000">'USER@EXAMPLE.com'</font><font  color="#007700">;<br  />  </font><font  color="#0000BB">$domain </font><font  color="#007700">= </font><font  color="#0000BB">stristr</font><font  color="#007700">(</font><font  color="#0000BB">$email</font><font  color="#007700">, </font><font  color="#DD0000">'e'</font><font  color="#007700">);<br  />  echo </font><font  color="#0000BB">$domain</font><font  color="#007700">; <br  /></font><font  color="#FF8000">// outputs ER@EXAMPLE.com<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
> 
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strchr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strrchr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strlen</name>
            <signature><![CDATA[int strlen ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110559" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strlen</B
> ( string str)<BR  ></BR
><P  >     Returns the length of <TT  CLASS="parameter" ><I  >string</I
></TT
>.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110570" ></A
><P  ><B  >例子 1. A <B  CLASS="function" >strlen()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">'abcdef'</font><font  color="#007700">;<br  />echo </font><font  color="#0000BB">strlen</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">); </font><font  color="#FF8000">// 6<br  /><br  /></font><font  color="#0000BB">$str </font><font  color="#007700">= </font><font  color="#DD0000">' ab cd '</font><font  color="#007700">;<br  />echo </font><font  color="#0000BB">strlen</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">); </font><font  color="#FF8000">// 7<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >count()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strnatcasecmp</name>
            <signature><![CDATA[int strnatcasecmp ( string str1, string str2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110580" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strnatcasecmp</B
> ( string str1, string str2)<BR  ></BR
><P  >     This function implements a comparison algorithm that orders
     alphanumeric strings in the way a human being would.  The
     behaviour of this function is similar to
     <SPAN HREF="#"><B  CLASS="function" >strnatcmp()</B
></A
>, except that the comparison is not
     case sensitive.  For more information see: Martin Pool's <SPAN HREF="#">Natural Order String Comparison</A
>
     page.
    </P
><P  >     Similar to other string comparison functions, this one returns
     < 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
> is less than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>; > 0 if
     <TT  CLASS="parameter" ><I  >str1</I
></TT
> is greater than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>, and 0 if they are equal.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strcasecmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strncmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strncasecmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strnatcmp()</B
></A
>, and <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strnatcmp</name>
            <signature><![CDATA[int strnatcmp ( string str1, string str2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110613" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strnatcmp</B
> ( string str1, string str2)<BR  ></BR
><P  >     This function implements a comparison algorithm that orders
     alphanumeric strings in the way a human being would, this is
     described as a "natural ordering".  An example of the difference
     between this algorithm and the regular computer string sorting
     algorithms (used in <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>) can be seen
     below:
     </P><DIV  CLASS="informalexample" ><A  NAME="AEN110626" ></A
><P  ></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$arr1 </font><font  color="#007700">= </font><font  color="#0000BB">$arr2 </font><font  color="#007700">= array(</font><font  color="#DD0000">"img12.png"</font><font  color="#007700">, </font><font  color="#DD0000">"img10.png"</font><font  color="#007700">, </font><font  color="#DD0000">"img2.png"</font><font  color="#007700">, </font><font  color="#DD0000">"img1.png"</font><font  color="#007700">);<br  />echo </font><font  color="#DD0000">"Standard string comparison\n"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">usort</font><font  color="#007700">(</font><font  color="#0000BB">$arr1</font><font  color="#007700">, </font><font  color="#DD0000">"strcmp"</font><font  color="#007700">);<br  /></font><font  color="#0000BB">print_r</font><font  color="#007700">(</font><font  color="#0000BB">$arr1</font><font  color="#007700">);<br  />echo </font><font  color="#DD0000">"\nNatural order string comparison\n"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">usort</font><font  color="#007700">(</font><font  color="#0000BB">$arr2</font><font  color="#007700">, </font><font  color="#DD0000">"strnatcmp"</font><font  color="#007700">);<br  /></font><font  color="#0000BB">print_r</font><font  color="#007700">(</font><font  color="#0000BB">$arr2</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  ></P
></DIV
>
     The code above will generate the following output:
     <DIV  CLASS="informalexample" ><A  NAME="AEN110628" ></A
><P  ></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >Standard string comparison
Array
(
    [0] => img1.png
    [1] => img10.png
    [2] => img12.png
    [3] => img2.png
)

Natural order string comparison
Array
(
    [0] => img1.png
    [1] => img2.png
    [2] => img10.png
    [3] => img12.png
)</PRE
></TD
></TR
></TABLE
><P  ></P
></DIV
>
     For more information see: Martin Pool's <SPAN HREF="#">Natural Order String Comparison</A
>
     page.
    </P
><P  >     Similar to other string comparison functions, this one returns
     < 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
> is less than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>; > 0 if
     <TT  CLASS="parameter" ><I  >str1</I
></TT
> is greater than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>, and 0 if they are equal.
    </P
><P  >     Note that this comparison is case sensitive.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strcasecmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strncmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strncasecmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strnatcasecmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >natsort()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >natcasesort()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strncasecmp</name>
            <signature><![CDATA[int strncasecmp ( string str1, string str2, int len)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110653" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strncasecmp</B
> ( string str1, string str2, int len)<BR  ></BR
><P  >     This function is similar to <SPAN HREF="#"><B  CLASS="function" >strcasecmp()</B
></A
>, with
     the difference that you can specify the (upper limit of the)
     number of characters (<TT  CLASS="parameter" ><I  >len</I
></TT
>) from each
     string to be used in the comparison. </P
><P  > 
     Returns < 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
> is less than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>; > 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
>
     is greater than <TT  CLASS="parameter" ><I  >str2</I
></TT
>, and 0 if they are
     equal.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strcasecmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, and <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strncmp</name>
            <signature><![CDATA[int strncmp ( string str1, string str2, int len)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110686" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strncmp</B
> ( string str1, string str2, int len)<BR  ></BR
><P  >     This function is similar to <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>, with the
     difference that you can specify the (upper limit of the) number
     of characters (<TT  CLASS="parameter" ><I  >len</I
></TT
>) from each string to be
     used in the comparison.</P
><P  >     Returns < 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
> is less than
     <TT  CLASS="parameter" ><I  >str2</I
></TT
>; > 0 if <TT  CLASS="parameter" ><I  >str1</I
></TT
>
     is greater than <TT  CLASS="parameter" ><I  >str2</I
></TT
>, and 0 if they are
     equal.
    </P
><P  >     Note that this comparison is case sensitive.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strncasecmp()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strcasecmp()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strcmp()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strpos</name>
            <signature><![CDATA[int strpos ( string haystack, string needle [, int offset])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110721" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strpos</B
> ( string haystack, string needle [, int offset])<BR  ></BR
><P  >     Returns the numeric position of the first occurrence of
     <TT  CLASS="parameter" ><I  >needle</I
></TT
> in the
     <TT  CLASS="parameter" ><I  >haystack</I
></TT
> string.  Unlike the
     <SPAN HREF="#"><B  CLASS="function" >strrpos()</B
></A
>, this function can take a full
     string as the <TT  CLASS="parameter" ><I  >needle</I
></TT
> parameter and the
     entire string will be used.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not found,
     <B  CLASS="function" >strpos()</B
> will return <SPAN HREF="#"><B  CLASS="type" >boolean</B
></A
> <TT  CLASS="constant" ><B  >FALSE</B
></TT
>.
    </P
><DIV  CLASS="warning" ><P  ></P
><TABLE  CLASS="warning" BORDER="1" WIDTH="100%" ><TR  ><TD  ALIGN="CENTER" ><B  >警告</B
></TD
></TR
><TR  ><TD  ALIGN="LEFT" ><P  >这个函数可能返回 Boolean <TT  CLASS="constant" ><B  >FALSE</B
></TT
>，也可能返回一个与 <TT  CLASS="constant" ><B  >FALSE</B
></TT
> 相等地非 Boolean 值，比如 0 或者 "" 。请参阅 <SPAN HREF="#">Booleans</A
> 的有关章节以获取更多信息。请使用 <SPAN HREF="#">=== 操作符</A
> 来测试该函数的返回值。 </P
></TD
></TR
></TABLE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110752" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strpos()</B
> examples</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$mystring </font><font  color="#007700">= </font><font  color="#DD0000">'abc'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$findme   </font><font  color="#007700">= </font><font  color="#DD0000">'a'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$pos </font><font  color="#007700">= </font><font  color="#0000BB">strpos</font><font  color="#007700">(</font><font  color="#0000BB">$mystring</font><font  color="#007700">, </font><font  color="#0000BB">$findme</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">// Note our use of ===.  Simply == would not work as expected<br  />// because the position of 'a' was the 0th (first) character.<br  /></font><font  color="#007700">if (</font><font  color="#0000BB">$pos </font><font  color="#007700">=== </font><font  color="#0000BB">false</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">"The string '$findme' was not found in the string '$mystring'"</font><font  color="#007700">;<br  />} else {<br  />    echo </font><font  color="#DD0000">"The string '$findme' was found in the string '$mystring'"</font><font  color="#007700">;<br  />    echo </font><font  color="#DD0000">" and exists at position $pos"</font><font  color="#007700">;<br  />}<br  /><br  /></font><font  color="#FF8000">// We can search for the character, ignoring anything before the offset<br  /></font><font  color="#0000BB">$newstring </font><font  color="#007700">= </font><font  color="#DD0000">'abcdef abcdef'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$pos </font><font  color="#007700">= </font><font  color="#0000BB">strpos</font><font  color="#007700">(</font><font  color="#0000BB">$newstring</font><font  color="#007700">, </font><font  color="#DD0000">'a'</font><font  color="#007700">, </font><font  color="#0000BB">1</font><font  color="#007700">); </font><font  color="#FF8000">// $pos = 7, not 0<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not a string, it is converted
     to an integer and applied as the ordinal value of a character.
    </P
><P  >     The optional <TT  CLASS="parameter" ><I  >offset</I
></TT
> parameter allows you
     to specify which character in <TT  CLASS="parameter" ><I  >haystack</I
></TT
> to
     start searching. The position returned is still relative to the
     the beginning of <TT  CLASS="parameter" ><I  >haystack</I
></TT
>.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strrpos()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >stripos()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strripos()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strrchr()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, and 
     <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strrchr</name>
            <signature><![CDATA[string strrchr ( string haystack, char needle)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110774" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >strrchr</B
> ( string haystack, char needle)<BR  ></BR
><P  >     This function returns the portion of
     <TT  CLASS="parameter" ><I  >haystack</I
></TT
> which starts at the last
     occurrence of <TT  CLASS="parameter" ><I  >needle</I
></TT
> and goes until the
     end of <TT  CLASS="parameter" ><I  >haystack</I
></TT
>.
    </P
><P  >     Returns <TT  CLASS="constant" ><B  >FALSE</B
></TT
> if <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not found.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> contains more than one
     character, only the first is used. This behavior is different from that
     of <SPAN HREF="#"><B  CLASS="function" >strchr()</B
></A
>.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not a string, it is converted
     to an integer and applied as the ordinal value of a character.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110797" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strrchr()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#FF8000">// get last directory in $PATH<br  /></font><font  color="#0000BB">$dir </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#0000BB">strrchr</font><font  color="#007700">(</font><font  color="#0000BB">$PATH</font><font  color="#007700">, </font><font  color="#DD0000">":"</font><font  color="#007700">), </font><font  color="#0000BB">1</font><font  color="#007700">);<br  /><br  /></font><font  color="#FF8000">// get everything after last newline<br  /></font><font  color="#0000BB">$text </font><font  color="#007700">= </font><font  color="#DD0000">"Line 1\nLine 2\nLine 3"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$last </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#0000BB">strrchr</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">, </font><font  color="#0000BB">10</font><font  color="#007700">), </font><font  color="#0000BB">1 </font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strchr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, and <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strrev</name>
            <signature><![CDATA[string strrev ( string string)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110810" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >strrev</B
> ( string string)<BR  ></BR
><P  >     Returns <TT  CLASS="parameter" ><I  >string</I
></TT
>, reversed.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110820" ></A
><P  ><B  >例子 1. Reversing a string with <B  CLASS="function" >strrev()</B
></B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">strrev</font><font  color="#007700">(</font><font  color="#DD0000">"Hello world!"</font><font  color="#007700">); </font><font  color="#FF8000">// outputs "!dlrow olleH"<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strripos</name>
            <signature><![CDATA[int strripos ( string haystack, string needle [, int offset])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110828" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strripos</B
> ( string haystack, string needle [, int offset])<BR  ></BR
><P  >     Returns the numeric position of the last occurrence of
     <TT  CLASS="parameter" ><I  >needle</I
></TT
> in the
     <TT  CLASS="parameter" ><I  >haystack</I
></TT
> string.  Unlike
     <SPAN HREF="#"><B  CLASS="function" >strrpos()</B
></A
>, <B  CLASS="function" >strripos()</B
> is
     case-insensitive.  Also note that string positions start at 0, and not
     1. 
    </P
><P  >     Note that the <TT  CLASS="parameter" ><I  >needle</I
></TT
> may be a string of one or
     more characters.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not found, <TT  CLASS="constant" ><B  >FALSE</B
></TT
> is returned.
    </P
><DIV  CLASS="warning" ><P  ></P
><TABLE  CLASS="warning" BORDER="1" WIDTH="100%" ><TR  ><TD  ALIGN="CENTER" ><B  >警告</B
></TD
></TR
><TR  ><TD  ALIGN="LEFT" ><P  >这个函数可能返回 Boolean <TT  CLASS="constant" ><B  >FALSE</B
></TT
>，也可能返回一个与 <TT  CLASS="constant" ><B  >FALSE</B
></TT
> 相等地非 Boolean 值，比如 0 或者 "" 。请参阅 <SPAN HREF="#">Booleans</A
> 的有关章节以获取更多信息。请使用 <SPAN HREF="#">=== 操作符</A
> 来测试该函数的返回值。 </P
></TD
></TR
></TABLE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110859" ></A
><P  ><B  >例子 1. A simple <B  CLASS="function" >strripos()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$haystack </font><font  color="#007700">= </font><font  color="#DD0000">'ababcd'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$needle   </font><font  color="#007700">= </font><font  color="#DD0000">'aB'</font><font  color="#007700">;<br  /><br  /></font><font  color="#0000BB">$pos      </font><font  color="#007700">= </font><font  color="#0000BB">strripos</font><font  color="#007700">(</font><font  color="#0000BB">$haystack</font><font  color="#007700">, </font><font  color="#0000BB">$needle</font><font  color="#007700">);<br  /><br  />if (</font><font  color="#0000BB">$pos </font><font  color="#007700">=== </font><font  color="#0000BB">false</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">"Sorry, we did not find ($needle) in ($haystack)"</font><font  color="#007700">;<br  />} else {<br  />    echo </font><font  color="#DD0000">"Congratulations!\n"</font><font  color="#007700">;<br  />    echo </font><font  color="#DD0000">"We found the last ($needle) in ($haystack) at position ($pos)"</font><font  color="#007700">;<br  />}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >       Outputs:
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >Congratulations!
   We found the last (aB) in (ababcd) at position (2)</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     <TT  CLASS="parameter" ><I  >offset</I
></TT
> may be specified to begin searching an 
     arbitrary number of characters into the string.  Negative values will 
     stop searching at an arbitrary point prior to the end of the string.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strrpos()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strrchr()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >stripos()</B
></A
> and 
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strrpos</name>
            <signature><![CDATA[int strrpos ( string haystack, string needle [, int offset])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110877" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strrpos</B
> ( string haystack, string needle [, int offset])<BR  ></BR
><P  >     Returns the numeric position of the last occurrence of
     <TT  CLASS="parameter" ><I  >needle</I
></TT
> in the
     <TT  CLASS="parameter" ><I  >haystack</I
></TT
> string.  Note that the needle in
     this case can only be a single character in PHP 4.  If a string is passed
     as the needle, then only the first character of that string will
     be used.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not found, returns <TT  CLASS="constant" ><B  >FALSE</B
></TT
>.
    </P
><P  >     It is easy to mistake the return values for "character found at
     position 0" and "character not found".  Here's how to detect
     the difference:
     </P><DIV  CLASS="informalexample" ><A  NAME="AEN110898" ></A
><P  ></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  /></font><font  color="#FF8000">// in PHP 4.0b3 and newer:<br  /></font><font  color="#0000BB">$pos </font><font  color="#007700">= </font><font  color="#0000BB">strrpos</font><font  color="#007700">(</font><font  color="#0000BB">$mystring</font><font  color="#007700">, </font><font  color="#DD0000">"b"</font><font  color="#007700">);<br  />if (</font><font  color="#0000BB">$pos </font><font  color="#007700">=== </font><font  color="#0000BB">false</font><font  color="#007700">) { </font><font  color="#FF8000">// note: three equal signs<br  />    // not found...<br  /></font><font  color="#007700">}<br  /><br  /></font><font  color="#FF8000">// in versions older than 4.0b3:<br  /></font><font  color="#0000BB">$pos </font><font  color="#007700">= </font><font  color="#0000BB">strrpos</font><font  color="#007700">(</font><font  color="#0000BB">$mystring</font><font  color="#007700">, </font><font  color="#DD0000">"b"</font><font  color="#007700">);<br  />if (</font><font  color="#0000BB">is_bool</font><font  color="#007700">(</font><font  color="#0000BB">$pos</font><font  color="#007700">) && !</font><font  color="#0000BB">$pos</font><font  color="#007700">) {<br  />    </font><font  color="#FF8000">// not found...<br  /></font><font  color="#007700">}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  ></P
></DIV
>
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not a string, it is converted
     to an integer and applied as the ordinal value of a character.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      As of <TT  CLASS="literal" >PHP 5.0.0</TT
> <TT  CLASS="parameter" ><I  >offset</I
></TT
> may
      be specified to begin searching an arbitrary number of characters into
      the string.  Negative values will stop searching at an arbitrary point
      prior to the end of the string.
     </P
></BLOCKQUOTE
></DIV
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The <TT  CLASS="parameter" ><I  >needle</I
></TT
> may be a string of more than one
      character as of <TT  CLASS="literal" >PHP 5.0.0</TT
>.
     </P
></BLOCKQUOTE
></DIV
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strpos()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strripos()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strrchr()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strspn</name>
            <signature><![CDATA[int strspn ( string str1, string str2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110921" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >strspn</B
> ( string str1, string str2)<BR  ></BR
><P  >     Returns the length of the initial segment of
     <TT  CLASS="parameter" ><I  >str1</I
></TT
> which consists entirely of characters
     in <TT  CLASS="parameter" ><I  >str2</I
></TT
>.
    </P
><P  >     The line of code:
     </P><DIV  CLASS="informalexample" ><A  NAME="AEN110936" ></A
><P  ></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$var </font><font  color="#007700">= </font><font  color="#0000BB">strspn</font><font  color="#007700">(</font><font  color="#DD0000">"42 is the answer, what is the question ..."</font><font  color="#007700">, </font><font  color="#DD0000">"1234567890"</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  ></P
></DIV
>
     will assign 2 to <TT  CLASS="varname" >$var</TT
>, because the string "42" will
     be the longest segment containing characters from "1234567890".
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strcspn()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strstr</name>
            <signature><![CDATA[string strstr ( string haystack, string needle)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110945" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >strstr</B
> ( string haystack, string needle)<BR  ></BR
><P  >     Returns part of <TT  CLASS="parameter" ><I  >haystack</I
></TT
> string from the
     first occurrence of <TT  CLASS="parameter" ><I  >needle</I
></TT
> to the end of
     <TT  CLASS="parameter" ><I  >haystack</I
></TT
>.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not found, returns <TT  CLASS="constant" ><B  >FALSE</B
></TT
>.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >needle</I
></TT
> is not a string, it is converted
     to an integer and applied as the ordinal value of a character.
    </P
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      This function is case-sensitive. For case-insensitive searches, use
      <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>.
     </P
></BLOCKQUOTE
></DIV
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN110969" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strstr()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$email </font><font  color="#007700">= </font><font  color="#DD0000">'user@example.com'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$domain </font><font  color="#007700">= </font><font  color="#0000BB">strstr</font><font  color="#007700">(</font><font  color="#0000BB">$email</font><font  color="#007700">, </font><font  color="#DD0000">'@'</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$domain</font><font  color="#007700">; </font><font  color="#FF8000">// prints @example.com<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
> 
    </P
><P  >     </P><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
       If you only want to determine if a particular <TT  CLASS="parameter" ><I  >needle</I
></TT
>
       occurs within <TT  CLASS="parameter" ><I  >haystack</I
></TT
>, use the faster and less memory
       intensive function <SPAN HREF="#"><B  CLASS="function" >strpos()</B
></A
> instead.
      </P
></BLOCKQUOTE
></DIV
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >preg_match()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strchr()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >stristr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strpos()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strrchr()</B
></A
>, and
     <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strtok</name>
            <signature><![CDATA[string strtok ( string arg1, string arg2)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN110991" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >strtok</B
> ( string arg1, string arg2)<BR  ></BR
><P  >     <B  CLASS="function" >strtok()</B
> splits a string (<TT  CLASS="parameter" ><I  >arg1</I
></TT
>)
     into smaller strings (tokens), with each token being delimited by any 
     character from <TT  CLASS="parameter" ><I  >arg2</I
></TT
>.
     That is, if you have a string like "This is an example string" you
     could tokenize this string into its individual words by using the
     space character as the token.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111006" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strtok()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$string </font><font  color="#007700">= </font><font  color="#DD0000">"This is\tan example\nstring"</font><font  color="#007700">;<br  /></font><font  color="#FF8000">/* Use tab and newline as tokenizing characters as well  */<br  /></font><font  color="#0000BB">$tok </font><font  color="#007700">= </font><font  color="#0000BB">strtok</font><font  color="#007700">(</font><font  color="#0000BB">$string</font><font  color="#007700">, </font><font  color="#DD0000">" \n\t"</font><font  color="#007700">);<br  />while (</font><font  color="#0000BB">$tok</font><font  color="#007700">) {<br  />    echo </font><font  color="#DD0000">"Word=$tok<br />"</font><font  color="#007700">;<br  />    </font><font  color="#0000BB">$tok </font><font  color="#007700">= </font><font  color="#0000BB">strtok</font><font  color="#007700">(</font><font  color="#DD0000">" \n\t"</font><font  color="#007700">);<br  />}<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     Note that only the first call to strtok uses the string argument.
     Every subsequent call to strtok only needs the token to use, as
     it keeps track of where it is in the current string.  To start
     over, or to tokenize a new string you simply call strtok with the
     string argument again to initialize it.  Note that you may put
     multiple tokens in the token parameter.  The string will be
     tokenized when any one of the characters in the argument are
     found.
    </P
><P  >     The behavior when an empty part was found changed with PHP 4.1.0. The old
     behavior returned an empty string, while the new, correct, behavior
     simply skips the part of the string:
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111012" ></A
><P  ><B  >例子 2. Old <B  CLASS="function" >strtok()</B
> behavior</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$first_token  </font><font  color="#007700">= </font><font  color="#0000BB">strtok</font><font  color="#007700">(</font><font  color="#DD0000">'/something'</font><font  color="#007700">, </font><font  color="#DD0000">'/'</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$second_token </font><font  color="#007700">= </font><font  color="#0000BB">strtok</font><font  color="#007700">(</font><font  color="#DD0000">'/'</font><font  color="#007700">);<br  /></font><font  color="#0000BB">var_dump</font><font  color="#007700">(</font><font  color="#0000BB">$first_token</font><font  color="#007700">, </font><font  color="#0000BB">$second_token</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >       Output:
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >string(0) ""
    string(9) "something"</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111018" ></A
><P  ><B  >例子 3. New <B  CLASS="function" >strtok()</B
> behavior</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$first_token  </font><font  color="#007700">= </font><font  color="#0000BB">strtok</font><font  color="#007700">(</font><font  color="#DD0000">'/something'</font><font  color="#007700">, </font><font  color="#DD0000">'/'</font><font  color="#007700">);<br  /></font><font  color="#0000BB">$second_token </font><font  color="#007700">= </font><font  color="#0000BB">strtok</font><font  color="#007700">(</font><font  color="#DD0000">'/'</font><font  color="#007700">);<br  /></font><font  color="#0000BB">var_dump</font><font  color="#007700">(</font><font  color="#0000BB">$first_token</font><font  color="#007700">, </font><font  color="#0000BB">$second_token</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >       Output:
      </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >string(9) "something"
    bool(false)</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     Also be careful that your tokens may be equal to "0". This
     evaluates to <TT  CLASS="constant" ><B  >FALSE</B
></TT
> in conditional expressions.
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >split()</B
></A
> and
     <SPAN HREF="#"><B  CLASS="function" >explode()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strtolower</name>
            <signature><![CDATA[string strtolower ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111033" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >strtolower</B
> ( string str)<BR  ></BR
><P  >     Returns <TT  CLASS="parameter" ><I  >string</I
></TT
> with all alphabetic
     characters converted to lowercase.
    </P
><P  >     Note that 'alphabetic' is determined by the current locale. This
     means that in i.e. the default "C" locale, characters such as
     umlaut-A (Ä) will not be converted.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111044" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strtolower()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"Mary Had A Little Lamb and She LOVED It So"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$str </font><font  color="#007700">= </font><font  color="#0000BB">strtolower</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$str</font><font  color="#007700">; </font><font  color="#FF8000">// Prints mary had a little lamb and she loved it so<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strtoupper()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >ucfirst()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >ucwords()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >mb_strtolower()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strtoupper</name>
            <signature><![CDATA[string strtoupper ( string string)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111057" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >strtoupper</B
> ( string string)<BR  ></BR
><P  >     Returns <TT  CLASS="parameter" ><I  >string</I
></TT
> with all alphabetic
     characters converted to uppercase.
    </P
><P  >     Note that 'alphabetic' is determined by the current locale. For
     instance, in the default "C" locale characters such as umlaut-a
     (洎 will not be converted.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111068" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strtoupper()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$str </font><font  color="#007700">= </font><font  color="#DD0000">"Mary Had A Little Lamb and She LOVED It So"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$str </font><font  color="#007700">= </font><font  color="#0000BB">strtoupper</font><font  color="#007700">(</font><font  color="#0000BB">$str</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">$str</font><font  color="#007700">; </font><font  color="#FF8000">// Prints MARY HAD A LITTLE LAMB AND SHE LOVED IT SO<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strtolower()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >ucfirst()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >ucwords()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >mb_strtoupper()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>strtr</name>
            <signature><![CDATA[string strtr ( string str, string from, string to)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111081" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >strtr</B
> ( string str, string from, string to)<BR  ></BR
>string <B  CLASS="methodname" >strtr</B
> ( string str, array replace_pairs)<BR  ></BR
><P  >     This function returns a copy of <TT  CLASS="parameter" ><I  >str</I
></TT
>,
     translating all occurrences of each character in
     <TT  CLASS="parameter" ><I  >from</I
></TT
> to the corresponding character in
     <TT  CLASS="parameter" ><I  >to</I
></TT
> and returning the result.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >from</I
></TT
> and <TT  CLASS="parameter" ><I  >to</I
></TT
> are
     different lengths, the extra characters in the longer of the two
     are ignored.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111111" ></A
><P  ><B  >例子 1. <B  CLASS="function" >strtr()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$addr </font><font  color="#007700">= </font><font  color="#0000BB">strtr</font><font  color="#007700">(</font><font  color="#0000BB">$addr</font><font  color="#007700">, </font><font  color="#DD0000">"溴觫, "</font><font  color="#0000BB">aao</font><font  color="#DD0000">");<br  />?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     <B  CLASS="function" >strtr()</B
> may be called with only two
     arguments. If called with two arguments it behaves in a new way:
     <TT  CLASS="parameter" ><I  >from</I
></TT
> then has to be an array that contains
     string -> string pairs that will be replaced in the source
     string. <B  CLASS="function" >strtr()</B
> will always look for the
     longest possible match first and will *NOT* try to replace stuff
     that it has already worked on.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111119" ></A
><P  ><B  >例子 2. <B  CLASS="function" >strtr()</B
> example with two arguments</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$trans </font><font  color="#007700">= array(</font><font  color="#DD0000">"hello" </font><font  color="#007700">=> </font><font  color="#DD0000">"hi"</font><font  color="#007700">, </font><font  color="#DD0000">"hi" </font><font  color="#007700">=> </font><font  color="#DD0000">"hello"</font><font  color="#007700">);<br  />echo </font><font  color="#0000BB">strtr</font><font  color="#007700">(</font><font  color="#DD0000">"hi all, I said hello"</font><font  color="#007700">, </font><font  color="#0000BB">$trans</font><font  color="#007700">);<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >     This will show: 
    </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >hello all, I said hi</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      This optional <TT  CLASS="parameter" ><I  >to</I
></TT
> and 
      <TT  CLASS="parameter" ><I  >from</I
></TT
> parameters were added in PHP 4.0.0
     </P
></BLOCKQUOTE
></DIV
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ereg_replace()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>substr_compare</name>
            <signature><![CDATA[int substr_compare ( string main_str, string str, int offset [, int length [, bool case_sensitivity]])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111135" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >substr_compare</B
> ( string main_str, string str, int offset [, int length [, bool case_sensitivity]])<BR  ></BR
><DIV  CLASS="warning" ><P  ></P
><TABLE  CLASS="warning" BORDER="1" WIDTH="100%" ><TR  ><TD  ALIGN="CENTER" ><B  >警告</B
></TD
></TR
><TR  ><TD  ALIGN="LEFT" ><P  >该函数目前尚无参考文档；仅参数列表可用。
</P
></TD
></TR
></TABLE
></DIV
></DIV
>]]></description>
        </method>
        <method>
            <name>substr_count</name>
            <signature><![CDATA[int substr_count ( string haystack, string needle)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111161" ></A
><H2  >Description</H2
>int <B  CLASS="methodname" >substr_count</B
> ( string haystack, string needle)<BR  ></BR
><P  >     <B  CLASS="function" >substr_count()</B
> returns the number of times the
     <TT  CLASS="parameter" ><I  >needle</I
></TT
> substring occurs in the
     <TT  CLASS="parameter" ><I  >haystack</I
></TT
> string.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111177" ></A
><P  ><B  >例子 1. <B  CLASS="function" >substr_count()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">substr_count</font><font  color="#007700">(</font><font  color="#DD0000">"This is a test"</font><font  color="#007700">, </font><font  color="#DD0000">"is"</font><font  color="#007700">); </font><font  color="#FF8000">// prints out 2<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >count_chars()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strpos()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >strstr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>substr_replace</name>
            <signature><![CDATA[string substr_replace ( string string, string replacement, int start [, int length])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111190" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >substr_replace</B
> ( string string, string replacement, int start [, int length])<BR  ></BR
><P  >     <B  CLASS="function" >substr_replace()</B
> replaces a copy of
     <TT  CLASS="parameter" ><I  >string</I
></TT
> delimited by the
     <TT  CLASS="parameter" ><I  >start</I
></TT
> and (optionally)
     <TT  CLASS="parameter" ><I  >length</I
></TT
> parameters with the string given in
     <TT  CLASS="parameter" ><I  >replacement</I
></TT
>. The result is returned.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >start</I
></TT
> is positive, the replacing will
     begin at the <TT  CLASS="parameter" ><I  >start</I
></TT
>'th offset into
     <TT  CLASS="parameter" ><I  >string</I
></TT
>.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >start</I
></TT
> is negative, the replacing will
     begin at the <TT  CLASS="parameter" ><I  >start</I
></TT
>'th character from the
     end of <TT  CLASS="parameter" ><I  >string</I
></TT
>.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >length</I
></TT
> is given and is positive, it
     represents the length of the portion of
     <TT  CLASS="parameter" ><I  >string</I
></TT
> which is to be replaced. If it is
     negative, it represents the number of characters from the end of
     <TT  CLASS="parameter" ><I  >string</I
></TT
> at which to stop replacing. If it
     is not given, then it will default to strlen(
     <TT  CLASS="parameter" ><I  >string</I
></TT
> ); i.e. end the replacing at the
     end of <TT  CLASS="parameter" ><I  >string</I
></TT
>.
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111228" ></A
><P  ><B  >例子 1. <B  CLASS="function" >substr_replace()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$var </font><font  color="#007700">= </font><font  color="#DD0000">'ABCDEFGH:/MNRPQR/'</font><font  color="#007700">;<br  />echo </font><font  color="#DD0000">"Original: $var<hr />\n"</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">/* These two examples replace all of $var with 'bob'. */<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">substr_replace</font><font  color="#007700">(</font><font  color="#0000BB">$var</font><font  color="#007700">, </font><font  color="#DD0000">'bob'</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">) . </font><font  color="#DD0000">"<br />\n"</font><font  color="#007700">;<br  />echo </font><font  color="#0000BB">substr_replace</font><font  color="#007700">(</font><font  color="#0000BB">$var</font><font  color="#007700">, </font><font  color="#DD0000">'bob'</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">strlen</font><font  color="#007700">(</font><font  color="#0000BB">$var</font><font  color="#007700">)) . </font><font  color="#DD0000">"<br />\n"</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">/* Insert 'bob' right at the beginning of $var. */<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">substr_replace</font><font  color="#007700">(</font><font  color="#0000BB">$var</font><font  color="#007700">, </font><font  color="#DD0000">'bob'</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">) . </font><font  color="#DD0000">"<br />\n"</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">/* These next two replace 'MNRPQR' in $var with 'bob'. */<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">substr_replace</font><font  color="#007700">(</font><font  color="#0000BB">$var</font><font  color="#007700">, </font><font  color="#DD0000">'bob'</font><font  color="#007700">, </font><font  color="#0000BB">10</font><font  color="#007700">, -</font><font  color="#0000BB">1</font><font  color="#007700">) . </font><font  color="#DD0000">"<br />\n"</font><font  color="#007700">;<br  />echo </font><font  color="#0000BB">substr_replace</font><font  color="#007700">(</font><font  color="#0000BB">$var</font><font  color="#007700">, </font><font  color="#DD0000">'bob'</font><font  color="#007700">, -</font><font  color="#0000BB">7</font><font  color="#007700">, -</font><font  color="#0000BB">1</font><font  color="#007700">) . </font><font  color="#DD0000">"<br />\n"</font><font  color="#007700">;<br  /><br  /></font><font  color="#FF8000">/* Delete 'MNRPQR' from $var. */<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">substr_replace</font><font  color="#007700">(</font><font  color="#0000BB">$var</font><font  color="#007700">, </font><font  color="#DD0000">''</font><font  color="#007700">, </font><font  color="#0000BB">10</font><font  color="#007700">, -</font><font  color="#0000BB">1</font><font  color="#007700">) . </font><font  color="#DD0000">"<br />\n"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >str_replace()</B
></A
> and
     <SPAN HREF="#"><B  CLASS="function" >substr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>substr</name>
            <signature><![CDATA[string substr ( string string, int start [, int length])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111239" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >substr</B
> ( string string, int start [, int length])<BR  ></BR
><P  >     <B  CLASS="function" >substr()</B
> returns the portion of <TT  CLASS="parameter" ><I  >string</I
></TT
>
     specified by the <TT  CLASS="parameter" ><I  >start</I
></TT
> and
     <TT  CLASS="parameter" ><I  >length</I
></TT
> parameters.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >start</I
></TT
> is non-negative, the returned string
     will start at the <TT  CLASS="parameter" ><I  >start</I
></TT
>'th position in
     <TT  CLASS="parameter" ><I  >string</I
></TT
>, counting from zero. For instance,
     in the string '<TT  CLASS="literal" >abcdef</TT
>', the character at
     position <TT  CLASS="literal" >0</TT
> is '<TT  CLASS="literal" >a</TT
>', the
     character at position <TT  CLASS="literal" >2</TT
> is
     '<TT  CLASS="literal" >c</TT
>', and so forth.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111267" ></A
><P  ><B  >例子 1. Basic <B  CLASS="function" >substr()</B
> usage</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, </font><font  color="#0000BB">1</font><font  color="#007700">);    </font><font  color="#FF8000">// returns "bcdef"<br  /></font><font  color="#0000BB">$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, </font><font  color="#0000BB">1</font><font  color="#007700">, </font><font  color="#0000BB">3</font><font  color="#007700">); </font><font  color="#FF8000">// returns "bcd"<br  /></font><font  color="#0000BB">$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">4</font><font  color="#007700">); </font><font  color="#FF8000">// returns "abcd"<br  /></font><font  color="#0000BB">$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, </font><font  color="#0000BB">8</font><font  color="#007700">); </font><font  color="#FF8000">// returns "abcdef"<br  /><br  />// Accessing via curly braces is another option<br  /></font><font  color="#0000BB">$string </font><font  color="#007700">= </font><font  color="#DD0000">'abcdef'</font><font  color="#007700">;<br  />echo </font><font  color="#0000BB">$string</font><font  color="#007700">{</font><font  color="#0000BB">0</font><font  color="#007700">};                </font><font  color="#FF8000">// returns a<br  /></font><font  color="#007700">echo </font><font  color="#0000BB">$string</font><font  color="#007700">{</font><font  color="#0000BB">3</font><font  color="#007700">};                </font><font  color="#FF8000">// returns d<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     If <TT  CLASS="parameter" ><I  >start</I
></TT
> is negative, the returned string
     will start at the <TT  CLASS="parameter" ><I  >start</I
></TT
>'th character
     from the end of <TT  CLASS="parameter" ><I  >string</I
></TT
>.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111275" ></A
><P  ><B  >例子 2. Using a negative <TT  CLASS="parameter" ><I  >start</I
></TT
></B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, -</font><font  color="#0000BB">1</font><font  color="#007700">);    </font><font  color="#FF8000">// returns "f"<br  /></font><font  color="#0000BB">$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, -</font><font  color="#0000BB">2</font><font  color="#007700">);    </font><font  color="#FF8000">// returns "ef"<br  /></font><font  color="#0000BB">$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, -</font><font  color="#0000BB">3</font><font  color="#007700">, </font><font  color="#0000BB">1</font><font  color="#007700">); </font><font  color="#FF8000">// returns "d"<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     If <TT  CLASS="parameter" ><I  >length</I
></TT
> is given and is positive, the string
     returned will contain at most <TT  CLASS="parameter" ><I  >length</I
></TT
> characters
     beginning from <TT  CLASS="parameter" ><I  >start</I
></TT
> (depending on the length of
     <TT  CLASS="parameter" ><I  >string</I
></TT
>). If <TT  CLASS="parameter" ><I  >string</I
></TT
> is less
     than <TT  CLASS="parameter" ><I  >start</I
></TT
> characters long, <TT  CLASS="constant" ><B  >FALSE</B
></TT
> will be
     returned.
    </P
><P  >     If <TT  CLASS="parameter" ><I  >length</I
></TT
> is given and is negative, then that many
     characters will be omitted from the end of <TT  CLASS="parameter" ><I  >string</I
></TT
>
     (after the start position has been calculated when a
     <TT  CLASS="parameter" ><I  >start</I
></TT
> is negative).  If
     <TT  CLASS="parameter" ><I  >start</I
></TT
> denotes a position beyond this truncation,
     an empty string will be returned.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111292" ></A
><P  ><B  >例子 3. Using a negative <TT  CLASS="parameter" ><I  >length</I
></TT
></B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, </font><font  color="#0000BB">0</font><font  color="#007700">, -</font><font  color="#0000BB">1</font><font  color="#007700">);  </font><font  color="#FF8000">// returns "abcde"<br  /></font><font  color="#0000BB">$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, </font><font  color="#0000BB">2</font><font  color="#007700">, -</font><font  color="#0000BB">1</font><font  color="#007700">);  </font><font  color="#FF8000">// returns "cde"<br  /></font><font  color="#0000BB">$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, </font><font  color="#0000BB">4</font><font  color="#007700">, -</font><font  color="#0000BB">4</font><font  color="#007700">);  </font><font  color="#FF8000">// returns ""<br  /></font><font  color="#0000BB">$rest </font><font  color="#007700">= </font><font  color="#0000BB">substr</font><font  color="#007700">(</font><font  color="#DD0000">"abcdef"</font><font  color="#007700">, -</font><font  color="#0000BB">3</font><font  color="#007700">, -</font><font  color="#0000BB">1</font><font  color="#007700">); </font><font  color="#FF8000">// returns "de"<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strrchr()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >substr_replace()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >ereg()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >trim()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >mb_substr()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>trim</name>
            <signature><![CDATA[string trim ( string str [, string charlist])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111306" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >trim</B
> ( string str [, string charlist])<BR  ></BR
><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
      The optional <TT  CLASS="parameter" ><I  >charlist</I
></TT
> parameter was 
      added in PHP 4.1.0
     </P
></BLOCKQUOTE
></DIV
><P  >     This function returns a string with whitespace stripped from the
     beginning and end of <TT  CLASS="parameter" ><I  >str</I
></TT
>.
     Without the second parameter,
     <B  CLASS="function" >trim()</B
> will strip these characters:
     
     </P><P  ></P
><UL  ><LI  ><P  >        " " (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >32</TT
> 
        (<TT  CLASS="literal" >0x20</TT
>)), an ordinary space.
       </P
></LI
><LI  ><P  >        "\t" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >9</TT
> 
        (<TT  CLASS="literal" >0x09</TT
>)), a tab.
       </P
></LI
><LI  ><P  >        "\n" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >10</TT
> 
        (<TT  CLASS="literal" >0x0A</TT
>)), a new line (line feed).
       </P
></LI
><LI  ><P  >        "\r" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >13</TT
> 
        (<TT  CLASS="literal" >0x0D</TT
>)), a carriage return.
       </P
></LI
><LI  ><P  >        "\0" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >0</TT
> 
        (<TT  CLASS="literal" >0x00</TT
>)), the <TT  CLASS="literal" >NUL</TT
>-byte.
       </P
></LI
><LI  ><P  > 
        "\x0B" (<SPAN  CLASS="acronym" >ASCII</SPAN
> <TT  CLASS="literal" >11</TT
> 
        (<TT  CLASS="literal" >0x0B</TT
>)), a vertical tab.
       </P
></LI
></UL
>
    </P
><P  >     You can also specify the characters you want to strip, by means
     of the <TT  CLASS="parameter" ><I  >charlist</I
></TT
> parameter.
     Simply list all characters that you want to be stripped. With
     <TT  CLASS="literal" >..</TT
> you can specify a range of characters.
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111358" ></A
><P  ><B  >例子 1. Usage example of <B  CLASS="function" >trim()</B
></B
></P
><P  >      <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  /><br  />$text </font><font  color="#007700">= </font><font  color="#DD0000">"\t\tThese are a few words :) ...  "</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$trimmed </font><font  color="#007700">= </font><font  color="#0000BB">trim</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// $trimmed = "These are a few words :) ..."<br  /></font><font  color="#0000BB">$trimmed </font><font  color="#007700">= </font><font  color="#0000BB">trim</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">, </font><font  color="#DD0000">" \t."</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// $trimmed = "These are a few words :)"<br  /></font><font  color="#0000BB">$clean </font><font  color="#007700">= </font><font  color="#0000BB">trim</font><font  color="#007700">(</font><font  color="#0000BB">$binary</font><font  color="#007700">, </font><font  color="#DD0000">"\x00..\x1F"</font><font  color="#007700">);<br  /></font><font  color="#FF8000">// trim the ASCII control characters at the beginning and end of $binary<br  />// (from 0 to 31 inclusive)<br  /><br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
>
     </P
></DIV
></TD
></TR
></TABLE
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >ltrim()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >rtrim()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>ucfirst</name>
            <signature><![CDATA[string ucfirst ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111370" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >ucfirst</B
> ( string str)<BR  ></BR
><P  >     Returns a string with the first character of
     <TT  CLASS="parameter" ><I  >str</I
></TT
> capitalized, if that character is
     alphabetic.
    </P
><P  >     Note that 'alphabetic' is determined by the current locale. For
     instance, in the default "C" locale characters such as umlaut-a
     (ä) will not be converted.
     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111381" ></A
><P  ><B  >例子 1. <B  CLASS="function" >ucfirst()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$foo </font><font  color="#007700">= </font><font  color="#DD0000">'hello world!'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$foo </font><font  color="#007700">= </font><font  color="#0000BB">ucfirst</font><font  color="#007700">(</font><font  color="#0000BB">$foo</font><font  color="#007700">);             </font><font  color="#FF8000">// Hello world!<br  /><br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= </font><font  color="#DD0000">'HELLO WORLD!'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= </font><font  color="#0000BB">ucfirst</font><font  color="#007700">(</font><font  color="#0000BB">$bar</font><font  color="#007700">);             </font><font  color="#FF8000">// HELLO WORLD!<br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= </font><font  color="#0000BB">ucfirst</font><font  color="#007700">(</font><font  color="#0000BB">strtolower</font><font  color="#007700">(</font><font  color="#0000BB">$bar</font><font  color="#007700">)); </font><font  color="#FF8000">// Hello world!<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strtolower()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >strtoupper()</B
></A
>,
     and <SPAN HREF="#"><B  CLASS="function" >ucwords()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>ucwords</name>
            <signature><![CDATA[string ucwords ( string str)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111393" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >ucwords</B
> ( string str)<BR  ></BR
><P  >     Returns a string with the first character of each word in
     <TT  CLASS="parameter" ><I  >str</I
></TT
> capitalized, if that character is
     alphabetic.
    </P
><P  >     The definition of a word is any string of characters
     that is immediately after a whitespace (These  are:
     space, form-feed, newline, carriage return, horizontal tab,
     and vertical tab).
    </P
><P  >     <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111405" ></A
><P  ><B  >例子 1. <B  CLASS="function" >ucwords()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$foo </font><font  color="#007700">= </font><font  color="#DD0000">'hello world!'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$foo </font><font  color="#007700">= </font><font  color="#0000BB">ucwords</font><font  color="#007700">(</font><font  color="#0000BB">$foo</font><font  color="#007700">);             </font><font  color="#FF8000">// Hello World! <br  /><br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= </font><font  color="#DD0000">'HELLO WORLD!'</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= </font><font  color="#0000BB">ucwords</font><font  color="#007700">(</font><font  color="#0000BB">$bar</font><font  color="#007700">);             </font><font  color="#FF8000">// HELLO WORLD!<br  /></font><font  color="#0000BB">$bar </font><font  color="#007700">= </font><font  color="#0000BB">ucwords</font><font  color="#007700">(</font><font  color="#0000BB">strtolower</font><font  color="#007700">(</font><font  color="#0000BB">$bar</font><font  color="#007700">)); </font><font  color="#FF8000">// Hello World!<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >strtoupper()</B
></A
>,
     <SPAN HREF="#"><B  CLASS="function" >strtolower()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >ucfirst()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>vprintf</name>
            <signature><![CDATA[void vprintf ( string format, array args)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111417" ></A
><H2  >Description</H2
>void <B  CLASS="methodname" >vprintf</B
> ( string format, array args)<BR  ></BR
><P  >     Display array values as a formatted string according to 
     <TT  CLASS="parameter" ><I  >format</I
></TT
> (which is described in the documentation 
     for <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>).
    </P
><P  >     Operates as <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
> but accepts an array of
     arguments, rather than a variable number of arguments.  
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >printf()</B
></A
>, <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>, 
     <SPAN HREF="#"><B  CLASS="function" >vsprintf()</B
></A
> 
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>vsprintf</name>
            <signature><![CDATA[string vsprintf ( string format, array args)]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111441" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >vsprintf</B
> ( string format, array args)<BR  ></BR
><P  >     Return array values as a formatted string according to 
     <TT  CLASS="parameter" ><I  >format</I
></TT
> (which is described in the documentation 
     for <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
>).
    </P
><P  >     Operates as <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
> but accepts an array of
     arguments, rather than a variable number of arguments.  
    </P
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >sprintf()</B
></A
> and <SPAN HREF="#"><B  CLASS="function" >vprintf()</B
></A
> 
    </P
></DIV
>]]></description>
        </method>
        <method>
            <name>wordwrap</name>
            <signature><![CDATA[string wordwrap ( string str [, int width [, string break [, boolean cut]]])]]></signature>
            <description><![CDATA[<DIV  CLASS="refsect1" ><A  NAME="AEN111464" ></A
><H2  >Description</H2
>string <B  CLASS="methodname" >wordwrap</B
> ( string str [, int width [, string break [, boolean cut]]])<BR  ></BR
><P  >     Returns a string with <TT  CLASS="parameter" ><I  >str</I
></TT
> wrapped
     at the column number specified by the optional
     <TT  CLASS="parameter" ><I  >width</I
></TT
> parameter.  The line is broken
     using the (optional) <TT  CLASS="parameter" ><I  >break</I
></TT
> parameter.
    </P
><P  >     <B  CLASS="function" >wordwrap()</B
> will automatically wrap at column
     75 and break using '<TT  CLASS="literal" >\n</TT
>' (newline) if 
     <TT  CLASS="parameter" ><I  >width</I
></TT
> or <TT  CLASS="parameter" ><I  >break</I
></TT
> 
     are not given.
    </P
><P  >     If the <TT  CLASS="parameter" ><I  >cut</I
></TT
> is set to 1, the string is
     always wrapped at the specified width. So if you have a word
     that is larger than the given width, it is broken apart.
     (See second example).
     </P><DIV  CLASS="note" ><BLOCKQUOTE  CLASS="note" ><P  ><B  >注: </B
>
       The optional <TT  CLASS="parameter" ><I  >cut</I
></TT
> parameter was added in PHP
       4.0.3
      </P
></BLOCKQUOTE
></DIV
>
    </P
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111495" ></A
><P  ><B  >例子 1. <B  CLASS="function" >wordwrap()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$text </font><font  color="#007700">= </font><font  color="#DD0000">"The quick brown fox jumped over the lazy dog."</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$newtext </font><font  color="#007700">= </font><font  color="#0000BB">wordwrap</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">, </font><font  color="#0000BB">20</font><font  color="#007700">, </font><font  color="#DD0000">"<br />"</font><font  color="#007700">);<br  /><br  />echo </font><font  color="#DD0000">"$newtext\n"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >     This example would display:
    </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >The quick brown fox
jumped over the 
lazy dog.</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE" ><TR  ><TD  ><DIV  CLASS="example" ><A  NAME="AEN111501" ></A
><P  ><B  >例子 2. <B  CLASS="function" >wordwrap()</B
> example</B
></P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><code ><font  color="#000000">
<font  color="#0000BB"><?php<br  />$text </font><font  color="#007700">= </font><font  color="#DD0000">"A very long woooooooooooord."</font><font  color="#007700">;<br  /></font><font  color="#0000BB">$newtext </font><font  color="#007700">= </font><font  color="#0000BB">wordwrap</font><font  color="#007700">(</font><font  color="#0000BB">$text</font><font  color="#007700">, </font><font  color="#0000BB">8</font><font  color="#007700">, </font><font  color="#DD0000">"\n"</font><font  color="#007700">, </font><font  color="#0000BB">1</font><font  color="#007700">);<br  /><br  />echo </font><font  color="#DD0000">"$newtext\n"</font><font  color="#007700">;<br  /></font><font  color="#0000BB">?></font>
</font>
</code></TD
></TR
></TABLE
><P  >     This example would display:
    </P
><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5" ><TR  ><TD  ><PRE  CLASS="screen" >A very
long
wooooooo
ooooord.</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
><P  >     See also <SPAN HREF="#"><B  CLASS="function" >nl2br()</B
></A
>.
    </P
></DIV
>]]></description>
        </method>
    </methods>
</Root>
