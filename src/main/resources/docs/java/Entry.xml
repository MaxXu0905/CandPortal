<?xml version="1.0" encoding="UTF-8"?>
<Root name="java.util.Map.Entry&lt;K,V&gt;">
    <methods>
        <method>
            <name>getKey</name>
            <signature><![CDATA[K getKey()]]></signature>
            <description><![CDATA[Returns the key corresponding to this entry.<dl><dt><span class="strong">Returns:</span></dt><dd>the key corresponding to this entry</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalStateException</a></code> - implementations may, but are not
         required to, throw this exception if the entry has been
         removed from the backing map.</dd></dl>]]></description>
        </method>
        <method>
            <name>getValue</name>
            <signature><![CDATA[V getValue()]]></signature>
            <description><![CDATA[Returns the value corresponding to this entry.  If the mapping
 has been removed from the backing map (by the iterator's
 remove operation), the results of this call are undefined.<dl><dt><span class="strong">Returns:</span></dt><dd>the value corresponding to this entry</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalStateException</a></code> - implementations may, but are not
         required to, throw this exception if the entry has been
         removed from the backing map.</dd></dl>]]></description>
        </method>
        <method>
            <name>setValue</name>
            <signature><![CDATA[V setValue(V value)]]></signature>
            <description><![CDATA[Replaces the value corresponding to this entry with the specified
 value (optional operation).  (Writes through to the map.)  The
 behavior of this call is undefined if the mapping has already been
 removed from the map (by the iterator's remove operation).<dl><dt><span class="strong">Parameters:</span></dt><dd><code>value</code> - new value to be stored in this entry</dd>
<dt><span class="strong">Returns:</span></dt><dd>old value corresponding to the entry</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">UnsupportedOperationException</a></code> - if the <tt>put</tt> operation
         is not supported by the backing map</dd>
<dd><code><a href="#">ClassCastException</a></code> - if the class of the specified value
         prevents it from being stored in the backing map</dd>
<dd><code><a href="#">NullPointerException</a></code> - if the backing map does not permit
         null values, and the specified value is null</dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if some property of this value
         prevents it from being stored in the backing map</dd>
<dd><code><a href="#">IllegalStateException</a></code> - implementations may, but are not
         required to, throw this exception if the entry has been
         removed from the backing map.</dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[boolean equals(Object o)]]></signature>
            <description><![CDATA[Compares the specified object with this entry for equality.
 Returns true if the given object is also a map entry and
 the two entries represent the same mapping.  More formally, two
 entries e1 and e2 represent the same mapping
 if
     (e1.getKey()==null ?
      e2.getKey()==null : e1.getKey().equals(e2.getKey()))  &&
     (e1.getValue()==null ?
      e2.getValue()==null : e1.getValue().equals(e2.getValue()))
 
 This ensures that the equals method works properly across
 different implementations of the Map.Entry interface.<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="#">equals</a></code> in class <code><a href="#">Object</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>o</code> - object to be compared for equality with this map entry</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the specified object is equal to this map
         entry</dd><dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>Object.hashCode()</code></a>, 
<a href="#"><code>HashMap</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[int hashCode()]]></signature>
            <description><![CDATA[Returns the hash code value for this map entry.  The hash code
 of a map entry e is defined to be: 
     (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^
     (e.getValue()==null ? 0 : e.getValue().hashCode())
 
 This ensures that e1.equals(e2) implies that
 e1.hashCode()==e2.hashCode() for any two Entries
 e1 and e2, as required by the general
 contract of Object.hashCode.<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="#">hashCode</a></code> in class <code><a href="#">Object</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the hash code value for this map entry</dd><dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>Object.hashCode()</code></a>, 
<a href="#"><code>Object.equals(Object)</code></a>, 
<a href="#"><code>equals(Object)</code></a></dd></dl>]]></description>
        </method>
    </methods>
</Root>
