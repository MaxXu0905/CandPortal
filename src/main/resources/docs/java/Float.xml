<?xml version="1.0" encoding="UTF-8"?>
<Root name="java.lang.Float">
    <fields>
        <field>
            <name>POSITIVE_INFINITY</name>
            <signature><![CDATA[public static final float POSITIVE_INFINITY]]></signature>
            <description><![CDATA[A constant holding the positive infinity of type
 float. It is equal to the value returned by
 Float.intBitsToFloat(0x7f800000).<dl><dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>NEGATIVE_INFINITY</name>
            <signature><![CDATA[public static final float NEGATIVE_INFINITY]]></signature>
            <description><![CDATA[A constant holding the negative infinity of type
 float. It is equal to the value returned by
 Float.intBitsToFloat(0xff800000).<dl><dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>NaN</name>
            <signature><![CDATA[public static final float NaN]]></signature>
            <description><![CDATA[A constant holding a Not-a-Number (NaN) value of type
 float.  It is equivalent to the value returned by
 Float.intBitsToFloat(0x7fc00000).<dl><dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>MAX_VALUE</name>
            <signature><![CDATA[public static final float MAX_VALUE]]></signature>
            <description><![CDATA[A constant holding the largest positive finite value of type
 float, (2-2-23)·2127.
 It is equal to the hexadecimal floating-point literal
 0x1.fffffeP+127f and also equal to
 Float.intBitsToFloat(0x7f7fffff).<dl><dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>MIN_NORMAL</name>
            <signature><![CDATA[public static final float MIN_NORMAL]]></signature>
            <description><![CDATA[A constant holding the smallest positive normal value of type
 float, 2-126.  It is equal to the
 hexadecimal floating-point literal 0x1.0p-126f and also
 equal to Float.intBitsToFloat(0x00800000).<dl><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>MIN_VALUE</name>
            <signature><![CDATA[public static final float MIN_VALUE]]></signature>
            <description><![CDATA[A constant holding the smallest positive nonzero value of type
 float, 2-149. It is equal to the
 hexadecimal floating-point literal 0x0.000002P-126f
 and also equal to Float.intBitsToFloat(0x1).<dl><dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>MAX_EXPONENT</name>
            <signature><![CDATA[public static final int MAX_EXPONENT]]></signature>
            <description><![CDATA[Maximum exponent a finite float variable may have.  It
 is equal to the value returned by Math.getExponent(Float.MAX_VALUE).<dl><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>MIN_EXPONENT</name>
            <signature><![CDATA[public static final int MIN_EXPONENT]]></signature>
            <description><![CDATA[Minimum exponent a normalized float variable may have.
 It is equal to the value returned by Math.getExponent(Float.MIN_NORMAL).<dl><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>SIZE</name>
            <signature><![CDATA[public static final int SIZE]]></signature>
            <description><![CDATA[The number of bits used to represent a float value.<dl><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#">Constant Field Values</a></dd></dl>]]></description>
        </field>
        <field>
            <name>TYPE</name>
            <signature><![CDATA[public static final Class<Float> TYPE]]></signature>
            <description><![CDATA[The Class instance representing the primitive type
 float.<dl><dt><span class="strong">Since:</span></dt>
  <dd>JDK1.1</dd></dl>]]></description>
        </field>
    </fields>
    <constructors>
        <constructor>
            <name>Float</name>
            <signature><![CDATA[public Float(float value)]]></signature>
            <description><![CDATA[Constructs a newly allocated Float object that
 represents the primitive float argument.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>value</code> - the value to be represented by the <code>Float</code>.</dd></dl>]]></description>
        </constructor>
        <constructor>
            <name>Float</name>
            <signature><![CDATA[public Float(double value)]]></signature>
            <description><![CDATA[Constructs a newly allocated Float object that
 represents the argument converted to type float.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>value</code> - the value to be represented by the <code>Float</code>.</dd></dl>]]></description>
        </constructor>
        <constructor>
            <name>Float</name>
            <signature><![CDATA[public Float(String s)
      throws NumberFormatException]]></signature>
            <description><![CDATA[Constructs a newly allocated Float object that
 represents the floating-point value of type float
 represented by the string. The string is converted to a
 float value as if by the valueOf method.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>s</code> - a string to be converted to a <code>Float</code>.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NumberFormatException</a></code> - if the string does not contain a
               parsable number.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>valueOf(java.lang.String)</code></a></dd></dl>]]></description>
        </constructor>
    </constructors>
    <methods>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(float f)]]></signature>
            <description><![CDATA[Returns a string representation of the float
 argument. All characters mentioned below are ASCII characters.
 
 If the argument is NaN, the result is the string
 "NaN".
 Otherwise, the result is a string that represents the sign and
     magnitude (absolute value) of the argument. If the sign is
     negative, the first character of the result is
     '-' ('\u002D'); if the sign is
     positive, no sign character appears in the result. As for
     the magnitude m:
 
 If m is infinity, it is represented by the characters
     "Infinity"; thus, positive infinity produces
     the result "Infinity" and negative infinity
     produces the result "-Infinity".
 If m is zero, it is represented by the characters
     "0.0"; thus, negative zero produces the result
     "-0.0" and positive zero produces the result
     "0.0".
  If m is greater than or equal to 10-3 but
      less than 107, then it is represented as the
      integer part of m, in decimal form with no leading
      zeroes, followed by '.'
      ('\u002E'), followed by one or more
      decimal digits representing the fractional part of
      m.
  If m is less than 10-3 or greater than or
      equal to 107, then it is represented in
      so-called "computerized scientific notation." Let n
      be the unique integer such that 10n ≤
      m < 10n+1; then let a
      be the mathematically exact quotient of m and
      10n so that 1 ≤ a < 10.
      The magnitude is then represented as the integer part of
      a, as a single decimal digit, followed by
      '.' ('\u002E'), followed by
      decimal digits representing the fractional part of
      a, followed by the letter 'E'
      ('\u0045'), followed by a representation
      of n as a decimal integer, as produced by the
      method Integer.toString(int).

 
 
 How many digits must be printed for the fractional part of
 m or a? There must be at least one digit
 to represent the fractional part, and beyond that as many, but
 only as many, more digits as are needed to uniquely distinguish
 the argument value from adjacent values of type
 float. That is, suppose that x is the
 exact mathematical value represented by the decimal
 representation produced by this method for a finite nonzero
 argument f. Then f must be the float
 value nearest to x; or, if two float values are
 equally close to x, then f must be one of
 them and the least significant bit of the significand of
 f must be 0.

 To create localized string representations of a floating-point
 value, use subclasses of NumberFormat.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>f</code> - the float to be converted.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of the argument.</dd></dl>]]></description>
        </method>
        <method>
            <name>toHexString</name>
            <signature><![CDATA[public static String toHexString(float f)]]></signature>
            <description><![CDATA[Returns a hexadecimal string representation of the
 float argument. All characters mentioned below are
 ASCII characters.

 
 If the argument is NaN, the result is the string
     "NaN".
 Otherwise, the result is a string that represents the sign and
 magnitude (absolute value) of the argument. If the sign is negative,
 the first character of the result is '-'
 ('\u002D'); if the sign is positive, no sign character
 appears in the result. As for the magnitude m:

 
 If m is infinity, it is represented by the string
 "Infinity"; thus, positive infinity produces the
 result "Infinity" and negative infinity produces
 the result "-Infinity".

 If m is zero, it is represented by the string
 "0x0.0p0"; thus, negative zero produces the result
 "-0x0.0p0" and positive zero produces the result
 "0x0.0p0".

 If m is a float value with a
 normalized representation, substrings are used to represent the
 significand and exponent fields.  The significand is
 represented by the characters "0x1."
 followed by a lowercase hexadecimal representation of the rest
 of the significand as a fraction.  Trailing zeros in the
 hexadecimal representation are removed unless all the digits
 are zero, in which case a single zero is used. Next, the
 exponent is represented by "p" followed
 by a decimal string of the unbiased exponent as if produced by
 a call to Integer.toString on the
 exponent value.

 If m is a float value with a subnormal
 representation, the significand is represented by the
 characters "0x0." followed by a
 hexadecimal representation of the rest of the significand as a
 fraction.  Trailing zeros in the hexadecimal representation are
 removed. Next, the exponent is represented by
 "p-126".  Note that there must be at
 least one nonzero digit in a subnormal significand.

 

 

 
 Examples
 Floating-point ValueHexadecimal String
 1.0 0x1.0p0
 -1.0        -0x1.0p0
 2.0 0x1.0p1
 3.0 0x1.8p1
 0.5 0x1.0p-1
 0.25        0x1.0p-2
 Float.MAX_VALUE
     0x1.fffffep127
 Minimum Normal Value
     0x1.0p-126
 Maximum Subnormal Value
     0x0.fffffep-126
 Float.MIN_VALUE
     0x0.000002p-126
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>f</code> - the <code>float</code> to be converted.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a hex string representation of the argument.</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>valueOf</name>
            <signature><![CDATA[public static Float valueOf(String s)
                     throws NumberFormatException]]></signature>
            <description><![CDATA[Returns a Float object holding the
 float value represented by the argument string
 s.

 If s is null, then a
 NullPointerException is thrown.

 Leading and trailing whitespace characters in s
 are ignored.  Whitespace is removed as if by the String.trim() method; that is, both ASCII space and control
 characters are removed. The rest of s should
 constitute a FloatValue as described by the lexical
 syntax rules:

 
 
 FloatValue:
 Signopt NaN
 Signopt Infinity
 Signopt FloatingPointLiteral
 Signopt HexFloatingPointLiteral
 SignedInteger
 

 

 
 HexFloatingPointLiteral:
  HexSignificand BinaryExponent FloatTypeSuffixopt
 

 

 
 HexSignificand:
 HexNumeral
 HexNumeral .
 0x HexDigitsopt
     . HexDigits
 0X HexDigitsopt
     . HexDigits
 

 

 
 BinaryExponent:
 BinaryExponentIndicator SignedInteger
 

 

 
 BinaryExponentIndicator:
 p
 P
 

 

 where Sign, FloatingPointLiteral,
 HexNumeral, HexDigits, SignedInteger and
 FloatTypeSuffix are as defined in the lexical structure
 sections of
 The Java™ Language Specification,
 except that underscores are not accepted between digits.
 If s does not have the form of
 a FloatValue, then a NumberFormatException
 is thrown. Otherwise, s is regarded as
 representing an exact decimal value in the usual
 "computerized scientific notation" or as an exact
 hexadecimal value; this exact numerical value is then
 conceptually converted to an "infinitely precise"
 binary value that is then rounded to type float
 by the usual round-to-nearest rule of IEEE 754 floating-point
 arithmetic, which includes preserving the sign of a zero
 value.

 Note that the round-to-nearest rule also implies overflow and
 underflow behaviour; if the exact value of s is large
 enough in magnitude (greater than or equal to (MAX_VALUE + ulp(MAX_VALUE)/2),
 rounding to float will result in an infinity and if the
 exact value of s is small enough in magnitude (less
 than or equal to MIN_VALUE/2), rounding to float will
 result in a zero.

 Finally, after rounding a Float object representing
 this float value is returned.

 To interpret localized string representations of a
 floating-point value, use subclasses of NumberFormat.

 Note that trailing format specifiers, specifiers that
 determine the type of a floating-point literal
 (1.0f is a float value;
 1.0d is a double value), do
 not influence the results of this method.  In other
 words, the numerical value of the input string is converted
 directly to the target floating-point type.  In general, the
 two-step sequence of conversions, string to double
 followed by double to float, is
 not equivalent to converting a string directly to
 float.  For example, if first converted to an
 intermediate double and then to
 float, the string
 "1.00000017881393421514957253748434595763683319091796875001d"
 results in the float value
 1.0000002f; if the string is converted directly to
 float, 1.0000001f results.

 To avoid calling this method on an invalid string and having
 a NumberFormatException be thrown, the documentation
 for Double.valueOf lists a regular
 expression which can be used to screen the input.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>s</code> - the string to be parsed.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>Float</code> object holding the value
          represented by the <code>String</code> argument.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NumberFormatException</a></code> - if the string does not contain a
          parsable number.</dd></dl>]]></description>
        </method>
        <method>
            <name>valueOf</name>
            <signature><![CDATA[public static Float valueOf(float f)]]></signature>
            <description><![CDATA[Returns a Float instance representing the specified
 float value.
 If a new Float instance is not required, this method
 should generally be used in preference to the constructor
 Float(float), as this method is likely to yield
 significantly better space and time performance by caching
 frequently requested values.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>f</code> - a float value.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>Float</code> instance representing <code>f</code>.</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>parseFloat</name>
            <signature><![CDATA[public static float parseFloat(String s)
                        throws NumberFormatException]]></signature>
            <description><![CDATA[Returns a new float initialized to the value
 represented by the specified String, as performed
 by the valueOf method of class Float.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>s</code> - the string to be parsed.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the <code>float</code> value represented by the string
         argument.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NullPointerException</a></code> - if the string is null</dd>
<dd><code><a href="#">NumberFormatException</a></code> - if the string does not contain a
               parsable <code>float</code>.</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>valueOf(String)</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>isNaN</name>
            <signature><![CDATA[public static boolean isNaN(float v)]]></signature>
            <description><![CDATA[Returns true if the specified number is a
 Not-a-Number (NaN) value, false otherwise.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>v</code> - the value to be tested.</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if the argument is NaN;
          <code>false</code> otherwise.</dd></dl>]]></description>
        </method>
        <method>
            <name>isInfinite</name>
            <signature><![CDATA[public static boolean isInfinite(float v)]]></signature>
            <description><![CDATA[Returns true if the specified number is infinitely
 large in magnitude, false otherwise.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>v</code> - the value to be tested.</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if the argument is positive infinity or
          negative infinity; <code>false</code> otherwise.</dd></dl>]]></description>
        </method>
        <method>
            <name>isNaN</name>
            <signature><![CDATA[public boolean isNaN()]]></signature>
            <description><![CDATA[Returns true if this Float value is a
 Not-a-Number (NaN), false otherwise.<dl><dt><span class="strong">Returns:</span></dt><dd><code>true</code> if the value represented by this object is
          NaN; <code>false</code> otherwise.</dd></dl>]]></description>
        </method>
        <method>
            <name>isInfinite</name>
            <signature><![CDATA[public boolean isInfinite()]]></signature>
            <description><![CDATA[Returns true if this Float value is
 infinitely large in magnitude, false otherwise.<dl><dt><span class="strong">Returns:</span></dt><dd><code>true</code> if the value represented by this object is
          positive infinity or negative infinity;
          <code>false</code> otherwise.</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public String toString()]]></signature>
            <description><![CDATA[Returns a string representation of this Float object.
 The primitive float value represented by this object
 is converted to a String exactly as if by the method
 toString of one argument.<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="#">toString</a></code> in class <code><a href="#">Object</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>String</code> representation of this object.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>toString(float)</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>byteValue</name>
            <signature><![CDATA[public byte byteValue()]]></signature>
            <description><![CDATA[Returns the value of this Float as a byte (by
 casting to a byte).<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="#">byteValue</a></code> in class <code><a href="#">Number</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the <code>float</code> value represented by this object
          converted to type <code>byte</code></dd></dl>]]></description>
        </method>
        <method>
            <name>shortValue</name>
            <signature><![CDATA[public short shortValue()]]></signature>
            <description><![CDATA[Returns the value of this Float as a short (by
 casting to a short).<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="#">shortValue</a></code> in class <code><a href="#">Number</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the <code>float</code> value represented by this object
          converted to type <code>short</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>JDK1.1</dd></dl>]]></description>
        </method>
        <method>
            <name>intValue</name>
            <signature><![CDATA[public int intValue()]]></signature>
            <description><![CDATA[Returns the value of this Float as an int (by
 casting to type int).<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="#">intValue</a></code> in class <code><a href="#">Number</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the <code>float</code> value represented by this object
          converted to type <code>int</code></dd></dl>]]></description>
        </method>
        <method>
            <name>longValue</name>
            <signature><![CDATA[public long longValue()]]></signature>
            <description><![CDATA[Returns value of this Float as a long (by
 casting to type long).<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="#">longValue</a></code> in class <code><a href="#">Number</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the <code>float</code> value represented by this object
          converted to type <code>long</code></dd></dl>]]></description>
        </method>
        <method>
            <name>floatValue</name>
            <signature><![CDATA[public float floatValue()]]></signature>
            <description><![CDATA[Returns the float value of this Float object.<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="#">floatValue</a></code> in class <code><a href="#">Number</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the <code>float</code> value represented by this object</dd></dl>]]></description>
        </method>
        <method>
            <name>doubleValue</name>
            <signature><![CDATA[public double doubleValue()]]></signature>
            <description><![CDATA[Returns the double value of this Float object.<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="#">doubleValue</a></code> in class <code><a href="#">Number</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the <code>float</code> value represented by this
         object is converted to type <code>double</code> and the
         result of the conversion is returned.</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public int hashCode()]]></signature>
            <description><![CDATA[Returns a hash code for this Float object. The
 result is the integer bit representation, exactly as produced
 by the method floatToIntBits(float), of the primitive
 float value represented by this Float
 object.<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="#">hashCode</a></code> in class <code><a href="#">Object</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>a hash code value for this object.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>Object.equals(java.lang.Object)</code></a>, 
<a href="#"><code>System.identityHashCode(java.lang.Object)</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public boolean equals(Object obj)]]></signature>
            <description><![CDATA[Compares this object against the specified object.  The result
 is true if and only if the argument is not
 null and is a Float object that
 represents a float with the same value as the
 float represented by this object. For this
 purpose, two float values are considered to be the
 same if and only if the method floatToIntBits(float)
 returns the identical int value when applied to
 each.

 Note that in most cases, for two instances of class
 Float, f1 and f2, the value
 of f1.equals(f2) is true if and only if

 
   f1.floatValue() == f2.floatValue()
 

 also has the value true. However, there are two exceptions:
 
 If f1 and f2 both represent
     Float.NaN, then the equals method returns
     true, even though Float.NaN==Float.NaN
     has the value false.
 If f1 represents +0.0f while
     f2 represents -0.0f, or vice
     versa, the equal test has the value
     false, even though 0.0f==-0.0f
     has the value true.
 

 This definition allows hash tables to operate properly.<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="#">equals</a></code> in class <code><a href="#">Object</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>obj</code> - the object to be compared</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if the objects are the same;
          <code>false</code> otherwise.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>floatToIntBits(float)</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>floatToIntBits</name>
            <signature><![CDATA[public static int floatToIntBits(float value)]]></signature>
            <description><![CDATA[Returns a representation of the specified floating-point value
 according to the IEEE 754 floating-point "single format" bit
 layout.

 Bit 31 (the bit that is selected by the mask
 0x80000000) represents the sign of the floating-point
 number.
 Bits 30-23 (the bits that are selected by the mask
 0x7f800000) represent the exponent.
 Bits 22-0 (the bits that are selected by the mask
 0x007fffff) represent the significand (sometimes called
 the mantissa) of the floating-point number.

 If the argument is positive infinity, the result is
 0x7f800000.

 If the argument is negative infinity, the result is
 0xff800000.

 If the argument is NaN, the result is 0x7fc00000.

 In all cases, the result is an integer that, when given to the
 intBitsToFloat(int) method, will produce a floating-point
 value the same as the argument to floatToIntBits
 (except all NaN values are collapsed to a single
 "canonical" NaN value).<dl><dt><span class="strong">Parameters:</span></dt><dd><code>value</code> - a floating-point number.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the bits that represent the floating-point number.</dd></dl>]]></description>
        </method>
        <method>
            <name>floatToRawIntBits</name>
            <signature><![CDATA[public static int floatToRawIntBits(float value)]]></signature>
            <description><![CDATA[Returns a representation of the specified floating-point value
 according to the IEEE 754 floating-point "single format" bit
 layout, preserving Not-a-Number (NaN) values.

 Bit 31 (the bit that is selected by the mask
 0x80000000) represents the sign of the floating-point
 number.
 Bits 30-23 (the bits that are selected by the mask
 0x7f800000) represent the exponent.
 Bits 22-0 (the bits that are selected by the mask
 0x007fffff) represent the significand (sometimes called
 the mantissa) of the floating-point number.

 If the argument is positive infinity, the result is
 0x7f800000.

 If the argument is negative infinity, the result is
 0xff800000.

 If the argument is NaN, the result is the integer representing
 the actual NaN value.  Unlike the floatToIntBits
 method, floatToRawIntBits does not collapse all the
 bit patterns encoding a NaN to a single "canonical"
 NaN value.

 In all cases, the result is an integer that, when given to the
 intBitsToFloat(int) method, will produce a
 floating-point value the same as the argument to
 floatToRawIntBits.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>value</code> - a floating-point number.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the bits that represent the floating-point number.</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.3</dd></dl>]]></description>
        </method>
        <method>
            <name>intBitsToFloat</name>
            <signature><![CDATA[public static float intBitsToFloat(int bits)]]></signature>
            <description><![CDATA[Returns the float value corresponding to a given
 bit representation.
 The argument is considered to be a representation of a
 floating-point value according to the IEEE 754 floating-point
 "single format" bit layout.

 If the argument is 0x7f800000, the result is positive
 infinity.

 If the argument is 0xff800000, the result is negative
 infinity.

 If the argument is any value in the range
 0x7f800001 through 0x7fffffff or in
 the range 0xff800001 through
 0xffffffff, the result is a NaN.  No IEEE 754
 floating-point operation provided by Java can distinguish
 between two NaN values of the same type with different bit
 patterns.  Distinct values of NaN are only distinguishable by
 use of the Float.floatToRawIntBits method.

 In all other cases, let s, e, and m be three
 values that can be computed from the argument:

 
 int s = ((bits >> 31) == 0) ? 1 : -1;
 int e = ((bits >> 23) & 0xff);
 int m = (e == 0) ?
                 (bits & 0x7fffff) << 1 :
                 (bits & 0x7fffff) | 0x800000;
 

 Then the floating-point result equals the value of the mathematical
 expression s·m·2e-150.

 Note that this method may not be able to return a
 float NaN with exactly same bit pattern as the
 int argument.  IEEE 754 distinguishes between two
 kinds of NaNs, quiet NaNs and signaling NaNs.  The
 differences between the two kinds of NaN are generally not
 visible in Java.  Arithmetic operations on signaling NaNs turn
 them into quiet NaNs with a different, but often similar, bit
 pattern.  However, on some processors merely copying a
 signaling NaN also performs that conversion.  In particular,
 copying a signaling NaN to return it to the calling method may
 perform this conversion.  So intBitsToFloat may
 not be able to return a float with a signaling NaN
 bit pattern.  Consequently, for some int values,
 floatToRawIntBits(intBitsToFloat(start)) may
 not equal start.  Moreover, which
 particular bit patterns represent signaling NaNs is platform
 dependent; although all NaN bit patterns, quiet or signaling,
 must be in the NaN range identified above.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>bits</code> - an integer.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the <code>float</code> floating-point value with the same bit
          pattern.</dd></dl>]]></description>
        </method>
        <method>
            <name>compareTo</name>
            <signature><![CDATA[public int compareTo(Float anotherFloat)]]></signature>
            <description><![CDATA[Compares two Float objects numerically.  There are
 two ways in which comparisons performed by this method differ
 from those performed by the Java language numerical comparison
 operators (<, <=, ==, >=, >) when
 applied to primitive float values:

 
          Float.NaN is considered by this method to
          be equal to itself and greater than all other
          float values
          (including Float.POSITIVE_INFINITY).
 
          0.0f is considered by this method to be greater
          than -0.0f.
 

 This ensures that the natural ordering of Float
 objects imposed by this method is consistent with equals.<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="#">compareTo</a></code> in interface <code><a href="#">Comparable</a><<a href="#">Float</a>></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>anotherFloat</code> - the <code>Float</code> to be compared.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the value <code>0</code> if <code>anotherFloat</code> is
          numerically equal to this <code>Float</code>; a value
          less than <code>0</code> if this <code>Float</code>
          is numerically less than <code>anotherFloat</code>;
          and a value greater than <code>0</code> if this
          <code>Float</code> is numerically greater than
          <code>anotherFloat</code>.</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.2</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>Comparable.compareTo(Object)</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>compare</name>
            <signature><![CDATA[public static int compare(float f1,
          float f2)]]></signature>
            <description><![CDATA[Compares the two specified float values. The sign
 of the integer value returned is the same as that of the
 integer that would be returned by the call:
 
    new Float(f1).compareTo(new Float(f2))
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>f1</code> - the first <code>float</code> to compare.</dd><dd><code>f2</code> - the second <code>float</code> to compare.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the value <code>0</code> if <code>f1</code> is
          numerically equal to <code>f2</code>; a value less than
          <code>0</code> if <code>f1</code> is numerically less than
          <code>f2</code>; and a value greater than <code>0</code>
          if <code>f1</code> is numerically greater than
          <code>f2</code>.</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4</dd></dl>]]></description>
        </method>
    </methods>
</Root>
