<?xml version="1.0" encoding="UTF-8"?>
<Root name="java.util.Arrays">
    <methods>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(int[] a)]]></signature>
            <description><![CDATA[Sorts the specified array into ascending numerical order.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(int[] a,
        int fromIndex,
        int toIndex)]]></signature>
            <description><![CDATA[Sorts the specified range of the array into ascending order. The range
 to be sorted extends from the index fromIndex, inclusive, to
 the index toIndex, exclusive. If fromIndex == toIndex,
 the range to be sorted is empty.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd><dd><code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or <code>toIndex > a.length</code></dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(long[] a)]]></signature>
            <description><![CDATA[Sorts the specified array into ascending numerical order.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(long[] a,
        int fromIndex,
        int toIndex)]]></signature>
            <description><![CDATA[Sorts the specified range of the array into ascending order. The range
 to be sorted extends from the index fromIndex, inclusive, to
 the index toIndex, exclusive. If fromIndex == toIndex,
 the range to be sorted is empty.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd><dd><code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or <code>toIndex > a.length</code></dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(short[] a)]]></signature>
            <description><![CDATA[Sorts the specified array into ascending numerical order.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(short[] a,
        int fromIndex,
        int toIndex)]]></signature>
            <description><![CDATA[Sorts the specified range of the array into ascending order. The range
 to be sorted extends from the index fromIndex, inclusive, to
 the index toIndex, exclusive. If fromIndex == toIndex,
 the range to be sorted is empty.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd><dd><code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or <code>toIndex > a.length</code></dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(char[] a)]]></signature>
            <description><![CDATA[Sorts the specified array into ascending numerical order.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(char[] a,
        int fromIndex,
        int toIndex)]]></signature>
            <description><![CDATA[Sorts the specified range of the array into ascending order. The range
 to be sorted extends from the index fromIndex, inclusive, to
 the index toIndex, exclusive. If fromIndex == toIndex,
 the range to be sorted is empty.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd><dd><code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or <code>toIndex > a.length</code></dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(byte[] a)]]></signature>
            <description><![CDATA[Sorts the specified array into ascending numerical order.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(byte[] a,
        int fromIndex,
        int toIndex)]]></signature>
            <description><![CDATA[Sorts the specified range of the array into ascending order. The range
 to be sorted extends from the index fromIndex, inclusive, to
 the index toIndex, exclusive. If fromIndex == toIndex,
 the range to be sorted is empty.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd><dd><code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or <code>toIndex > a.length</code></dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(float[] a)]]></signature>
            <description><![CDATA[Sorts the specified array into ascending numerical order.

 The < relation does not provide a total order on all float
 values: -0.0f == 0.0f is true and a Float.NaN
 value compares neither less than, greater than, nor equal to any value,
 even itself. This method uses the total order imposed by the method
 Float.compareTo(java.lang.Float): -0.0f is treated as less than value
 0.0f and Float.NaN is considered greater than any
 other value and all Float.NaN values are considered equal.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(float[] a,
        int fromIndex,
        int toIndex)]]></signature>
            <description><![CDATA[Sorts the specified range of the array into ascending order. The range
 to be sorted extends from the index fromIndex, inclusive, to
 the index toIndex, exclusive. If fromIndex == toIndex,
 the range to be sorted is empty.

 The < relation does not provide a total order on all float
 values: -0.0f == 0.0f is true and a Float.NaN
 value compares neither less than, greater than, nor equal to any value,
 even itself. This method uses the total order imposed by the method
 Float.compareTo(java.lang.Float): -0.0f is treated as less than value
 0.0f and Float.NaN is considered greater than any
 other value and all Float.NaN values are considered equal.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd><dd><code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or <code>toIndex > a.length</code></dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(double[] a)]]></signature>
            <description><![CDATA[Sorts the specified array into ascending numerical order.

 The < relation does not provide a total order on all double
 values: -0.0d == 0.0d is true and a Double.NaN
 value compares neither less than, greater than, nor equal to any value,
 even itself. This method uses the total order imposed by the method
 Double.compareTo(java.lang.Double): -0.0d is treated as less than value
 0.0d and Double.NaN is considered greater than any
 other value and all Double.NaN values are considered equal.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(double[] a,
        int fromIndex,
        int toIndex)]]></signature>
            <description><![CDATA[Sorts the specified range of the array into ascending order. The range
 to be sorted extends from the index fromIndex, inclusive, to
 the index toIndex, exclusive. If fromIndex == toIndex,
 the range to be sorted is empty.

 The < relation does not provide a total order on all double
 values: -0.0d == 0.0d is true and a Double.NaN
 value compares neither less than, greater than, nor equal to any value,
 even itself. This method uses the total order imposed by the method
 Double.compareTo(java.lang.Double): -0.0d is treated as less than value
 0.0d and Double.NaN is considered greater than any
 other value and all Double.NaN values are considered equal.

 Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
 by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
 offers O(n log(n)) performance on many data sets that cause other
 quicksorts to degrade to quadratic performance, and is typically
 faster than traditional (one-pivot) Quicksort implementations.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd><dd><code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or <code>toIndex > a.length</code></dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(Object[] a)]]></signature>
            <description><![CDATA[Sorts the specified array of objects into ascending order, according
 to the natural ordering of its elements.
 All elements in the array must implement the Comparable
 interface.  Furthermore, all elements in the array must be
 mutually comparable (that is, e1.compareTo(e2) must
 not throw a ClassCastException for any elements e1
 and e2 in the array).

 This sort is guaranteed to be stable:  equal elements will
 not be reordered as a result of the sort.

 Implementation note: This implementation is a stable, adaptive,
 iterative mergesort that requires far fewer than n lg(n) comparisons
 when the input array is partially sorted, while offering the
 performance of a traditional mergesort when the input array is
 randomly ordered.  If the input array is nearly sorted, the
 implementation requires approximately n comparisons.  Temporary
 storage requirements vary from a small constant for nearly sorted
 input arrays to n/2 object references for randomly ordered input
 arrays.

 The implementation takes equal advantage of ascending and
 descending order in its input array, and can take advantage of
 ascending and descending order in different parts of the the same
 input array.  It is well-suited to merging two or more sorted arrays:
 simply concatenate the arrays and sort the resulting array.

 The implementation was adapted from Tim Peters's list sort for Python
 (
 TimSort).  It uses techiques from Peter McIlroy's "Optimistic
 Sorting and Information Theoretic Complexity", in Proceedings of the
 Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 January 1993.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ClassCastException</a></code> - if the array contains elements that are not
         <i>mutually comparable</i> (for example, strings and integers)</dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - (optional) if the natural
         ordering of the array elements is found to violate the
         <a href="#"><code>Comparable</code></a> contract</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static void sort(Object[] a,
        int fromIndex,
        int toIndex)]]></signature>
            <description><![CDATA[Sorts the specified range of the specified array of objects into
 ascending order, according to the
 natural ordering of its
 elements.  The range to be sorted extends from index
 fromIndex, inclusive, to index toIndex, exclusive.
 (If fromIndex==toIndex, the range to be sorted is empty.)  All
 elements in this range must implement the Comparable
 interface.  Furthermore, all elements in this range must be mutually
 comparable (that is, e1.compareTo(e2) must not throw a
 ClassCastException for any elements e1 and
 e2 in the array).

 This sort is guaranteed to be stable:  equal elements will
 not be reordered as a result of the sort.

 Implementation note: This implementation is a stable, adaptive,
 iterative mergesort that requires far fewer than n lg(n) comparisons
 when the input array is partially sorted, while offering the
 performance of a traditional mergesort when the input array is
 randomly ordered.  If the input array is nearly sorted, the
 implementation requires approximately n comparisons.  Temporary
 storage requirements vary from a small constant for nearly sorted
 input arrays to n/2 object references for randomly ordered input
 arrays.

 The implementation takes equal advantage of ascending and
 descending order in its input array, and can take advantage of
 ascending and descending order in different parts of the the same
 input array.  It is well-suited to merging two or more sorted arrays:
 simply concatenate the arrays and sort the resulting array.

 The implementation was adapted from Tim Peters's list sort for Python
 (
 TimSort).  It uses techiques from Peter McIlroy's "Optimistic
 Sorting and Information Theoretic Complexity", in Proceedings of the
 Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 January 1993.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        sorted</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be sorted</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code> or
         (optional) if the natural ordering of the array elements is
         found to violate the <a href="#"><code>Comparable</code></a> contract</dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or
         <code>toIndex > a.length</code></dd>
<dd><code><a href="#">ClassCastException</a></code> - if the array contains elements that are
         not <i>mutually comparable</i> (for example, strings and
         integers).</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static <T> void sort(T[] a,
            Comparator<? super T> c)]]></signature>
            <description><![CDATA[Sorts the specified array of objects according to the order induced by
 the specified comparator.  All elements in the array must be
 mutually comparable by the specified comparator (that is,
 c.compare(e1, e2) must not throw a ClassCastException
 for any elements e1 and e2 in the array).

 This sort is guaranteed to be stable:  equal elements will
 not be reordered as a result of the sort.

 Implementation note: This implementation is a stable, adaptive,
 iterative mergesort that requires far fewer than n lg(n) comparisons
 when the input array is partially sorted, while offering the
 performance of a traditional mergesort when the input array is
 randomly ordered.  If the input array is nearly sorted, the
 implementation requires approximately n comparisons.  Temporary
 storage requirements vary from a small constant for nearly sorted
 input arrays to n/2 object references for randomly ordered input
 arrays.

 The implementation takes equal advantage of ascending and
 descending order in its input array, and can take advantage of
 ascending and descending order in different parts of the the same
 input array.  It is well-suited to merging two or more sorted arrays:
 simply concatenate the arrays and sort the resulting array.

 The implementation was adapted from Tim Peters's list sort for Python
 (
 TimSort).  It uses techiques from Peter McIlroy's "Optimistic
 Sorting and Information Theoretic Complexity", in Proceedings of the
 Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 January 1993.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>c</code> - the comparator to determine the order of the array.  A
        <code>null</code> value indicates that the elements'
        <a href="#">natural ordering</a> should be used.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ClassCastException</a></code> - if the array contains elements that are
         not <i>mutually comparable</i> using the specified comparator</dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - (optional) if the comparator is
         found to violate the <a href="#"><code>Comparator</code></a> contract</dd></dl>]]></description>
        </method>
        <method>
            <name>sort</name>
            <signature><![CDATA[public static <T> void sort(T[] a,
            int fromIndex,
            int toIndex,
            Comparator<? super T> c)]]></signature>
            <description><![CDATA[Sorts the specified range of the specified array of objects according
 to the order induced by the specified comparator.  The range to be
 sorted extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be sorted is empty.)  All elements in the range must be
 mutually comparable by the specified comparator (that is,
 c.compare(e1, e2) must not throw a ClassCastException
 for any elements e1 and e2 in the range).

 This sort is guaranteed to be stable:  equal elements will
 not be reordered as a result of the sort.

 Implementation note: This implementation is a stable, adaptive,
 iterative mergesort that requires far fewer than n lg(n) comparisons
 when the input array is partially sorted, while offering the
 performance of a traditional mergesort when the input array is
 randomly ordered.  If the input array is nearly sorted, the
 implementation requires approximately n comparisons.  Temporary
 storage requirements vary from a small constant for nearly sorted
 input arrays to n/2 object references for randomly ordered input
 arrays.

 The implementation takes equal advantage of ascending and
 descending order in its input array, and can take advantage of
 ascending and descending order in different parts of the the same
 input array.  It is well-suited to merging two or more sorted arrays:
 simply concatenate the arrays and sort the resulting array.

 The implementation was adapted from Tim Peters's list sort for Python
 (
 TimSort).  It uses techiques from Peter McIlroy's "Optimistic
 Sorting and Information Theoretic Complexity", in Proceedings of the
 Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
 January 1993.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be sorted</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        sorted</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be sorted</dd><dd><code>c</code> - the comparator to determine the order of the array.  A
        <code>null</code> value indicates that the elements'
        <a href="#">natural ordering</a> should be used.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ClassCastException</a></code> - if the array contains elements that are not
         <i>mutually comparable</i> using the specified comparator.</dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code> or
         (optional) if the comparator is found to violate the
         <a href="#"><code>Comparator</code></a> contract</dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0</code> or
         <code>toIndex > a.length</code></dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(long[] a,
               long key)]]></signature>
            <description><![CDATA[Searches the specified array of longs for the specified value using the
 binary search algorithm.  The array must be sorted (as
 by the sort(long[]) method) prior to making this call.  If it
 is not sorted, the results are undefined.  If the array contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(long[] a,
               int fromIndex,
               int toIndex,
               long key)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array of longs for the specified value using the
 binary search algorithm.
 The range must be sorted (as
 by the sort(long[], int, int) method)
 prior to making this call.  If it
 is not sorted, the results are undefined.  If the range contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(int[] a,
               int key)]]></signature>
            <description><![CDATA[Searches the specified array of ints for the specified value using the
 binary search algorithm.  The array must be sorted (as
 by the sort(int[]) method) prior to making this call.  If it
 is not sorted, the results are undefined.  If the array contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(int[] a,
               int fromIndex,
               int toIndex,
               int key)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array of ints for the specified value using the
 binary search algorithm.
 The range must be sorted (as
 by the sort(int[], int, int) method)
 prior to making this call.  If it
 is not sorted, the results are undefined.  If the range contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(short[] a,
               short key)]]></signature>
            <description><![CDATA[Searches the specified array of shorts for the specified value using
 the binary search algorithm.  The array must be sorted
 (as by the sort(short[]) method) prior to making this call.  If
 it is not sorted, the results are undefined.  If the array contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(short[] a,
               int fromIndex,
               int toIndex,
               short key)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array of shorts for the specified value using
 the binary search algorithm.
 The range must be sorted
 (as by the sort(short[], int, int) method)
 prior to making this call.  If
 it is not sorted, the results are undefined.  If the range contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(char[] a,
               char key)]]></signature>
            <description><![CDATA[Searches the specified array of chars for the specified value using the
 binary search algorithm.  The array must be sorted (as
 by the sort(char[]) method) prior to making this call.  If it
 is not sorted, the results are undefined.  If the array contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(char[] a,
               int fromIndex,
               int toIndex,
               char key)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array of chars for the specified value using the
 binary search algorithm.
 The range must be sorted (as
 by the sort(char[], int, int) method)
 prior to making this call.  If it
 is not sorted, the results are undefined.  If the range contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(byte[] a,
               byte key)]]></signature>
            <description><![CDATA[Searches the specified array of bytes for the specified value using the
 binary search algorithm.  The array must be sorted (as
 by the sort(byte[]) method) prior to making this call.  If it
 is not sorted, the results are undefined.  If the array contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(byte[] a,
               int fromIndex,
               int toIndex,
               byte key)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array of bytes for the specified value using the
 binary search algorithm.
 The range must be sorted (as
 by the sort(byte[], int, int) method)
 prior to making this call.  If it
 is not sorted, the results are undefined.  If the range contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(double[] a,
               double key)]]></signature>
            <description><![CDATA[Searches the specified array of doubles for the specified value using
 the binary search algorithm.  The array must be sorted
 (as by the sort(double[]) method) prior to making this call.
 If it is not sorted, the results are undefined.  If the array contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.  This method considers all NaN values to be
 equivalent and equal.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(double[] a,
               int fromIndex,
               int toIndex,
               double key)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array of doubles for the specified value using
 the binary search algorithm.
 The range must be sorted
 (as by the sort(double[], int, int) method)
 prior to making this call.
 If it is not sorted, the results are undefined.  If the range contains
 multiple elements with the specified value, there is no guarantee which
 one will be found.  This method considers all NaN values to be
 equivalent and equal.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(float[] a,
               float key)]]></signature>
            <description><![CDATA[Searches the specified array of floats for the specified value using
 the binary search algorithm. The array must be sorted
 (as by the sort(float[]) method) prior to making this call. If
 it is not sorted, the results are undefined. If the array contains
 multiple elements with the specified value, there is no guarantee which
 one will be found. This method considers all NaN values to be
 equivalent and equal.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>. The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key. Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(float[] a,
               int fromIndex,
               int toIndex,
               float key)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array of floats for the specified value using
 the binary search algorithm.
 The range must be sorted
 (as by the sort(float[], int, int) method)
 prior to making this call. If
 it is not sorted, the results are undefined. If the range contains
 multiple elements with the specified value, there is no guarantee which
 one will be found. This method considers all NaN values to be
 equivalent and equal.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>. The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key. Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(Object[] a,
               Object key)]]></signature>
            <description><![CDATA[Searches the specified array for the specified object using the binary
 search algorithm. The array must be sorted into ascending order
 according to the
 natural ordering
 of its elements (as by the
 sort(Object[]) method) prior to making this call.
 If it is not sorted, the results are undefined.
 (If the array contains elements that are not mutually comparable (for
 example, strings and integers), it cannot be sorted according
 to the natural ordering of its elements, hence results are undefined.)
 If the array contains multiple
 elements equal to the specified object, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ClassCastException</a></code> - if the search key is not comparable to the
         elements of the array.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static int binarySearch(Object[] a,
               int fromIndex,
               int toIndex,
               Object key)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array for the specified object using the binary
 search algorithm.
 The range must be sorted into ascending order
 according to the
 natural ordering
 of its elements (as by the
 sort(Object[], int, int) method) prior to making this
 call.  If it is not sorted, the results are undefined.
 (If the range contains elements that are not mutually comparable (for
 example, strings and integers), it cannot be sorted according
 to the natural ordering of its elements, hence results are undefined.)
 If the range contains multiple
 elements equal to the specified object, there is no guarantee which
 one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ClassCastException</a></code> - if the search key is not comparable to the
         elements of the array within the specified range.</dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static <T> int binarySearch(T[] a,
                   T key,
                   Comparator<? super T> c)]]></signature>
            <description><![CDATA[Searches the specified array for the specified object using the binary
 search algorithm.  The array must be sorted into ascending order
 according to the specified comparator (as by the
 sort(T[], Comparator)
 method) prior to making this call.  If it is
 not sorted, the results are undefined.
 If the array contains multiple
 elements equal to the specified object, there is no guarantee which one
 will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>key</code> - the value to be searched for</dd><dd><code>c</code> - the comparator by which the array is ordered.  A
        <tt>null</tt> value indicates that the elements'
        <a href="#">natural ordering</a> should be used.</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element greater than the key, or <tt>a.length</tt> if all
         elements in the array are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ClassCastException</a></code> - if the array contains elements that are not
         <i>mutually comparable</i> using the specified comparator,
         or the search key is not comparable to the
         elements of the array using this comparator.</dd></dl>]]></description>
        </method>
        <method>
            <name>binarySearch</name>
            <signature><![CDATA[public static <T> int binarySearch(T[] a,
                   int fromIndex,
                   int toIndex,
                   T key,
                   Comparator<? super T> c)]]></signature>
            <description><![CDATA[Searches a range of
 the specified array for the specified object using the binary
 search algorithm.
 The range must be sorted into ascending order
 according to the specified comparator (as by the
 sort(T[], int, int, Comparator)
 method) prior to making this call.
 If it is not sorted, the results are undefined.
 If the range contains multiple elements equal to the specified object,
 there is no guarantee which one will be found.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be searched</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
          searched</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be searched</dd><dd><code>key</code> - the value to be searched for</dd><dd><code>c</code> - the comparator by which the array is ordered.  A
        <tt>null</tt> value indicates that the elements'
        <a href="#">natural ordering</a> should be used.</dd>
<dt><span class="strong">Returns:</span></dt><dd>index of the search key, if it is contained in the array
         within the specified range;
         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
         <i>insertion point</i> is defined as the point at which the
         key would be inserted into the array: the index of the first
         element in the range greater than the key,
         or <tt>toIndex</tt> if all
         elements in the range are less than the specified key.  Note
         that this guarantees that the return value will be >= 0 if
         and only if the key is found.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ClassCastException</a></code> - if the range contains elements that are not
         <i>mutually comparable</i> using the specified comparator,
         or the search key is not comparable to the
         elements in the range using this comparator.</dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <code>fromIndex > toIndex</code></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex < 0 or toIndex > a.length</code></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(long[] a,
             long[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of longs are
 equal to one another.  Two arrays are considered equal if both
 arrays contain the same number of elements, and all corresponding pairs
 of elements in the two arrays are equal.  In other words, two arrays
 are equal if they contain the same elements in the same order.  Also,
 two array references are considered equal if both are null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(int[] a,
             int[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of ints are
 equal to one another.  Two arrays are considered equal if both
 arrays contain the same number of elements, and all corresponding pairs
 of elements in the two arrays are equal.  In other words, two arrays
 are equal if they contain the same elements in the same order.  Also,
 two array references are considered equal if both are null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(short[] a,
             short[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of shorts are
 equal to one another.  Two arrays are considered equal if both
 arrays contain the same number of elements, and all corresponding pairs
 of elements in the two arrays are equal.  In other words, two arrays
 are equal if they contain the same elements in the same order.  Also,
 two array references are considered equal if both are null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(char[] a,
             char[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of chars are
 equal to one another.  Two arrays are considered equal if both
 arrays contain the same number of elements, and all corresponding pairs
 of elements in the two arrays are equal.  In other words, two arrays
 are equal if they contain the same elements in the same order.  Also,
 two array references are considered equal if both are null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(byte[] a,
             byte[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of bytes are
 equal to one another.  Two arrays are considered equal if both
 arrays contain the same number of elements, and all corresponding pairs
 of elements in the two arrays are equal.  In other words, two arrays
 are equal if they contain the same elements in the same order.  Also,
 two array references are considered equal if both are null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(boolean[] a,
             boolean[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of booleans are
 equal to one another.  Two arrays are considered equal if both
 arrays contain the same number of elements, and all corresponding pairs
 of elements in the two arrays are equal.  In other words, two arrays
 are equal if they contain the same elements in the same order.  Also,
 two array references are considered equal if both are null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(double[] a,
             double[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of doubles are
 equal to one another.  Two arrays are considered equal if both
 arrays contain the same number of elements, and all corresponding pairs
 of elements in the two arrays are equal.  In other words, two arrays
 are equal if they contain the same elements in the same order.  Also,
 two array references are considered equal if both are null.

 Two doubles d1 and d2 are considered equal if:
     new Double(d1).equals(new Double(d2))
 (Unlike the == operator, this method considers
 NaN equals to itself, and 0.0d unequal to -0.0d.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd><dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>Double.equals(Object)</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(float[] a,
             float[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of floats are
 equal to one another.  Two arrays are considered equal if both
 arrays contain the same number of elements, and all corresponding pairs
 of elements in the two arrays are equal.  In other words, two arrays
 are equal if they contain the same elements in the same order.  Also,
 two array references are considered equal if both are null.

 Two floats f1 and f2 are considered equal if:
     new Float(f1).equals(new Float(f2))
 (Unlike the == operator, this method considers
 NaN equals to itself, and 0.0f unequal to -0.0f.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd><dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>Float.equals(Object)</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>equals</name>
            <signature><![CDATA[public static boolean equals(Object[] a,
             Object[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays of Objects are
 equal to one another.  The two arrays are considered equal if
 both arrays contain the same number of elements, and all corresponding
 pairs of elements in the two arrays are equal.  Two objects e1
 and e2 are considered equal if (e1==null ? e2==null
 : e1.equals(e2)).  In other words, the two arrays are equal if
 they contain the same elements in the same order.  Also, two array
 references are considered equal if both are null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(long[] a,
        long val)]]></signature>
            <description><![CDATA[Assigns the specified long value to each element of the specified array
 of longs.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(long[] a,
        int fromIndex,
        int toIndex,
        long val)]]></signature>
            <description><![CDATA[Assigns the specified long value to each element of the specified
 range of the specified array of longs.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(int[] a,
        int val)]]></signature>
            <description><![CDATA[Assigns the specified int value to each element of the specified array
 of ints.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(int[] a,
        int fromIndex,
        int toIndex,
        int val)]]></signature>
            <description><![CDATA[Assigns the specified int value to each element of the specified
 range of the specified array of ints.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(short[] a,
        short val)]]></signature>
            <description><![CDATA[Assigns the specified short value to each element of the specified array
 of shorts.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(short[] a,
        int fromIndex,
        int toIndex,
        short val)]]></signature>
            <description><![CDATA[Assigns the specified short value to each element of the specified
 range of the specified array of shorts.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(char[] a,
        char val)]]></signature>
            <description><![CDATA[Assigns the specified char value to each element of the specified array
 of chars.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(char[] a,
        int fromIndex,
        int toIndex,
        char val)]]></signature>
            <description><![CDATA[Assigns the specified char value to each element of the specified
 range of the specified array of chars.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(byte[] a,
        byte val)]]></signature>
            <description><![CDATA[Assigns the specified byte value to each element of the specified array
 of bytes.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(byte[] a,
        int fromIndex,
        int toIndex,
        byte val)]]></signature>
            <description><![CDATA[Assigns the specified byte value to each element of the specified
 range of the specified array of bytes.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(boolean[] a,
        boolean val)]]></signature>
            <description><![CDATA[Assigns the specified boolean value to each element of the specified
 array of booleans.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(boolean[] a,
        int fromIndex,
        int toIndex,
        boolean val)]]></signature>
            <description><![CDATA[Assigns the specified boolean value to each element of the specified
 range of the specified array of booleans.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(double[] a,
        double val)]]></signature>
            <description><![CDATA[Assigns the specified double value to each element of the specified
 array of doubles.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(double[] a,
        int fromIndex,
        int toIndex,
        double val)]]></signature>
            <description><![CDATA[Assigns the specified double value to each element of the specified
 range of the specified array of doubles.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(float[] a,
        float val)]]></signature>
            <description><![CDATA[Assigns the specified float value to each element of the specified array
 of floats.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(float[] a,
        int fromIndex,
        int toIndex,
        float val)]]></signature>
            <description><![CDATA[Assigns the specified float value to each element of the specified
 range of the specified array of floats.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(Object[] a,
        Object val)]]></signature>
            <description><![CDATA[Assigns the specified Object reference to each element of the specified
 array of Objects.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayStoreException</a></code> - if the specified value is not of a
         runtime type that can be stored in the specified array</dd></dl>]]></description>
        </method>
        <method>
            <name>fill</name>
            <signature><![CDATA[public static void fill(Object[] a,
        int fromIndex,
        int toIndex,
        Object val)]]></signature>
            <description><![CDATA[Assigns the specified Object reference to each element of the specified
 range of the specified array of Objects.  The range to be filled
 extends from index fromIndex, inclusive, to index
 toIndex, exclusive.  (If fromIndex==toIndex, the
 range to be filled is empty.)<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array to be filled</dd><dd><code>fromIndex</code> - the index of the first element (inclusive) to be
        filled with the specified value</dd><dd><code>toIndex</code> - the index of the last element (exclusive) to be
        filled with the specified value</dd><dd><code>val</code> - the value to be stored in all elements of the array</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>fromIndex > toIndex</tt></dd>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <tt>fromIndex < 0</tt> or
         <tt>toIndex > a.length</tt></dd>
<dd><code><a href="#">ArrayStoreException</a></code> - if the specified value is not of a
         runtime type that can be stored in the specified array</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static <T> T[] copyOf(T[] original,
             int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with nulls (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain null.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.
 The resulting array is of exactly the same class as the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with nulls
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static <T,U> T[] copyOf(U[] original,
               int newLength,
               Class<? extends T[]> newType)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with nulls (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain null.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.
 The resulting array is of the class newType.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd><dd><code>newType</code> - the class of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with nulls
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd>
<dd><code><a href="#">ArrayStoreException</a></code> - if an element copied from
     <tt>original</tt> is not of a runtime type that can be stored in
     an array of class <tt>newType</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static byte[] copyOf(byte[] original,
            int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with zeros (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain (byte)0.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with zeros
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static short[] copyOf(short[] original,
             int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with zeros (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain (short)0.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with zeros
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static int[] copyOf(int[] original,
           int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with zeros (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain 0.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with zeros
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static long[] copyOf(long[] original,
            int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with zeros (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain 0L.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with zeros
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static char[] copyOf(char[] original,
            int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with null characters (if necessary)
 so the copy has the specified length.  For all indices that are valid
 in both the original array and the copy, the two arrays will contain
 identical values.  For any indices that are valid in the copy but not
 the original, the copy will contain '\\u000'.  Such indices
 will exist if and only if the specified length is greater than that of
 the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with null characters
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static float[] copyOf(float[] original,
             int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with zeros (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain 0f.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with zeros
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static double[] copyOf(double[] original,
              int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with zeros (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain 0d.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with zeros
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOf</name>
            <signature><![CDATA[public static boolean[] copyOf(boolean[] original,
               int newLength)]]></signature>
            <description><![CDATA[Copies the specified array, truncating or padding with false (if necessary)
 so the copy has the specified length.  For all indices that are
 valid in both the original array and the copy, the two arrays will
 contain identical values.  For any indices that are valid in the
 copy but not the original, the copy will contain false.
 Such indices will exist if and only if the specified length
 is greater than that of the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array to be copied</dd><dd><code>newLength</code> - the length of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a copy of the original array, truncated or padded with false elements
     to obtain the specified length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">NegativeArraySizeException</a></code> - if <tt>newLength</tt> is negative</dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static <T> T[] copyOfRange(T[] original,
                  int from,
                  int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 null is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.
 
 The resulting array is of exactly the same class as the original array.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with nulls to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static <T,U> T[] copyOfRange(U[] original,
                    int from,
                    int to,
                    Class<? extends T[]> newType)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 null is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.
 The resulting array is of the class newType.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd><dd><code>newType</code> - the class of the copy to be returned</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with nulls to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd>
<dd><code><a href="#">ArrayStoreException</a></code> - if an element copied from
     <tt>original</tt> is not of a runtime type that can be stored in
     an array of class <tt>newType</tt>.</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static byte[] copyOfRange(byte[] original,
                 int from,
                 int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 (byte)0 is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with zeros to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static short[] copyOfRange(short[] original,
                  int from,
                  int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 (short)0 is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with zeros to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static int[] copyOfRange(int[] original,
                int from,
                int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 0 is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with zeros to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static long[] copyOfRange(long[] original,
                 int from,
                 int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 0L is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with zeros to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static char[] copyOfRange(char[] original,
                 int from,
                 int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 '\\u000' is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with null characters to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static float[] copyOfRange(float[] original,
                  int from,
                  int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 0f is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with zeros to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static double[] copyOfRange(double[] original,
                   int from,
                   int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 0d is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with zeros to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>copyOfRange</name>
            <signature><![CDATA[public static boolean[] copyOfRange(boolean[] original,
                    int from,
                    int to)]]></signature>
            <description><![CDATA[Copies the specified range of the specified array into a new array.
 The initial index of the range (from) must lie between zero
 and original.length, inclusive.  The value at
 original[from] is placed into the initial element of the copy
 (unless from == original.length or from == to).
 Values from subsequent elements in the original array are placed into
 subsequent elements in the copy.  The final index of the range
 (to), which must be greater than or equal to from,
 may be greater than original.length, in which case
 false is placed in all elements of the copy whose index is
 greater than or equal to original.length - from.  The length
 of the returned array will be to - from.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>original</code> - the array from which a range is to be copied</dd><dd><code>from</code> - the initial index of the range to be copied, inclusive</dd><dd><code>to</code> - the final index of the range to be copied, exclusive.
     (This index may lie outside the array.)</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new array containing the specified range from the original array,
     truncated or padded with false elements to obtain the required length</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="#">ArrayIndexOutOfBoundsException</a></code> - if <code>from < 0</code>
     or <code>from > original.length</code></dd>
<dd><code><a href="#">IllegalArgumentException</a></code> - if <tt>from > to</tt></dd>
<dd><code><a href="#">NullPointerException</a></code> - if <tt>original</tt> is null</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6</dd></dl>]]></description>
        </method>
        <method>
            <name>asList</name>
            <signature><![CDATA[@SafeVarargs
public static <T> List<T> asList(T... a)]]></signature>
            <description><![CDATA[Returns a fixed-size list backed by the specified array.  (Changes to
 the returned list "write through" to the array.)  This method acts
 as bridge between array-based and collection-based APIs, in
 combination with Collection.toArray().  The returned list is
 serializable and implements RandomAccess.

 This method also provides a convenient way to create a fixed-size
 list initialized to contain several elements:
 
     List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array by which the list will be backed</dd>
<dt><span class="strong">Returns:</span></dt><dd>a list view of the specified array</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(long[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.
 For any two long arrays a and b
 such that Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is the same value that would be
 obtained by invoking the hashCode
 method on a List containing a sequence of Long
 instances representing the elements of a in the same order.
 If a is null, this method returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose hash value to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(int[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.
 For any two non-null int arrays a and b
 such that Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is the same value that would be
 obtained by invoking the hashCode
 method on a List containing a sequence of Integer
 instances representing the elements of a in the same order.
 If a is null, this method returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose hash value to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(short[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.
 For any two short arrays a and b
 such that Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is the same value that would be
 obtained by invoking the hashCode
 method on a List containing a sequence of Short
 instances representing the elements of a in the same order.
 If a is null, this method returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose hash value to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(char[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.
 For any two char arrays a and b
 such that Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is the same value that would be
 obtained by invoking the hashCode
 method on a List containing a sequence of Character
 instances representing the elements of a in the same order.
 If a is null, this method returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose hash value to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(byte[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.
 For any two byte arrays a and b
 such that Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is the same value that would be
 obtained by invoking the hashCode
 method on a List containing a sequence of Byte
 instances representing the elements of a in the same order.
 If a is null, this method returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose hash value to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(boolean[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.
 For any two boolean arrays a and b
 such that Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is the same value that would be
 obtained by invoking the hashCode
 method on a List containing a sequence of Boolean
 instances representing the elements of a in the same order.
 If a is null, this method returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose hash value to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(float[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.
 For any two float arrays a and b
 such that Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is the same value that would be
 obtained by invoking the hashCode
 method on a List containing a sequence of Float
 instances representing the elements of a in the same order.
 If a is null, this method returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose hash value to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(double[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.
 For any two double arrays a and b
 such that Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is the same value that would be
 obtained by invoking the hashCode
 method on a List containing a sequence of Double
 instances representing the elements of a in the same order.
 If a is null, this method returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose hash value to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>hashCode</name>
            <signature><![CDATA[public static int hashCode(Object[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the contents of the specified array.  If
 the array contains other arrays as elements, the hash code is based on
 their identities rather than their contents.  It is therefore
 acceptable to invoke this method on an array that contains itself as an
 element,  either directly or indirectly through one or more levels of
 arrays.

 For any two arrays a and b such that
 Arrays.equals(a, b), it is also the case that
 Arrays.hashCode(a) == Arrays.hashCode(b).

 The value returned by this method is equal to the value that would
 be returned by Arrays.asList(a).hashCode(), unless a
 is null, in which case 0 is returned.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose content-based hash code to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>deepHashCode(Object[])</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>deepHashCode</name>
            <signature><![CDATA[public static int deepHashCode(Object[] a)]]></signature>
            <description><![CDATA[Returns a hash code based on the "deep contents" of the specified
 array.  If the array contains other arrays as elements, the
 hash code is based on their contents and so on, ad infinitum.
 It is therefore unacceptable to invoke this method on an array that
 contains itself as an element, either directly or indirectly through
 one or more levels of arrays.  The behavior of such an invocation is
 undefined.

 For any two arrays a and b such that
 Arrays.deepEquals(a, b), it is also the case that
 Arrays.deepHashCode(a) == Arrays.deepHashCode(b).

 The computation of the value returned by this method is similar to
 that of the value returned by List.hashCode() on a list
 containing the same elements as a in the same order, with one
 difference: If an element e of a is itself an array,
 its hash code is computed not by calling e.hashCode(), but as
 by calling the appropriate overloading of Arrays.hashCode(e)
 if e is an array of a primitive type, or as by calling
 Arrays.deepHashCode(e) recursively if e is an array
 of a reference type.  If a is null, this method
 returns 0.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose deep-content-based hash code to compute</dd>
<dt><span class="strong">Returns:</span></dt><dd>a deep-content-based hash code for <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>hashCode(Object[])</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>deepEquals</name>
            <signature><![CDATA[public static boolean deepEquals(Object[] a1,
                 Object[] a2)]]></signature>
            <description><![CDATA[Returns true if the two specified arrays are deeply
 equal to one another.  Unlike the equals(Object[],Object[])
 method, this method is appropriate for use with nested arrays of
 arbitrary depth.

 Two array references are considered deeply equal if both
 are null, or if they refer to arrays that contain the same
 number of elements and all corresponding pairs of elements in the two
 arrays are deeply equal.

 Two possibly null elements e1 and e2 are
 deeply equal if any of the following conditions hold:
 
     e1 and e2 are both arrays of object reference
         types, and Arrays.deepEquals(e1, e2) would return true
     e1 and e2 are arrays of the same primitive
         type, and the appropriate overloading of
         Arrays.equals(e1, e2) would return true.
     e1 == e2
     e1.equals(e2) would return true.
 
 Note that this definition permits null elements at any depth.

 If either of the specified arrays contain themselves as elements
 either directly or indirectly through one or more levels of arrays,
 the behavior of this method is undefined.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a1</code> - one array to be tested for equality</dd><dd><code>a2</code> - the other array to be tested for equality</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the two arrays are equal</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>equals(Object[],Object[])</code></a>, 
<a href="#"><code>Objects.deepEquals(Object, Object)</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(long[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
 enclosed in square brackets ("[]").  Adjacent elements are
 separated by the characters ", " (a comma followed by a
 space).  Elements are converted to strings as by
 String.valueOf(long).  Returns "null" if a
 is null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(int[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
 enclosed in square brackets ("[]").  Adjacent elements are
 separated by the characters ", " (a comma followed by a
 space).  Elements are converted to strings as by
 String.valueOf(int).  Returns "null" if a is
 null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(short[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
 enclosed in square brackets ("[]").  Adjacent elements are
 separated by the characters ", " (a comma followed by a
 space).  Elements are converted to strings as by
 String.valueOf(short).  Returns "null" if a
 is null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(char[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
 enclosed in square brackets ("[]").  Adjacent elements are
 separated by the characters ", " (a comma followed by a
 space).  Elements are converted to strings as by
 String.valueOf(char).  Returns "null" if a
 is null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(byte[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
 enclosed in square brackets ("[]").  Adjacent elements
 are separated by the characters ", " (a comma followed
 by a space).  Elements are converted to strings as by
 String.valueOf(byte).  Returns "null" if
 a is null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(boolean[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
 enclosed in square brackets ("[]").  Adjacent elements are
 separated by the characters ", " (a comma followed by a
 space).  Elements are converted to strings as by
 String.valueOf(boolean).  Returns "null" if
 a is null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(float[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
 enclosed in square brackets ("[]").  Adjacent elements are
 separated by the characters ", " (a comma followed by a
 space).  Elements are converted to strings as by
 String.valueOf(float).  Returns "null" if a
 is null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(double[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
 enclosed in square brackets ("[]").  Adjacent elements are
 separated by the characters ", " (a comma followed by a
 space).  Elements are converted to strings as by
 String.valueOf(double).  Returns "null" if a
 is null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd></dl>]]></description>
        </method>
        <method>
            <name>toString</name>
            <signature><![CDATA[public static String toString(Object[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the contents of the specified array.
 If the array contains other arrays as elements, they are converted to
 strings by the Object.toString() method inherited from
 Object, which describes their identities rather than
 their contents.

 The value returned by this method is equal to the value that would
 be returned by Arrays.asList(a).toString(), unless a
 is null, in which case "null" is returned.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>deepToString(Object[])</code></a></dd></dl>]]></description>
        </method>
        <method>
            <name>deepToString</name>
            <signature><![CDATA[public static String deepToString(Object[] a)]]></signature>
            <description><![CDATA[Returns a string representation of the "deep contents" of the specified
 array.  If the array contains other arrays as elements, the string
 representation contains their contents and so on.  This method is
 designed for converting multidimensional arrays to strings.

 The string representation consists of a list of the array's
 elements, enclosed in square brackets ("[]").  Adjacent
 elements are separated by the characters ", " (a comma
 followed by a space).  Elements are converted to strings as by
 String.valueOf(Object), unless they are themselves
 arrays.

 If an element e is an array of a primitive type, it is
 converted to a string as by invoking the appropriate overloading of
 Arrays.toString(e).  If an element e is an array of a
 reference type, it is converted to a string as by invoking
 this method recursively.

 To avoid infinite recursion, if the specified array contains itself
 as an element, or contains an indirect reference to itself through one
 or more levels of arrays, the self-reference is converted to the string
 "[...]".  For example, an array containing only a reference
 to itself would be rendered as "[[...]]".

 This method returns "null" if the specified array
 is null.<dl><dt><span class="strong">Parameters:</span></dt><dd><code>a</code> - the array whose string representation to return</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string representation of <tt>a</tt></dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="#"><code>toString(Object[])</code></a></dd></dl>]]></description>
        </method>
    </methods>
</Root>
