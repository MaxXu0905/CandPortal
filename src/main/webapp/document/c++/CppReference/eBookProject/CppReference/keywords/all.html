<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0045)http://www.cppreference.com/keywords/all.html -->
<HTML><HEAD><TITLE>C/C++ Keywords</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2900.2995" name=GENERATOR><LINK 
href="all.files/cppreference.css" type=text/css rel=stylesheet></HEAD>
<BODY>
<TABLE>
  <TBODY>
  <TR>
    <TD>
      <DIV class=body-content>
      <DIV class=header-box><A 
      href="../index.html">cppreference.com</A> &gt; <A 
      href="../keywords/index.html">C/C++ Keywords</A> 
      </DIV>
      <DIV class=name-format>asm </DIV>
      <DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  asm( "instruction" );
</PRE>
      <P>The asm command allows you to insert assembly language commands 
      directly into your code. Various different compilers allow differing forms 
      for this command, such as</P><PRE class=example-code>   asm {
     instruction-sequence
   }            
</PRE>
      <P>or</P><PRE class=example-code>   asm( instruction );          
</PRE></DIV></TD></TR></TBODY></TABLE>
<HR>

<DIV class=name-format>auto </DIV>
<P>The keyword auto is used to declare local variables, and is purely 
optional.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/register.html">register</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>bool </DIV>
<P>The keyword bool is used to declare Boolean logic variables; that is, 
variables which can be either true or false.</P>
<P>For example, the following code declares a boolean variable called 
<EM>done</EM>, initializes it to false, and then loops until that variable is 
set to true.</P><PRE class=example-code>   bool done = false;
   while( !done ) {
   ...
   }            
</PRE>
<P>Also see the <A href="../data_types.html">data 
types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/false.html">false</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/long.html">long</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/true.html">true</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>break </DIV>
<P>The break keyword is used to break out of a <A 
href="../keywords/do.html">do</A>, <A 
href="../keywords/for.html">for</A>, or <A 
href="../keywords/while.html">while</A> loop. It is 
also used to finish each clause of a <A 
href="../keywords/switch.html">switch</A> statement, 
keeping the program from "falling through" to the next case in the code. An 
example:</P><PRE class=example-code>   while( x &lt; 100 ) {
     if( x &lt; 0 )
       break;
     cout &lt;&lt; x &lt;&lt; endl;
     x++;
   }            
</PRE>
<P>A given break statement will break out of only the closest loop, no further. 
If you have a triply-nested for loop, for example, you might want to include 
extra logic or a <A 
href="../keywords/goto.html">goto</A> statement to 
break out of the loop.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/continue.html">continue</A><BR><A 
href="../keywords/do.html">do</A><BR><A 
href="../keywords/for.html">for</A><BR><A 
href="../keywords/goto.html">goto</A><BR><A 
href="../keywords/switch.html">switch</A><BR><A 
href="../keywords/while.html">while</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>case </DIV>
<P>The case keyword is used to test a variable against a certain value in a <A 
href="../keywords/switch.html">switch</A> 
statement.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/default.html">default</A><BR><A 
href="../keywords/switch.html">switch</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>catch </DIV>
<P>The catch statement handles exceptions generated by the <A 
href="../keywords/throw.html">throw</A> statement.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/throw.html">throw</A><BR><A 
href="../keywords/try.html">try</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>char </DIV>
<P>The char keyword is used to declare character variables. For more information 
about variable types, see the <A 
href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/long.html">long</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/void.html">void</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>class </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  class class-name : inheritance-list {
  private-members-list;    
  protected:
  protected-members-list;
  public:
  public-members-list;
  } object-list;
</PRE>
<P>The class keyword allows you to create new classes. <EM>class-name</EM> is 
the name of the class that you wish to create, and <EM>inheritance-list</EM> is 
an optional list of classes inherited by the new class. Members of the class are 
private by default, unless listed under either the protected or public labels. 
<EM>object-list</EM> can be used to immediately instantiate one or more 
instances of the class, and is also optional. For example:</P><PRE class=example-code>   class Date {
     int Day;
     int Month;
     int Year;
   public:
     void display();
   };           
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/friend.html">friend</A><BR><A 
href="../keywords/private.html">private</A><BR><A 
href="../keywords/protected.html">protected</A><BR><A 
href="../keywords/public.html">public</A><BR><A 
href="../keywords/struct.html">struct</A><BR><A 
href="../keywords/this.html">this</A><BR><A 
href="../keywords/typename.html">typename</A><BR><A 
href="../keywords/union.html">union</A><BR><A 
href="../keywords/virtual.html">virtual</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>const </DIV>
<P>The const keyword can be used to tell the compiler that a certain variable 
should not be modified once it has been initialized.</P>
<P>It can also be used to declare functions of a class that do not alter any 
class data.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/const_cast.html">const_cast</A><BR><A 
href="../keywords/mutable.html">mutable</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>const_cast </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  const_cast&lt;type&gt; (object);
</PRE>
<P>The const_cast keyword can be used to remove the "const-ness" of some datum. 
The target data type must be the same as the source type, except (of course) 
that the target type doesn't have to be <A 
href="../keywords/const.html">const</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/const.html">const</A><BR><A 
href="../keywords/dynamic_cast.html">dynamic_cast</A><BR><A 
href="../keywords/reinterpret_cast.html">reinterpret_cast</A><BR><A 
href="../keywords/static_cast.html">static_cast</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>continue </DIV>
<P>The continue statement can be used to bypass iterations of a given loop.</P>
<P>For example, the following code will display all of the numbers between 0 and 
20 except 10:</P><PRE class=example-code>   for( int i = 0; i &lt; 21; i++ ) {
     if( i == 10 ) {
       continue;
     }
     cout &lt;&lt; i &lt;&lt; " ";
   }            
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/break.html">break</A><BR><A 
href="../keywords/do.html">do</A><BR><A 
href="../keywords/for.html">for</A><BR><A 
href="../keywords/while.html">while</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>default </DIV>
<P>A default <A href="../keywords/case.html">case</A> 
in the <A href="../keywords/switch.html">switch</A> 
statement.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/case.html">case</A><BR><A 
href="../keywords/switch.html">switch</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>delete </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  delete p;
  delete[] pArray;
</PRE>
<P>The delete operator frees the memory pointed to by <EM>p</EM>. The argument 
should have been previously allocated by a call to <A 
href="../keywords/new.html">new</A>. The second form of 
delete should be used to delete an array.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content>(Standard C Memory) <A 
href="../stdmem/free.html">free</A><BR>(Standard C 
Memory) <A 
href="../stdmem/malloc.html">malloc</A><BR><A 
href="../keywords/new.html">new</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>do </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  do {
  statement-list;
  } while( condition );
</PRE>
<P>The do construct evaluates the given <EM>statement-list</EM> repeatedly, 
until <EM>condition</EM> becomes false. Note that every do loop will evaluate 
its statement list at least once, because the terminating condition is tested at 
the end of the loop.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/break.html">break</A><BR><A 
href="../keywords/continue.html">continue</A><BR><A 
href="../keywords/for.html">for</A><BR><A 
href="../keywords/while.html">while</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>double </DIV>
<P>The double keyword is used to declare double precision floating-point 
variables. Also see the <A 
href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/long.html">long</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/void.html">void</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>dynamic_cast </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  dynamic_cast&lt;type&gt; (object);
</PRE>
<P>The dynamic_cast keyword casts a datum from one type to another, performing a 
runtime check to ensure the validity of the cast. If you attempt to cast between 
incompatible types, the result of the cast will be <STRONG>NULL</STRONG>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/const_cast.html">const_cast</A><BR><A 
href="../keywords/reinterpret_cast.html">reinterpret_cast</A><BR><A 
href="../keywords/static_cast.html">static_cast</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>else </DIV>
<P>The else keyword is used as an alternative case for the <A 
href="../keywords/if.html">if</A> statement.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/if.html">if</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>enum </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  enum name {name-list} var-list;
</PRE>
<P>The enum keyword is used to create an enumerated type named name that 
consists of the elements in <EM>name-list</EM>. The <EM>var-list</EM> argument 
is optional, and can be used to create instances of the type along with the 
declaration. For example, the following code creates an enumerated type for 
colors:</P>
<DIV class=related-examples><PRE class=example-code>   enum ColorT {red, orange, yellow, green, blue, indigo, violet};
   ...
   ColorT c1 = indigo;
   if( c1 == indigo ) {
     cout &lt;&lt; "c1 is indigo" &lt;&lt; endl;
   }            
</PRE></DIV>
<P>In the above example, the effect of the enumeration is to introduce several 
new constants named <EM>red</EM>, <EM>orange</EM>, <EM>yellow</EM>, etc. By 
default, these constants are assigned consecutive integer values starting at 
zero. You can change the values of those constants, as shown by the next 
example:</P>
<DIV class=related-examples><PRE class=example-code>   enum ColorT { red = 10, blue = 15, green };
   ...
   ColorT c = green;
   cout &lt;&lt; "c is " &lt;&lt; c &lt;&lt; endl;
</PRE></DIV>
<P>When executed, the above code will display the following output:</P>
<DIV class=related-examples><PRE class=example-code>   c is 16
</PRE></DIV>
<P>Note that the above examples will only work with C++ compilers. If you're 
working in regular C, you will need to specify the <EM>enum</EM> keyword 
whenever you create an instance of an enumerated type: 
<DIV class=related-examples><PRE class=example-code>   enum ColorT { red = 10, blue = 15, green };
   ...
   enum ColorT c = green;   // note the aditional enum keyword
   printf( "c is %d\n", c );
</PRE></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>explicit </DIV>
<P>When a constructor is specified as explicit, no automatic conversion will be 
used with that constructor --it will only be used when an initialization exactly 
matches a call to that constructor.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>export </DIV>
<P>The export keyword is intended to allow definitions of C++ templates to be 
separated from their declarations. While officially part of the C++ standard, 
the export keyword is only supported by a few compilers (such as the Comeau C++ 
compiler) and is not supported by such mainstream compilers as GCC and Visual 
C++. </P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>extern </DIV>
<P>The extern keyword is used to inform the compiler about variables declared 
outside of the current scope. Variables described by extern statements will not 
have any space allocated for them, as they should be properly defined 
elsewhere.</P>
<P>Extern statements are frequently used to allow data to span the scope of 
multiple files.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>false </DIV>
<P>The Boolean value of "false".</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/true.html">true</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>float </DIV>
<P>The float keyword is used to declare floating-point variables. Also see the 
<A href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/long.html">long</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/void.html">void</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>for </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  for( initialization; test-condition; increment ) {
  statement-list;
  }
</PRE>
<P>The for construct is a general looping mechanism consisting of 4 parts:</P>
<OL>
  <LI>the initialization, which consists of 0 or more comma-delimited variable 
  initialization statements 
  <LI>the test-condition, which is evaluated to determine if the execution of 
  the for loop will continue 
  <LI>the increment, which consists of 0 or more comma-delimited statements that 
  increment variables 
  <LI>and the statement-list, which consists of 0 or more statements that will 
  be executed each time the loop is executed. </LI></OL>
<P>For example:</P><PRE class=example-code>   for( int i = 0; i &lt; 10; i++ ) {
     cout &lt;&lt; "i is " &lt;&lt; i &lt;&lt; endl;
   }
   int j, k;
   for( j = 0, k = 10;
        j &lt; k;
        j++, k-- ) {
     cout &lt;&lt; "j is " &lt;&lt; j &lt;&lt; " and k is " &lt;&lt; k &lt;&lt; endl;
   }
   for( ; ; ) {
     // loop forever!
   }            
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/break.html">break</A><BR><A 
href="../keywords/continue.html">continue</A><BR><A 
href="../keywords/do.html">do</A><BR><A 
href="../keywords/if.html">if</A><BR><A 
href="../keywords/while.html">while</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>friend </DIV>
<P>The friend keyword allows classes or functions not normally associated with a 
given class to have access to the private data of that class.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>goto </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  goto labelA;
  ...
  labelA:
</PRE>
<P>The goto statement causes the current thread of execution to jump to the 
specified label. While the use of the goto statement is generally <A 
href="http://www.acm.org/classics/oct95/">considered harmful</A>, it can 
occasionally be useful. For example, it may be cleaner to use a goto to break 
out of a deeply-nested <A 
href="../keywords/for.html">for</A> loop, compared to 
the space and time that extra <A 
href="../keywords/break.html">break</A> logic would 
consume.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/break.html">break</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>if </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  if( conditionA ) {
    statement-listA;
  }
  else if( conditionB ) {
    statement-listB;
  }
  ...
  else {
    statement-listN;
  }
</PRE>
<P>The if construct is a branching mechanism that allows different code to 
execute under different conditions. The conditions are evaluated in order, and 
the statement-list of the first condition to evaluate to true is executed. If no 
conditions evaluate to true and an <A 
href="../keywords/else.html">else</A> statement is 
present, then the statement list within the else block will be executed. All of 
the <A href="../keywords/else.html">else</A> blocks are 
optional.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/else.html">else</A><BR><A 
href="../keywords/for.html">for</A><BR><A 
href="../keywords/switch.html">switch</A><BR><A 
href="../keywords/while.html">while</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>inline </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  inline int functionA( int i ) {
  ...
  }
</PRE>
<P>The inline keyword requests that the compiler expand a given function in 
place, as opposed to inserting a call to that function. Functions that contain 
<A href="../keywords/static.html">static</A> data, 
loops, <A href="../keywords/switch.html">switch</A> 
statements, or recursive calls cannot be inlined. When a function declaration is 
included in a class declaration, the compiler should try to automatically inline 
that function.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>int </DIV>
<P>The int keyword is used to declare integer variables. Also see the <A 
href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/long.html">long</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/void.html">void</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>long </DIV>
<P>The long keyword is a data type modifier that is used to declare long integer 
variables. For more information on long, see the <A 
href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/void.html">void</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>mutable </DIV>
<P>The mutable keyword overrides any enclosing <A 
href="../keywords/const.html">const</A> statement. A 
mutable member of a <A 
href="../keywords/const.html">const</A> object can be 
modified.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/const.html">const</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>namespace </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  namespace name {
  declaration-list;
  }
</PRE>
<P>The namespace keyword allows you to create a new scope. The name is optional, 
and can be omitted to create an unnamed namespace. Once you create a namespace, 
you'll have to refer to it explicitly or use the <A 
href="../keywords/using.html">using</A> keyword.</P>
<DIV class=related-examples-format>Example code: </DIV>
<DIV class=related-examples><PRE class=example-code>   namespace CartoonNameSpace {
     int HomersAge;
     void incrementHomersAge() {
       HomersAge++;
     }
   }
   int main() {
     ...
     CartoonNameSpace::HomersAge = 39;
     CartoonNameSpace::incrementHomersAge();
     cout &lt;&lt; CartoonNameSpace::HomersAge &lt;&lt; endl;
     ...
   }            
</PRE></DIV>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/using.html">using</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>new </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  pointer = new type;
  pointer = new type( initializer );
  pointer = new type[size];
</PRE>
<P>The new operator allocates a new chunk of memory to hold a variable of type 
<EM>type</EM> and returns a pointer to that memory. An optional initializer can 
be used to initialize the memory. Allocating arrays can be accomplished by 
providing a <EM>size</EM> parameter in brackets.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/delete.html">delete</A><BR>(Standard 
C Memory) <A 
href="../stdmem/free.html">free</A><BR>(Standard C 
Memory) <A href="../stdmem/malloc.html">malloc</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>operator </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  return-type class-name::operator#(parameter-list) {
  ...
  }
  return-type operator#(parameter-list) {
  ...
  }
</PRE>
<P>The operator keyword is used to overload operators. The sharp sign (#) listed 
above in the syntax description represents the operator which will be 
overloaded. If part of a class, the <EM>class-name</EM> should be specified. For 
unary operators, <EM>parameter-list</EM> should be empty, and for binary 
operators, <EM>parameter-list</EM> should contain the operand on the right side 
of the operator (the operand on the left side is passed as <A 
href="../keywords/this.html">this</A>).</P>
<P>For the non-member operator overload function, the operand on the left side 
should be passed as the first parameter and the operand on the right side should 
be passed as the second parameter.</P>
<P>You cannot overload the #, ##, ., :, .*, or ? tokens.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/this.html">this</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>private </DIV>
<P>Private data of a class can only be accessed by members of that class, except 
when <A href="../keywords/friend.html">friend</A> is 
used. The <A 
href="../keywords/private.html">private</A> keyword can 
also be used to inherit a base class privately, which causes all <A 
href="../keywords/public.html">public</A> and <A 
href="../keywords/protected.html">protected</A> members 
of the base class to become private members of the derived class.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A><BR><A 
href="../keywords/protected.html">protected</A><BR><A 
href="../keywords/public.html">public</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>protected </DIV>
<P>Protected data are private to their own class but can be inherited by derived 
classes. The protected keyword can also be used as an inheritance specifier, 
which causes all <A 
href="../keywords/public.html">public</A> and protected 
members of the base class to become protected members of the derived class.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A><BR><A 
href="../keywords/private.html">private</A><BR><A 
href="../keywords/public.html">public</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>public </DIV>
<P>Public data in a class are accessible to everyone. The public keyword can 
also be used as an inheritance specifier, which causes all public and <A 
href="../keywords/protected.html">protected</A> members 
of the base class to become public and protected members of the derived 
class.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A><BR><A 
href="../keywords/private.html">private</A><BR><A 
href="../keywords/protected.html">protected</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>register </DIV>
<P>The register keyword requests that a variable be optimized for speed, and 
fell out of common use when computers became better at most code optimizations 
than humans.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/auto.html">auto</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>reinterpret_cast </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  reinterpret_cast&lt;type&gt; (object);
</PRE>
<P>The reinterpret_cast operator changes one data type into another. It should 
be used to cast between incompatible pointer types.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/const_cast.html">const_cast</A><BR><A 
href="../keywords/dynamic_cast.html">dynamic_cast</A><BR><A 
href="../keywords/static_cast.html">static_cast</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>return </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  return;
  return( value );
</PRE>
<P>The return statement causes execution to jump from the current function to 
whatever function called the current function. An optional <EM>value</EM> can be 
returned. A function may have more than one return statement.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>short </DIV>
<P>The short keyword is a data type modifier that is used to declare short 
integer variables. See the <A 
href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/long.html">long</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/void.html">void</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>signed </DIV>
<P>The signed keyword is a data type modifier that is usually used to declare 
signed char variables. See the <A 
href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/long.html">long</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/void.html">void</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>sizeof </DIV>
<P>The sizeof operator is a compile-time operator that returns the size, in 
bytes, of the argument passed to it. For example, the following code uses sizeof 
to display the sizes of a number of variables:</P><PRE class=example-code>  
  struct EmployeeRecord {
    int ID;
    int age;
    double salary;
    EmployeeRecord* boss;
  };

  ...

  cout &lt;&lt; "sizeof(int): " &lt;&lt; sizeof(int) &lt;&lt; endl
       &lt;&lt; "sizeof(float): " &lt;&lt; sizeof(float) &lt;&lt; endl
       &lt;&lt; "sizeof(double): " &lt;&lt; sizeof(double) &lt;&lt; endl
       &lt;&lt; "sizeof(char): " &lt;&lt; sizeof(char) &lt;&lt; endl
       &lt;&lt; "sizeof(EmployeeRecord): " &lt;&lt; sizeof(EmployeeRecord) &lt;&lt; endl;

  int i;
  float f;
  double d;
  char c;
  EmployeeRecord er;

  cout &lt;&lt; "sizeof(i): " &lt;&lt; sizeof(i) &lt;&lt; endl
       &lt;&lt; "sizeof(f): " &lt;&lt; sizeof(f) &lt;&lt; endl
       &lt;&lt; "sizeof(d): " &lt;&lt; sizeof(d) &lt;&lt; endl
       &lt;&lt; "sizeof(c): " &lt;&lt; sizeof(c) &lt;&lt; endl
       &lt;&lt; "sizeof(er): " &lt;&lt; sizeof(er) &lt;&lt; endl;
</PRE>
<P>When run, the above code displays this output:</P><PRE class=example-code>  
  sizeof(int): 4
  sizeof(float): 4
  sizeof(double): 8
  sizeof(char): 1
  sizeof(EmployeeRecord): 20
  sizeof(i): 4
  sizeof(f): 4
  sizeof(d): 8
  sizeof(c): 1
  sizeof(er): 20
</PRE>
<P>Note that sizeof can either take a variable type (such as 
<STRONG>int</STRONG>) or a variable name (such as <STRONG>i</STRONG> in the 
example above).</P>
<P>It is also important to note that the sizes of various types of variables can 
change depending on what system you're on. Check out <A 
href="../data_types.html">a description of the C and 
C++ data types</A> for more information.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../data_types.html">C/C++ Data Types</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>static </DIV>
<P>The static data type modifier is used to create permanent storage for 
variables. Static variables keep their value between function calls. When used 
in a <A href="../keywords/class.html">class</A>, all 
instantiations of that class share one copy of the variable.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>static_cast </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  static_cast&lt;type&gt; (object);
</PRE>
<P>The static_cast keyword can be used for any normal conversion between types. 
No runtime checks are performed.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/const_cast.html">const_cast</A><BR><A 
href="../keywords/dynamic_cast.html">dynamic_cast</A><BR><A 
href="../keywords/reinterpret_cast.html">reinterpret_cast</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>struct </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  struct struct-name : inheritance-list {
  public-members-list;    
  protected:
  protected-members-list;
  private:
  private-members-list;
  } object-list;
</PRE>
<P>Structs are like `classes`, except that by default members of a struct are <A 
href="../keywords/public.html">public</A> rather than 
<A href="../keywords/private.html">private</A>. In C, 
structs can only contain data and are not permitted to have inheritance lists. 
For example:</P><PRE class=example-code>   struct Date {
     int Day;
     int Month;
     int Year;
   };           
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A><BR><A 
href="../keywords/union.html">union</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>switch </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  switch( expression ) {
  case A:
  statement list;
  break;
  case B:
  statement list;
  break;
  ...
  case N:
  statement list;
  break;
  default:
  statement list;
  break;
  }
</PRE>
<P>The switch statement allows you to test an expression for many values, and is 
commonly used as a replacement for multiple <A 
href="../keywords/if.html">if</A>()...<A 
href="../keywords/else.html">else</A> <A 
href="../keywords/if.html">if</A>()...<A 
href="../keywords/else.html">else</A> <A 
href="../keywords/if.html">if</A>()... statements. <A 
href="../keywords/break.html">break</A> statements are 
required between each <A 
href="../keywords/case.html">case</A> statement, 
otherwise execution will "fall-through" to the next <A 
href="../keywords/case.html">case</A> statement. The <A 
href="../keywords/default.html">default</A> case is 
optional. If provided, it will match any case not explicitly covered by the 
preceding cases in the switch statement. For example:</P><PRE class=example-code>   char keystroke = getch();
   switch( keystroke ) {
     case 'a':
     case 'b':
     case 'c':
     case 'd':
       KeyABCDPressed();
       break;
     case 'e':
       KeyEPressed();
       break;
     default:
       UnknownKeyPressed();
       break;
   }            
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/break.html">break</A><BR><A 
href="../keywords/case.html">case</A><BR><A 
href="../keywords/default.html">default</A><BR><A 
href="../keywords/if.html">if</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>template </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  template &lt;class data-type&gt; return-type name( parameter-list ) {
  statement-list;
  }
</PRE>
<P>Templates are used to create generic functions and can operate on data 
without knowing the nature of that data. They accomplish this by using a 
placeholder data-type for which many other <A 
href="../data_types.html">data types</A> can be 
substituted.</P>
<DIV class=related-examples-format>Example code: </DIV>
<DIV class=related-examples>
<P>For example, the following code uses a template to define a generic swap 
function that can swap two variables of any type:</P><PRE class=example-code>   template&lt;class X&gt; void genericSwap( X &amp;a, X &amp;b ) {
     X tmp;             

     tmp = a;
     a = b;
     b = tmp;
   }
   int main(void) {
     ...
     int num1 = 5;
     int num2 = 21;
     cout &lt;&lt; "Before, num1 is " &lt;&lt; num1 &lt;&lt; " and num2 is " &lt;&lt; num2 &lt;&lt; endl;
     genericSwap( num1, num2 );
     cout &lt;&lt; "After, num1 is " &lt;&lt; num1 &lt;&lt; " and num2 is " &lt;&lt; num2 &lt;&lt; endl;
     char c1 = 'a';
     char c2 = 'z';
     cout &lt;&lt; "Before, c1 is " &lt;&lt; c1 &lt;&lt; " and c2 is " &lt;&lt; c2 &lt;&lt; endl;
     genericSwap( c1, c2 );
     cout &lt;&lt; "After, c1 is " &lt;&lt; c1 &lt;&lt; " and c2 is " &lt;&lt; c2 &lt;&lt; endl;
     ...
     return( 0 );
   }            
</PRE></DIV>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/typename.html">typename</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>this </DIV>
<P>The this keyword is a pointer to the current object. All member functions of 
a <A href="../keywords/class.html">class</A> have a 
this pointer.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A><BR><A 
href="../keywords/operator.html">operator</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>throw </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  try {
  statement list;
  }
  catch( typeA arg ) {
  statement list;
  }
  catch( typeB arg ) {
  statement list;
  }
  ...
  catch( typeN arg ) {
  statement list;
  }
</PRE>
<P>The throw statement is part of the C++ mechanism for exception handling. This 
statement, together with the <A 
href="../keywords/try.html">try</A> and <A 
href="../keywords/catch.html">catch</A> statements, the 
C++ exception handling system gives programmers an elegant mechanism for error 
recovery.</P>
<P>You will generally use a <A 
href="../keywords/try.html">try</A> block to execute 
potentially error-prone code. Somewhere in this code, a throw statement can be 
executed, which will cause execution to jump out of the <A 
href="../keywords/try.html">try</A> block and into one 
of the <A href="../keywords/catch.html">catch</A> 
blocks. For example:</P><PRE class=example-code>   try {
     cout &lt;&lt; "Before throwing exception" &lt;&lt; endl;
     throw 42;
     cout &lt;&lt; "Shouldn't ever see this" &lt;&lt; endl;
   }
   catch( int error ) {
     cout &lt;&lt; "Error: caught exception " &lt;&lt; error &lt;&lt; endl;
   }            
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/catch.html">catch</A><BR><A 
href="../keywords/try.html">try</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>true </DIV>
<P>The Boolean value of "true".</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/false.html">false</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>try </DIV>
<P>The try statement attempts to execute exception-generating code. See the <A 
href="../keywords/throw.html">throw</A> statement for 
more details.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/catch.html">catch</A><BR><A 
href="../keywords/throw.html">throw</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>typedef </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  typedef existing-type new-type;
</PRE>
<P>The typedef keyword allows you to create a new type from an existing 
type.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>typeid </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  typeid( object );
</PRE>
<P>The typeid operator returns a reference to a type_info object that describes 
`object`.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>typename </DIV>
<P>The typename keyword can be used to describe an undefined type or in place of 
the <A href="../keywords/class.html">class</A> keyword 
in a <A href="../keywords/template.html">template</A> 
declaration.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A><BR><A 
href="../keywords/template.html">template</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>union </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  union union-name {
  public-members-list;    
  private:
  private-members-list;
  } object-list;
</PRE>
<P>A union is like a <A 
href="../keywords/class.html">class</A>, except that 
all members of a union share the same memory location and are by default <A 
href="../keywords/public.html">public</A> rather than 
<A href="../keywords/private.html">private</A>. For 
example:</P><PRE class=example-code>   union Data {
     int i;
     char c;
   };           
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A><BR><A 
href="../keywords/struct.html">struct</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>unsigned </DIV>
<P>The unsigned keyword is a data type modifier that is usually used to declare 
unsigned <A href="../keywords/int.html">int</A> 
variables. See the <A href="../data_types.html">data 
types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/void.html">void</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>using </DIV>
<P>The using keyword is used to import a <A 
href="../keywords/namespace.html">namespace</A> (or 
parts of a namespace) into the current scope.</P>
<DIV class=related-examples-format>Example code: </DIV>
<DIV class=related-examples>
<P>For example, the following code imports the entire <EM>std</EM> namespace 
into the current scope so that items within that namespace can be used without a 
preceeding "std::".</P><PRE class=example-code> using namespace std;           
</PRE>
<P>Alternatively, the next code snippet just imports a single element of the 
<EM>std</EM> namespace into the current namespace:</P><PRE class=example-code> using std::cout;               
</PRE></DIV>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/namespace.html">namespace</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>virtual </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  virtual return-type name( parameter-list );
  virtual return-type name( parameter-list ) = 0;
</PRE>
<P>The virtual keyword can be used to create virtual functions, which can be 
overridden by derived classes.</P>
<UL>
  <LI>A virtual function indicates that a function can be overridden in a 
  subclass, and that the overridden function will actually be used. 
  <LI>When a base object pointer points to a derived object that contains a 
  virtual function, the decision about which version of that function to call is 
  based on the type of object pointed to by the pointer, and this process 
  happens at runtime. 
  <LI>A base object can point to different derived objects and have different 
  versions of the virtual function run. </LI></UL>
<P>If the function is specified as a pure virtual function (denoted by the = 0), 
it must be overridden by a derived class.</P>
<DIV class=related-examples-format>Example code: </DIV>
<DIV class=related-examples>
<P>For example, the following code snippet shows how a child class can override 
a virtual method of its parent, and how a non-virtual method in the parent 
cannot be overridden:</P><PRE class=example-code>class Base {
public:
 void nonVirtualFunc() {
   cout &lt;&lt; "Base: non-virtual function" &lt;&lt; endl;
 }
 virtual void virtualFunc() {
   cout &lt;&lt; "Base: virtual function" &lt;&lt; endl;
 }
};              

class Child : public Base {
public:
 void nonVirtualFunc() {
   cout &lt;&lt; "Child: non-virtual function" &lt;&lt; endl;
 }
 void virtualFunc() {
   cout &lt;&lt; "Child: virtual function" &lt;&lt; endl;
 }
};              

int main() {
 Base* basePointer = new Child();
 basePointer-&gt;nonVirtualFunc();
 basePointer-&gt;virtualFunc();
 return 0;
}               
</PRE>
<P>When run, the above code displays:</P><PRE class=example-code>Base: non-virtual function
Child: virtual function         
</PRE></DIV>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/class.html">class</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>void </DIV>
<P>The void keyword is used to denote functions that return no value, or generic 
variables which can point to any type of data. Void can also be used to declare 
an empty parameter list. Also see the <A 
href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/long.html">long</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/wchar_t.html">wchar_t</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>volatile </DIV>
<P>The volatile keyword is an implementation-dependent modifier, used when 
declaring variables, which prevents the compiler from optimizing those 
variables. Volatile should be used with variables whose value can change in 
unexpected ways (i.e. through an interrupt), which could conflict with 
optimizations that the compiler might perform.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>wchar_t </DIV>
<P>The keyword wchar_t is used to declare wide character variables. Also see the 
<A href="../data_types.html">data types</A> page.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/bool.html">bool</A><BR><A 
href="../keywords/char.html">char</A><BR><A 
href="../keywords/double.html">double</A><BR><A 
href="../keywords/float.html">float</A><BR><A 
href="../keywords/int.html">int</A><BR><A 
href="../keywords/short.html">short</A><BR><A 
href="../keywords/signed.html">signed</A><BR><A 
href="../keywords/unsigned.html">unsigned</A><BR><A 
href="../keywords/void.html">void</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>while </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  while( condition ) {
  statement-list;
  }
</PRE>
<P>The while keyword is used as a looping construct that will evaluate the 
<EM>statement-list</EM> as long as <EM>condition</EM> is true. Note that if the 
<EM>condition</EM> starts off as false, the <EM>statement-list</EM> will never 
be executed. (You can use a <A 
href="../keywords/do.html">do</A> loop to guarantee 
that the statement-list will be executed at least once.) For example:</P><PRE class=example-code>   bool done = false;
   while( !done ) {
     ProcessData();
     if( StopLooping() ) {
       done = true;
     }
   }            
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../keywords/break.html">break</A><BR><A 
href="../keywords/continue.html">continue</A><BR><A 
href="../keywords/do.html">do</A><BR><A 
href="../keywords/for.html">for</A><BR><A 
href="../keywords/if.html">if</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>
</BODY></HTML>
