<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0043)http://www.cppreference.com/cppmap/all.html -->
<HTML><HEAD><TITLE>C++ Maps</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2900.2995" name=GENERATOR><LINK 
href="all.files/cppreference.css" type=text/css rel=stylesheet></HEAD>
<BODY>
<TABLE>
  <TBODY>
  <TR>
    <TD>
      <DIV class=body-content>
      <DIV class=header-box><A 
      href="../index.html">cppreference.com</A> &gt; <A 
      href="../cppmap/index.html">C++ Maps</A> </DIV>
      <DIV class=name-format>begin </DIV>
      <DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  iterator begin();
  const_iterator begin() const;
</PRE>
      <P>The function begin() returns an iterator to the first element of the 
      map. begin() should run in <A 
      href="../complexity.html">constant time</A>.</P>
      <P>For example, the following code uses begin() to initialize an iterator 
      that is used to traverse a list:</P><PRE class=example-code>   // Create a list of characters
   list&lt;char&gt; charList;
   for( int i=0; i &lt; 10; i++ ) {
     charList.push_front( i + 65 );
   }
   // Display the list
   list&lt;char&gt;::iterator theIterator;
   for( theIterator = charList.begin(); theIterator != charList.end(); theIterator++ ) {
     cout &lt;&lt; *theIterator;
   }            
</PRE>
      <DIV class=related-name-format>Related topics: </DIV>
      <DIV class=related-content><A 
      href="../cppmap/end.html">end</A><BR><A 
      href="../cppmap/rbegin.html">rbegin</A><BR><A 
      href="../cppmap/rend.html">rend</A> 
    </DIV></DIV></TD></TR></TBODY></TABLE>
<HR>

<DIV class=name-format>clear </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  void clear();
</PRE>
<P>The function clear() deletes all of the elements in the map. clear() runs in 
<A href="../complexity.html">linear time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content>(C++ Lists) <A 
href="../cpplist/erase.html">erase</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>count </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  <STRONG>size_type</STRONG> count( const <A href="../containers.html">key_type</A>&amp; key );
</PRE>
<P>The function count() returns the number of occurrences of <EM>key</EM> in the 
map.</P>
<P>count() should run in <A 
href="../complexity.html">logarithmic time</A>.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>empty </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  bool empty() const;
</PRE>
<P>The empty() function returns true if the map has no elements, false 
otherwise.</P>
<P>For example, the following code uses empty() as the stopping condition on a 
<A href="../keywords/while.html">while</A> loop to 
clear a map and display its contents in order:</P><PRE class=example-code>  struct strCmp {
    bool operator()( const char* s1, const char* s2 ) const {
      return strcmp( s1, s2 ) &lt; 0;
    }
  };

  ...

  map&lt;const char*, int, strCmp&gt; ages;
  ages["Homer"] = 38;
  ages["Marge"] = 37;
  ages["Lisa"] = 8;
  ages["Maggie"] = 1;
  ages["Bart"] = 11;

  while( !ages.empty() ) {
    cout &lt;&lt; "Erasing: " &lt;&lt; (*ages.begin()).first &lt;&lt; ", " &lt;&lt; (*ages.begin()).second &lt;&lt; endl;
    ages.erase( ages.begin() );
  }
</PRE>
<P>When run, the above code displays:</P><PRE class=example-code>  Erasing: Bart, 11
  Erasing: Homer, 38
  Erasing: Lisa, 8
  Erasing: Maggie, 1
  Erasing: Marge, 37
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/begin.html">begin</A><BR><A 
href="../cppmap/erase.html">erase</A><BR><A 
href="../cppmap/size.html">size</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>end </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  iterator end();
  const_iterator end() const;
</PRE>
<P>The end() function returns an iterator just past the end of the map.</P>
<P>Note that before you can access the last element of the map using an iterator 
that you get from a call to end(), you'll have to decrement the iterator 
first.</P>
<P>For example, the following code uses <A 
href="../cppmap/begin.html">begin</A>() and end() to 
iterate through all of the members of a vector:</P><PRE class=example-code> vector&lt;int&gt; v1( 5, 789 );
 vector&lt;int&gt;::iterator it;
 for( it = v1.begin(); it != v1.end(); it++ ) {
   cout &lt;&lt; *it &lt;&lt; endl;
 }              
</PRE>
<P>The iterator is initialized with a call to <A 
href="../cppmap/begin.html">begin</A>(). After the body 
of the loop has been executed, the iterator is incremented and tested to see if 
it is equal to the result of calling end(). Since end() returns an iterator 
pointing to an element just after the last element of the vector, the loop will 
only stop once all of the elements of the vector have been displayed.</P>
<P>end() runs in <A href="../complexity.html">constant 
time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/begin.html">begin</A><BR><A 
href="../cppmap/rbegin.html">rbegin</A><BR><A 
href="../cppmap/rend.html">rend</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>equal_range </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  pair&lt;iterator, iterator&gt; equal_range( const <A href="../containers.html">key_type</A>&amp; key );
</PRE>
<P>The function equal_range() returns two iterators - one to the first element 
that contains <EM>key</EM>, another to a point just after the last element that 
contains <EM>key</EM>.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>erase </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  void erase( iterator pos );
  void erase( iterator start, iterator end );
  <STRONG>size_type</STRONG> erase( const <A href="../containers.html">key_type</A>&amp; key );
</PRE>
<P>The erase function() either erases the element at <EM>pos</EM>, erases the 
elements between <EM>start</EM> and <EM>end</EM>, or erases all elements that 
have the value of <EM>key</EM>.</P>
<P>For example, the following code uses erase() in a <A 
href="../keywords/while.html">while</A> loop to 
incrementally clear a map and display its contents in order:</P><PRE class=example-code>  struct strCmp {
    bool operator()( const char* s1, const char* s2 ) const {
      return strcmp( s1, s2 ) &lt; 0;
    }
  };

  ...

  map&lt;const char*, int, strCmp&gt; ages;
  ages["Homer"] = 38;
  ages["Marge"] = 37;
  ages["Lisa"] = 8;
  ages["Maggie"] = 1;
  ages["Bart"] = 11;

  while( !ages.empty() ) {
    cout &lt;&lt; "Erasing: " &lt;&lt; (*ages.begin()).first &lt;&lt; ", " &lt;&lt; (*ages.begin()).second &lt;&lt; endl;
    ages.erase( ages.begin() );
  }
</PRE>
<P>When run, the above code displays:</P><PRE class=example-code>  Erasing: Bart, 11
  Erasing: Homer, 38
  Erasing: Lisa, 8
  Erasing: Maggie, 1
  Erasing: Marge, 37
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/begin.html">begin</A><BR><A 
href="../cppmap/empty.html">empty</A><BR><A 
href="../cppmap/size.html">size</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>find </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  iterator find( const <A href="../containers.html">key_type</A>&amp; key );
</PRE>
<P>The find() function returns an iterator to <EM>key</EM>, or an iterator to 
the end of the map if <EM>key</EM> is not found.</P>
<P>find() runs in <A 
href="../complexity.html">logarithmic time</A>.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>insert </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  iterator insert( iterator i, const <A href="../containers.html">TYPE</A>&amp; pair );
  void insert( <A href="../iterators.html">input_iterator</A> start, <A href="../iterators.html">input_iterator</A> end );
  pair&lt;iterator,bool&gt; insert( const <A href="../containers.html">TYPE</A>&amp; pair );
</PRE>
<P>The function insert() either:</P>
<UL>
  <LI>inserts <EM>pair</EM> after the element at <EM>pos</EM> (where 
  <EM>pos</EM> is really just a suggestion as to where <EM>pair</EM> should go, 
  since sets and maps are ordered), and returns an iterator to that element. 
  <LI>inserts a range of elements from <EM>start</EM> to <EM>end</EM>. 
  <LI>inserts <EM>pair</EM>, but only if <EM>pair</EM> doesn't already exist. 
  The return value is an iterator to the element inserted, and a boolean 
  describing whether an insertion took place. </LI></UL>
<P>For example, the following code uses the insert() function to insert some 
data into a map:</P><PRE class=example-code>  map&lt;const char*, int&gt; m;
  m.insert( make_pair("test",5) );
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/map_operators.html">Map operators</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>key_comp </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  key_compare key_comp() const;
</PRE>
<P>The function key_comp() returns the function that compares keys.</P>
<P>key_comp() runs in <A 
href="../complexity.html">constant time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/value_comp.html">value_comp</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>lower_bound </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  iterator lower_bound( const <A href="../containers.html">key_type</A>&amp; key );
</PRE>
<P>The lower_bound() function returns an iterator to the first element which has 
a value greater than or equal to key.</P>
<P>lower_bound() runs in <A 
href="../complexity.html">logarithmic time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/upper_bound.html">upper_bound</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>Map Constructors &amp; Destructors </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  map();
  map( const map&amp; m );
  map( iterator start, iterator end );
  map( iterator start, iterator end, const key_compare&amp; cmp );
  map( const key_compare&amp; cmp );
  ~map();
</PRE>
<P>The default constructor takes no arguments, creates a new instance of that 
map, and runs in <A href="../complexity.html">constant 
time</A>. The default copy constructor runs in <A 
href="../complexity.html">linear time</A> and can be 
used to create a new map that is a copy of the given map <EM>m</EM>.</P>
<P>You can also create a map that will contain a copy of the elements between 
<EM>start</EM> and <EM>end</EM>, or specify a comparison function <EM>cmp</EM>. 
<P>The default destructor is called when the map should be destroyed.</P>
<P>For example, the following code creates a map that associates a string with 
an integer:</P><PRE class=example-code>  struct strCmp {
    bool operator()( const char* s1, const char* s2 ) const {
      return strcmp( s1, s2 ) &lt; 0;
    }
  };

  ...

  map&lt;const char*, int, strCmp&gt; ages;
  ages["Homer"] = 38;
  ages["Marge"] = 37;
  ages["Lisa"] = 8;
  ages["Maggie"] = 1;
  ages["Bart"] = 11;

  cout &lt;&lt; "Bart is " &lt;&lt; ages["Bart"] &lt;&lt; " years old" &lt;&lt; endl;
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/map_operators.html">Map Operators</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>Map operators </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  <A href="../containers.html">TYPE</A>&amp; operator[]( const <A href="../containers.html">key_type</A>&amp; key );
  map operator=(const map&amp; c2);
  bool operator==(const map&amp; c1, const map&amp; c2);
  bool operator!=(const map&amp; c1, const map&amp; c2);
  bool operator&lt;(const map&amp; c1, const map&amp; c2);
  bool operator&gt;(const map&amp; c1, const map&amp; c2);
  bool operator&lt;=(const map&amp; c1, const map&amp; c2);
  bool operator&gt;=(const map&amp; c1, const map&amp; c2);
</PRE>
<P>Maps can be compared and assigned with the standard comparison operators: ==, 
!=, &lt;=, &gt;=, &lt;, &gt;, and =. Individual elements of a map can be 
examined with the [] operator.</P>
<P>Performing a comparison or assigning one map to another takes <A 
href="../complexity.html">linear time</A>.</P>
<P>Two maps are equal if:</P>
<OL>
  <LI>Their size is the same, and 
  <LI>Each member in location <EM>i</EM> in one map is equal to the the member 
  in location <EM>i</EM> in the other map. </LI></OL>
<P>Comparisons among maps are done lexicographically.</P>
<P>For example, the following code defines a map between strings and integers 
and loads values into the map using the [] operator:</P><PRE class=example-code>  struct strCmp {
    bool operator()( const char* s1, const char* s2 ) const {
      return strcmp( s1, s2 ) &lt; 0;
    }
  };

  map&lt;const char*, int, strCmp&gt; ages;
  ages["Homer"] = 38;
  ages["Marge"] = 37;
  ages["Lisa"] = 8;
  ages["Maggie"] = 1;
  ages["Bart"] = 11;

  cout &lt;&lt; "Bart is " &lt;&lt; ages["Bart"] &lt;&lt; " years old" &lt;&lt; endl;

  cout &lt;&lt; "In alphabetical order: " &lt;&lt; endl;
  for( map&lt;const char*, int, strCmp&gt;::iterator iter = ages.begin(); iter != ages.end(); iter++ ) {
    cout &lt;&lt; (*iter).first &lt;&lt; " is " &lt;&lt; (*iter).second &lt;&lt; " years old" &lt;&lt; endl;
  }
</PRE>
<P>When run, the above code displays this output:</P><PRE class=example-code>  Bart is 11 years old
  In alphabetical order:
  Bart is 11 years old
  Homer is 38 years old
  Lisa is 8 years old
  Maggie is 1 years old
  Marge is 37 years old  
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/insert.html">insert</A><BR><A 
href="../cppmap/map_constructors.html">Map Constructors 
&amp; Destructors</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>max_size </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  <STRONG>size_type</STRONG> max_size() const;
</PRE>
<P>The max_size() function returns the maximum number of elements that the map 
can hold. The max_size() function should not be confused with the <A 
href="../cppmap/size.html">size</A>() or (C++ Strings) 
<A href="../cppstring/capacity.html">capacity</A>() 
functions, which return the number of elements currently in the map and the the 
number of elements that the map will be able to hold before more memory will 
have to be allocated, respectively.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/size.html">size</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>rbegin </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  <A href="../iterators.html">reverse_iterator</A> rbegin();
  const_<A href="../iterators.html">reverse_iterator</A> rbegin() const;
</PRE>
<P>The rbegin() function returns a <A 
href="../iterators.html">reverse_iterator</A> to the 
end of the current map.</P>
<P>rbegin() runs in <A 
href="../complexity.html">constant time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/begin.html">begin</A><BR><A 
href="../cppmap/end.html">end</A><BR><A 
href="../cppmap/rend.html">rend</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>rend </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  <A href="../iterators.html">reverse_iterator</A> rend();
  const_<A href="../iterators.html">reverse_iterator</A> rend() const;
</PRE>
<P>The function rend() returns a <A 
href="../iterators.html">reverse_iterator</A> to the 
beginning of the current map.</P>
<P>rend() runs in <A href="../complexity.html">constant 
time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/begin.html">begin</A><BR><A 
href="../cppmap/end.html">end</A><BR><A 
href="../cppmap/rbegin.html">rbegin</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>size </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  <STRONG>size_type</STRONG> size() const;
</PRE>
<P>The size() function returns the number of elements in the current map.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/empty.html">empty</A><BR><A 
href="../cppmap/max_size.html">max_size</A><BR></DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>swap </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  void swap( const container&amp; from );
</PRE>
<P>The swap() function exchanges the elements of the current map with those of 
<EM>from</EM>. This function operates in <A 
href="../complexity.html">constant time</A>.</P>
<P>For example, the following code uses the swap() function to exchange the 
values of two strings:</P><PRE class=example-code>   string first( "This comes first" );
   string second( "And this is second" );
   first.swap( second );
   cout &lt;&lt; first &lt;&lt; endl;
   cout &lt;&lt; second &lt;&lt; endl;          
</PRE>
<P>The above code displays:</P><PRE class=example-code>   And this is second
   This comes first             
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content>(C++ Lists) <A 
href="../cpplist/splice.html">splice</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>upper_bound </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  iterator upper_bound( const <A href="../containers.html">key_type</A>&amp; key );
</PRE>
<P>The function upper_bound() returns an iterator to the first element in the 
map with a key greater than <EM>key</EM>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/lower_bound.html">lower_bound</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>value_comp </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;map&gt;
  value_compare value_comp() const;
</PRE>
<P>The value_comp() function returns the function that compares values.</P>
<P>value_comp() runs in <A 
href="../complexity.html">constant time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppmap/key_comp.html">key_comp</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>
</BODY></HTML>
