<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0046)http://www.cppreference.com/cppvector/all.html -->
<HTML><HEAD><TITLE>C++ Vectors</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2900.2995" name=GENERATOR><LINK 
href="all.files/cppreference.css" type=text/css rel=stylesheet></HEAD>
<BODY>
<TABLE>
  <TBODY>
  <TR>
    <TD>
      <DIV class=body-content>
      <DIV class=header-box><A 
      href="../index.html">cppreference.com</A> &gt; <A 
      href="../cppvector/index.html">C++ Vectors</A> 
      </DIV>
      <DIV class=name-format>assign </DIV>
      <DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  void assign( <STRONG>size_type</STRONG> num, const <A href="../containers.html">TYPE</A>&amp; val );
  void assign( <A href="../iterators.html">input_iterator</A> start, <A href="../iterators.html">input_iterator</A> end );
</PRE>
      <P>The assign() function either gives the current vector the values from 
      <EM>start</EM> to <EM>end</EM>, or gives it <EM>num</EM> copies of 
      <EM>val</EM>.</P>
      <P>This function will destroy the previous contents of the vector.</P>
      <P>For example, the following code uses assign() to put 10 copies of the 
      integer 42 into a vector:</P><PRE class=example-code> vector&lt;int&gt; v;
 v.assign( 10, 42 );
 for( int i = 0; i &lt; v.size(); i++ ) {
   cout &lt;&lt; v[i] &lt;&lt; " ";
 }
 cout &lt;&lt; endl;            
</PRE>
      <P>The above code displays the following output:</P><PRE class=example-code> 42 42 42 42 42 42 42 42 42 42          
</PRE>
      <P>The next example shows how assign() can be used to copy one vector to 
      another:</P><PRE class=example-code> vector&lt;int&gt; v1;
 for( int i = 0; i &lt; 10; i++ ) {
   v1.push_back( i );
 }              

 vector&lt;int&gt; v2;
 v2.assign( v1.begin(), v1.end() );             

 for( int i = 0; i &lt; v2.size(); i++ ) {
   cout &lt;&lt; v2[i] &lt;&lt; " ";
 }
 cout &lt;&lt; endl;            
</PRE>
      <P>When run, the above code displays the following output:</P><PRE class=example-code> 0 1 2 3 4 5 6 7 8 9            
</PRE>
      <DIV class=related-name-format>Related topics: </DIV>
      <DIV class=related-content>(C++ Strings) <A 
      href="../cppstring/assign1.html">assign</A><BR><A 
      href="../cppvector/insert.html">insert</A><BR><A 
      href="../cppvector/push_back.html">push_back</A><BR>(C++ 
      Lists) <A 
      href="../cpplist/push_front.html">push_front</A> 
      </DIV></DIV></TD></TR></TBODY></TABLE>
<HR>

<DIV class=name-format>at </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <A href="../containers.html">TYPE</A>&amp; at( <STRONG>size_type</STRONG> loc );
  const <A href="../containers.html">TYPE</A>&amp; at( <STRONG>size_type</STRONG> loc ) const;
</PRE>
<P>The at() function returns a reference to the element in the vector at index 
<EM>loc</EM>. The at() function is safer than the [] operator, because it won't 
let you reference items outside the bounds of the vector.</P>
<P>For example, consider the following code:</P><PRE class=example-code> vector&lt;int&gt; v( 5, 1 );
 for( int i = 0; i &lt; 10; i++ ) {
   cout &lt;&lt; "Element " &lt;&lt; i &lt;&lt; " is " &lt;&lt; v[i] &lt;&lt; endl;
 }              
</PRE>
<P>This code overrunns the end of the vector, producing potentially dangerous 
results. The following code would be much safer:</P><PRE class=example-code> vector&lt;int&gt; v( 5, 1 );
 for( int i = 0; i &lt; 10; i++ ) {
   cout &lt;&lt; "Element " &lt;&lt; i &lt;&lt; " is " &lt;&lt; v.at(i) &lt;&lt; endl;
 }              
</PRE>
<P>Instead of attempting to read garbage values from memory, the at() function 
will realize that it is about to overrun the vector and will throw an 
exception.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/vector_operators.html">Vector 
operators</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>back </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <A href="../containers.html">TYPE</A>&amp; back();
  const <A href="../containers.html">TYPE</A>&amp; back() const;
</PRE>
<P>The back() function returns a reference to the last element in the 
vector.</P>
<P>For example:</P><PRE class=example-code> vector&lt;int&gt; v;
 for( int i = 0; i &lt; 5; i++ ) {
   v.push_back(i);
 }
 cout &lt;&lt; "The first element is " &lt;&lt; v.front()
      &lt;&lt; " and the last element is " &lt;&lt; v.back() &lt;&lt; endl;           
</PRE>
<P>This code produces the following output:</P><PRE class=example-code> The first element is 0 and the last element is 4               
</PRE>
<P>The back() function runs in <A 
href="../complexity.html">constant time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/front.html">front</A><BR><A 
href="../cppvector/pop_back.html">pop_back</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>begin </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  iterator begin();
  const_iterator begin() const;
</PRE>
<P>The function begin() returns an iterator to the first element of the vector. 
begin() should run in <A 
href="../complexity.html">constant time</A>.</P>
<P>For example, the following code uses begin() to initialize an iterator that 
is used to traverse a list:</P><PRE class=example-code>   // Create a list of characters
   list&lt;char&gt; charList;
   for( int i=0; i &lt; 10; i++ ) {
     charList.push_front( i + 65 );
   }
   // Display the list
   list&lt;char&gt;::iterator theIterator;
   for( theIterator = charList.begin(); theIterator != charList.end(); theIterator++ ) {
     cout &lt;&lt; *theIterator;
   }            
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/end.html">end</A><BR><A 
href="../cppvector/rbegin.html">rbegin</A><BR><A 
href="../cppvector/rend.html">rend</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>capacity </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <STRONG>size_type</STRONG> capacity() const;
</PRE>
<P>The capacity() function returns the number of elements that the vector can 
hold before it will need to allocate more space.</P>
<P>For example, the following code uses two different methods to set the 
capacity of two vectors. One method passes an argument to the constructor that 
suggests an initial size, the other method calls the reserve function to achieve 
a similar goal:</P><PRE class=example-code> vector&lt;int&gt; v1(10);
 cout &lt;&lt; "The capacity of v1 is " &lt;&lt; v1.capacity() &lt;&lt; endl;
 vector&lt;int&gt; v2;
 v2.reserve(20);
 cout &lt;&lt; "The capacity of v2 is " &lt;&lt; v2.capacity() &lt;&lt; endl;         
</PRE>
<P>When run, the above code produces the following output:</P><PRE class=example-code> The capacity of v1 is 10
 The capacity of v2 is 20               
</PRE>
<P>C++ containers are designed to grow in size dynamically. This frees the 
programmer from having to worry about storing an arbitrary number of elements in 
a container. However, sometimes the programmer can improve the performance of 
her program by giving hints to the compiler about the size of the containers 
that the program will use. These hints come in the form of the <A 
href="../cppvector/reserve.html">reserve</A>() function 
and the constructor used in the above example, which tell the compiler how large 
the container is expected to get.</P>
<P>The capacity() function runs in <A 
href="../complexity.html">constant time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/reserve.html">reserve</A><BR><A 
href="../cppvector/resize.html">resize</A><BR><A 
href="../cppvector/size.html">size</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>clear </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  void clear();
</PRE>
<P>The function clear() deletes all of the elements in the vector. clear() runs 
in <A href="../complexity.html">linear time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/erase.html">erase</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>empty </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  bool empty() const;
</PRE>
<P>The empty() function returns true if the vector has no elements, false 
otherwise.</P>
<P>For example, the following code uses empty() as the stopping condition on a 
(C/C++ Keywords) <A 
href="../keywords/while.html">while</A> loop to clear a 
vector and display its contents in reverse order:</P><PRE class=example-code> vector&lt;int&gt; v;
 for( int i = 0; i &lt; 5; i++ ) {
   v.push_back(i);
 }
 while( !v.empty() ) {
   cout &lt;&lt; v.back() &lt;&lt; endl;
   v.pop_back();
 }              
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/size.html">size</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>end </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  iterator end();
  const_iterator end() const;
</PRE>
<P>The end() function returns an iterator just past the end of the vector.</P>
<P>Note that before you can access the last element of the vector using an 
iterator that you get from a call to end(), you'll have to decrement the 
iterator first. This is because end() doesn't point to the end of the vector; it 
points <STRONG>just past the end of the vector</STRONG>.</P>
<P>For example, in the following code, the first "cout" statement will display 
garbage, whereas the second statement will actually display the last element of 
the vector:</P><PRE class=example-code>  vector&lt;int&gt; v1;
  v1.push_back( 0 );
  v1.push_back( 1 );
  v1.push_back( 2 );
  v1.push_back( 3 );

  int bad_val = *(v1.end());
  cout &lt;&lt; "bad_val is " &lt;&lt; bad_val &lt;&lt; endl;

  int good_val = *(v1.end() - 1);
  cout &lt;&lt; "good_val is " &lt;&lt; good_val &lt;&lt; endl;
</PRE>
<P>The next example shows how <A 
href="../cppvector/begin.html">begin</A>() and end() 
can be used to iterate through all of the members of a vector:</P><PRE class=example-code> vector&lt;int&gt; v1( 5, 789
  ); vector&lt;int&gt;::iterator it; for( it = v1.begin(); it !=
  v1.end(); it++ ) { cout &lt;&lt; *it &lt;&lt; endl; } </PRE>
<P>The iterator is initialized with a call to <A 
href="../cppvector/begin.html">begin</A>(). After the 
body of the loop has been executed, the iterator is incremented and tested to 
see if it is equal to the result of calling end(). Since end() returns an 
iterator pointing to an element just after the last element of the vector, the 
loop will only stop once all of the elements of the vector have been 
displayed.</P>
<P>end() runs in <A href="../complexity.html">constant 
time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/begin.html">begin</A><BR><A 
href="../cppvector/rbegin.html">rbegin</A><BR><A 
href="../cppvector/rend.html">rend</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>erase </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  iterator erase( iterator loc );
  iterator erase( iterator start, iterator end );
</PRE>
<P>The erase() function either deletes the element at location <EM>loc</EM>, or 
deletes the elements between <EM>start</EM> and <EM>end</EM> (including 
<EM>start</EM> but not including <EM>end</EM>). The return value is the element 
after the last element erased.</P>
<P>The first version of erase (the version that deletes a single element at 
location <EM>loc</EM>) runs in <A 
href="../complexity.html">constant time</A> for lists 
and <A href="../complexity.html">linear time</A> for 
vectors, dequeues, and strings. The multiple-element version of erase always 
takes <A href="../complexity.html">linear time</A>.</P>
<P>For example:</P><PRE class=example-code> // Create a vector, load it with the first ten characters of the alphabet
 vector&lt;char&gt; alphaVector;
 for( int i=0; i &lt; 10; i++ ) {
   alphaVector.push_back( i + 65 );
 }
 int size = alphaVector.size();
 vector&lt;char&gt;::iterator startIterator;
 vector&lt;char&gt;::iterator tempIterator;
 for( int i=0; i &lt; size; i++ ) {
   startIterator = alphaVector.begin();
   alphaVector.erase( startIterator );
   // Display the vector
   for( tempIterator = alphaVector.begin(); tempIterator != alphaVector.end(); tempIterator++ ) {
     cout &lt;&lt; *tempIterator;
   }
   cout &lt;&lt; endl;
 }              
</PRE>
<P>That code would display the following output:</P><PRE class=example-code> BCDEFGHIJ
 CDEFGHIJ
 DEFGHIJ
 EFGHIJ
 FGHIJ
 GHIJ
 HIJ
 IJ
 J              
</PRE>
<P>In the next example, erase() is called with two iterators to delete a range 
of elements from a vector:</P><PRE class=example-code> // create a vector, load it with the first ten characters of the alphabet
 vector&lt;char&gt; alphaVector;
 for( int i=0; i &lt; 10; i++ ) {
   alphaVector.push_back( i + 65 );
 }
 // display the complete vector
 for( int i = 0; i &lt; alphaVector.size(); i++ ) {
   cout &lt;&lt; alphaVector[i];
 }
 cout &lt;&lt; endl;            

 // use erase to remove all but the first two and last three elements
 // of the vector
 alphaVector.erase( alphaVector.begin()+2, alphaVector.end()-3 );
 // display the modified vector
 for( int i = 0; i &lt; alphaVector.size(); i++ ) {
   cout &lt;&lt; alphaVector[i];
 }
 cout &lt;&lt; endl;            
</PRE>
<P>When run, the above code displays:</P><PRE class=example-code> ABCDEFGHIJ
 ABHIJ          
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/clear.html">clear</A><BR><A 
href="../cppvector/insert.html">insert</A><BR><A 
href="../cppvector/pop_back.html">pop_back</A><BR>(C++ 
Lists) <A 
href="../cpplist/pop_front.html">pop_front</A><BR>(C++ 
Lists) <A 
href="../cpplist/remove.html">remove</A><BR>(C++ Lists) 
<A href="../cpplist/remove_if.html">remove_if</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>front </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <A href="../containers.html">TYPE</A>&amp; front();
  const <A href="../containers.html">TYPE</A>&amp; front() const;
</PRE>
<P>The front() function returns a reference to the first element of the vector, 
and runs in <A href="../complexity.html">constant 
time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/back.html">back</A><BR>(C++ Lists) 
<A 
href="../cpplist/pop_front.html">pop_front</A><BR>(C++ 
Lists) <A 
href="../cpplist/push_front.html">push_front</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>insert </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  iterator insert( iterator loc, const <A href="../containers.html">TYPE</A>&amp; val );
  void insert( iterator loc, <STRONG>size_type</STRONG> num, const <A href="../containers.html">TYPE</A>&amp; val );
  template&lt;<A href="../containers.html">TYPE</A>&gt; void insert( iterator loc, <A href="../iterators.html">input_iterator</A> start, <A href="../iterators.html">input_iterator</A> end );
</PRE>
<P>The insert() function either:</P>
<UL>
  <LI>inserts <EM>val</EM> before <EM>loc</EM>, returning an iterator to the 
  element inserted, 
  <LI>inserts <EM>num</EM> copies of <EM>val</EM> before <EM>loc</EM>, or 
  <LI>inserts the elements from <EM>start</EM> to <EM>end</EM> before 
  <EM>loc</EM>. </LI></UL>
<P>Note that inserting elements into a vector can be relatively time-intensive, 
since the underlying data structure for a vector is an array. In order to insert 
data into an array, you might need to displace a lot of the elements of that 
array, and this can take <A 
href="../complexity.html">linear time</A>. If you are 
planning on doing a lot of insertions into your vector and you care about speed, 
you might be better off using a container that has a linked list as its 
underlying data structure (such as a <A 
href="../cpplist/index.html">List</A> or a <A 
href="../cppdeque/index.html">Deque</A>).</P>
<P>For example, the following code uses the insert() function to splice four 
copies of the character 'C' into a vector of characters:</P><PRE class=example-code> // Create a vector, load it with the first 10 characters of the alphabet
 vector&lt;char&gt; alphaVector;
 for( int i=0; i &lt; 10; i++ ) {
   alphaVector.push_back( i + 65 );
 }              

 // Insert four C's into the vector
 vector&lt;char&gt;::iterator theIterator = alphaVector.begin();
 alphaVector.insert( theIterator, 4, 'C' );             

 // Display the vector
 for( theIterator = alphaVector.begin(); theIterator != alphaVector.end(); theIterator++ )    {
   cout &lt;&lt; *theIterator;
 }              
</PRE>
<P>This code would display:</P><PRE class=example-code> CCCCABCDEFGHIJ         
</PRE>
<P>Here is another example of the insert() function. In this code, insert() is 
used to append the contents of one vector onto the end of another:</P><PRE class=example-code>  vector&lt;int&gt; v1;
  v1.push_back( 0 );
  v1.push_back( 1 );
  v1.push_back( 2 );
  v1.push_back( 3 );

  vector&lt;int&gt; v2;
  v2.push_back( 5 );
  v2.push_back( 6 );
  v2.push_back( 7 );
  v2.push_back( 8 );

  cout &lt;&lt; "Before, v2 is: ";
  for( int i = 0; i &lt; v2.size(); i++ ) {
    cout &lt;&lt; v2[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;

  v2.insert( v2.end(), v1.begin(), v1.end() );

  cout &lt;&lt; "After, v2 is: ";
  for( int i = 0; i &lt; v2.size(); i++ ) {
    cout &lt;&lt; v2[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
</PRE>
<P>When run, this code displays:</P><PRE class=example-code>  Before, v2 is: 5 6 7 8
  After, v2 is: 5 6 7 8 0 1 2 3
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/assign.html">assign</A><BR><A 
href="../cppvector/erase.html">erase</A><BR><A 
href="../cppvector/push_back.html">push_back</A><BR>(C++ 
Lists) <A 
href="../cpplist/merge.html">merge</A><BR>(C++ Lists) 
<A 
href="../cpplist/push_front.html">push_front</A><BR>(C++ 
Lists) <A href="../cpplist/splice.html">splice</A> 
</DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>max_size </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <STRONG>size_type</STRONG> max_size() const;
</PRE>
<P>The max_size() function returns the maximum number of elements that the 
vector can hold. The max_size() function should not be confused with the <A 
href="../cppvector/size.html">size</A>() or <A 
href="../cppvector/capacity.html">capacity</A>() 
functions, which return the number of elements currently in the vector and the 
the number of elements that the vector will be able to hold before more memory 
will have to be allocated, respectively.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/size.html">size</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>pop_back </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  void pop_back();
</PRE>
<P>The pop_back() function removes the last element of the vector.</P>
<P>pop_back() runs in <A 
href="../complexity.html">constant time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/back.html">back</A><BR><A 
href="../cppvector/erase.html">erase</A><BR>(C++ Lists) 
<A href="../cpplist/pop_front.html">pop_front</A><BR><A 
href="../cppvector/push_back.html">push_back</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>push_back </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  void push_back( const <A href="../containers.html">TYPE</A>&amp; val );
</PRE>
<P>The push_back() function appends <EM>val</EM> to the end of the vector.</P>
<P>For example, the following code puts 10 integers into a list:</P><PRE class=example-code>   list&lt;int&gt; the_list;
   for( int i = 0; i &lt; 10; i++ )
     the_list.push_back( i );           
</PRE>
<P>When displayed, the resulting list would look like this:</P><PRE class=example-code> 0 1 2 3 4 5 6 7 8 9            
</PRE>
<P>push_back() runs in <A 
href="../complexity.html">constant time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/assign.html">assign</A><BR><A 
href="../cppvector/insert.html">insert</A><BR><A 
href="../cppvector/pop_back.html">pop_back</A><BR>(C++ 
Lists) <A 
href="../cpplist/push_front.html">push_front</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>rbegin </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <A href="../iterators.html">reverse_iterator</A> rbegin();
  const_<A href="../iterators.html">reverse_iterator</A> rbegin() const;
</PRE>
<P>The rbegin() function returns a <A 
href="../iterators.html">reverse_iterator</A> to the 
end of the current vector.</P>
<P>rbegin() runs in <A 
href="../complexity.html">constant time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/begin.html">begin</A><BR><A 
href="../cppvector/end.html">end</A><BR><A 
href="../cppvector/rend.html">rend</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>rend </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <A href="../iterators.html">reverse_iterator</A> rend();
  const_<A href="../iterators.html">reverse_iterator</A> rend() const;
</PRE>
<P>The function rend() returns a <A 
href="../iterators.html">reverse_iterator</A> to the 
beginning of the current vector.</P>
<P>rend() runs in <A href="../complexity.html">constant 
time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/begin.html">begin</A><BR><A 
href="../cppvector/end.html">end</A><BR><A 
href="../cppvector/rbegin.html">rbegin</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>reserve </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  void reserve( <STRONG>size_type</STRONG> size );
</PRE>
<P>The reserve() function sets the capacity of the vector to at least 
<EM>size</EM>.</P>
<P>reserve() runs in <A 
href="../complexity.html">linear time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/capacity.html">capacity</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>resize </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  void resize( <STRONG>size_type</STRONG> num, const <A href="../containers.html">TYPE</A>&amp; val = <A href="../containers.html">TYPE</A>() );
</PRE>
<P>The function resize() changes the size of the vector to <EM>size</EM>. If 
<EM>val</EM> is specified then any newly-created elements will be initialized to 
have a value of <EM>val</EM>.</P>
<P>This function runs in <A 
href="../complexity.html">linear time</A>.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/vector_constructors.html">Vector 
constructors &amp; destructors</A><BR><A 
href="../cppvector/capacity.html">capacity</A><BR><A 
href="../cppvector/size.html">size</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>size </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <STRONG>size_type</STRONG> size() const;
</PRE>
<P>The size() function returns the number of elements in the current vector.</P>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/capacity.html">capacity</A><BR><A 
href="../cppvector/empty.html">empty</A><BR>(C++ 
Strings) <A 
href="../cppstring/length.html">length</A><BR><A 
href="../cppvector/max_size.html">max_size</A><BR><A 
href="../cppvector/resize.html">resize</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>swap </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  void swap( const container&amp; from );
</PRE>
<P>The swap() function exchanges the elements of the current vector with those 
of <EM>from</EM>. This function operates in <A 
href="../complexity.html">constant time</A>.</P>
<P>For example, the following code uses the swap() function to exchange the 
values of two strings:</P><PRE class=example-code>   string first( "This comes first" );
   string second( "And this is second" );
   first.swap( second );
   cout &lt;&lt; first &lt;&lt; endl;
   cout &lt;&lt; second &lt;&lt; endl;          
</PRE>
<P>The above code displays:</P><PRE class=example-code>   And this is second
   This comes first             
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content>(C++ Lists) <A 
href="../cpplist/splice.html">splice</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>Vector constructors </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  vector();
  vector( const vector&amp; c );
  vector( <STRONG>size_type</STRONG> num, const <A href="../containers.html">TYPE</A>&amp; val = <A href="../containers.html">TYPE</A>() );
  vector( <A href="../iterators.html">input_iterator</A> start, <A href="../iterators.html">input_iterator</A> end );
  ~vector();
</PRE>
<P>The default vector constructor takes no arguments, creates a new instance of 
that vector.</P>
<P>The second constructor is a default copy constructor that can be used to 
create a new vector that is a copy of the given vector <EM>c</EM>.</P>
<P>The third constructor creates a vector with space for <EM>num</EM> objects. 
If <EM>val</EM> is specified, each of those objects will be given that value. 
For example, the following code creates a vector consisting of five copies of 
the integer 42:</P><PRE class=example-code> vector&lt;int&gt; v1( 5, 42 );         
</PRE>
<P>The last constructor creates a vector that is initialized to contain the 
elements between <EM>start</EM> and <EM>end</EM>. For example:</P><PRE class=example-code> // create a vector of random integers
 cout &lt;&lt; "original vector: ";
 vector&lt;int&gt; v;
 for( int i = 0; i &lt; 10; i++ ) {
   int num = (int) rand() % 10;
   cout &lt;&lt; num &lt;&lt; " ";
   v.push_back( num );
 }
 cout &lt;&lt; endl;            

 // find the first element of v that is even
 vector&lt;int&gt;::iterator iter1 = v.begin();
 while( iter1 != v.end() &amp;&amp; *iter1 % 2 != 0 ) {
   iter1++;
 }              

 // find the last element of v that is even
 vector&lt;int&gt;::iterator iter2 = v.end();
 do {
   iter2--;
 } while( iter2 != v.begin() &amp;&amp; *iter2 % 2 != 0 );              

 // only proceed if we find both numbers
 if( iter1 != v.end() &amp;&amp; iter2 != v.begin() ) {
   cout &lt;&lt; "first even number: " &lt;&lt; *iter1 &lt;&lt; ", last even number: " &lt;&lt; *iter2 &lt;&lt; endl;         

   cout &lt;&lt; "new vector: ";
   vector&lt;int&gt; v2( iter1, iter2 );
   for( int i = 0; i &lt; v2.size(); i++ ) {
     cout &lt;&lt; v2[i] &lt;&lt; " ";
   }
   cout &lt;&lt; endl;
 }
</PRE>
<P>When run, this code displays the following output:</P><PRE class=example-code> original vector: 1 9 7 9 2 7 2 1 9 8
 first even number: 2, last even number: 8
 new vector: 2 7 2 1 9          
</PRE>
<P>All of these constructors run in <A 
href="../complexity.html">linear time</A> except the 
first, which runs in <A 
href="../complexity.html">constant time</A>.</P>
<P>The default destructor is called when the vector should be destroyed.</P>
<DIV></DIV></TD></TR></TABLE>
<HR>

<DIV class=name-format>Vector operators </DIV>
<DIV class=syntax-name-format>Syntax: </DIV><PRE class=syntax-box>  #include &lt;vector&gt;
  <A href="../containers.html">TYPE</A>&amp; operator[]( <STRONG>size_type</STRONG> index );
  const <A href="../containers.html">TYPE</A>&amp; operator[]( <STRONG>size_type</STRONG> index ) const;
  vector operator=(const vector&amp; c2);
  bool operator==(const vector&amp; c1, const vector&amp; c2);
  bool operator!=(const vector&amp; c1, const vector&amp; c2);
  bool operator&lt;(const vector&amp; c1, const vector&amp; c2);
  bool operator&gt;(const vector&amp; c1, const vector&amp; c2);
  bool operator&lt;=(const vector&amp; c1, const vector&amp; c2);
  bool operator&gt;=(const vector&amp; c1, const vector&amp; c2);
</PRE>
<P>All of the C++ containers can be compared and assigned with the standard 
comparison operators: ==, !=, &lt;=, &gt;=, &lt;, &gt;, and =. Individual 
elements of a vector can be examined with the [] operator.</P>
<P>Performing a comparison or assigning one vector to another takes <A 
href="../complexity.html">linear time</A>. The [] 
operator runs in <A href="../complexity.html">constant 
time</A>.</P>
<P>Two vectors are equal if:</P>
<OL>
  <LI>Their size is the same, and 
  <LI>Each member in location i in one vector is equal to the the member in 
  location i in the other vector. </LI></OL>
<P>Comparisons among vectors are done lexicographically.</P>
<P>For example, the following code uses the [] operator to access all of the 
elements of a vector:</P><PRE class=example-code> vector&lt;int&gt; v( 5, 1 );
 for( int i = 0; i &lt; v.size(); i++ ) {
   cout &lt;&lt; "Element " &lt;&lt; i &lt;&lt; " is " &lt;&lt; v[i] &lt;&lt; endl;
 }              
</PRE>
<DIV class=related-name-format>Related topics: </DIV>
<DIV class=related-content><A 
href="../cppvector/at.html">at</A> </DIV>
<DIV></DIV></TD></TR></TABLE>
<HR>
</BODY></HTML>
